---
title: "Transmittance_transformation"
date: "`r Sys.Date()`"
format: html
self-contained: true
theme: cosmo
editor: source
code-fold: true
---

**Objectives:**  
Check if the model can retrieve the community niche if the transmittance is not loged, and if it's better with or witout log transfomation of the transmittance.

loo ?

Put as presences all the trees of the community, and as absences a uniform, on transmittance loged or not.
Then plot de presence probabilities predictions on x-axis loged or not.
-> 2 models, 4 panels

```{r, packages, include = F}
library(readr)
library(rstan)
rstan_options(auto_write = TRUE) # option pour ne pas recompiler à chaque fois - gain de temps
# options(mc.cores = parallel::detectCores()) #option pour ajouter des coeurs au calcul
rstan_options(disable_march_warning = TRUE)
library(bayesplot)
library(rstanarm) # for Bayesian automatic regression modelling using stan
library(brms) # Bayesian generalized multivariate non-linear multilevel models using stan
library(foreach) # parallisation
library(parallel)
library(tidyverse)
```

# Prepare data
```{r, include=F}
Inv <- read_csv("D:/Mes Donnees/PhD/Inventories/Data/Understory/Paracou/P16_Paracou_InvandEnv.csv") %>% 
  select(idTree, ScientificName, Strategy, Transmittance) %>% 
  filter(!is.na(Transmittance)) %>% 
  mutate(logTransmittance = log(Transmittance)) %>% 
  mutate(Presence = 1) %>% 
  sample_frac(0.1)
```

# Create absence uniform data
```{r}
Abs <- data.frame(
  Transmittance = seq(min(Inv$Transmittance), max(Inv$Transmittance), length.out=nrow(Inv)),
  logTransmittance = seq(min(Inv$logTransmittance), max(Inv$logTransmittance), length.out=nrow(Inv)),
  Presence = 0
) 

All <- bind_rows(Inv, Abs)
```

```{r}
for(d in c("Inv", "Abs")){
  for(var in c("Transmittance", "logTransmittance"))
    print(
      ggplot(get(d), aes(x= get(var))) +
        geom_histogram() +
        theme_minimal() +
        labs(title= d,y="Abundance", x=var)
    )
}
median(Inv$logTransmittance) # -4
median(Inv$Transmittance) # 0.01
exp(-4)

rm(Abs, Inv)
```

# Model data as list
```{r, data list}
Np <- 50 # number of predictions

dataM_notlog <- list(N = nrow(All), 
                     Presence = All$Presence,
                     Environment = All$Transmittance,
                     # number of predictions
                     Np = Np,
                     # environment of predictions
                     Environmentp = seq(min(All$Transmittance), max(All$Transmittance), length.out = Np) 
)

dataM_log <- list(N = nrow(All), 
                  Presence = All$Presence,
                  Environment = All$logTransmittance,
                  # number of predictions
                  Np = Np,
                  # environment of predictions
                  Environmentp = seq(min(All$logTransmittance), max(All$logTransmittance), length.out = Np) 
)

# dataM
```


# Model
```{r, eval=F}
path <- "D:/Mes Donnees/PhD/R_codes/PhD/Modelisation/"

# quadratic - canonic form - concave forced without explicite priors
M_Quadra_forced <- stan_model(model_name = "Quadra_can_forced",
                              paste(path, "Stanfiles/Bernoulli_EnvOnly_quadratic_canonic_forced.stan", sep=''))
```
```{r}
readLines("D:/Mes Donnees/PhD/R_codes/PhD/Modelisation/Stanfiles/Bernoulli_EnvOnly_quadratic_canonic_forced.stan")
```


# Run models
```{r, eval=F}
gc()
fit_notlog <- sampling(M_Quadra_forced, data = dataM_notlog, chains = 4, cores=4, iter = 2000)

fit_log <- sampling(M_Quadra_forced, data = dataM_log, chains = 4, cores=4, iter = 2000)
```
-> not log
Avis : There were 2595 transitions after warmup that exceeded the maximum treedepth. Increase max_treedepth above 10. See
https://mc-stan.org/misc/warnings.html#maximum-treedepth-exceededAvis : Examine the pairs() plot to diagnose sampling problems
Avis : The largest R-hat is 1.35, indicating chains have not mixed.
Running the chains for more iterations may help. See
https://mc-stan.org/misc/warnings.html#r-hatAvis : Bulk Effective Samples Size (ESS) is too low, indicating posterior means and medians may be unreliable.
Running the chains for more iterations may help. See
https://mc-stan.org/misc/warnings.html#bulk-essAvis : Tail Effective Samples Size (ESS) is too low, indicating posterior variances and tail quantiles may be unreliable.
Running the chains for more iterations may help. See
https://mc-stan.org/misc/warnings.html#tail-ess


```{r, eval=F}
fits <- list(fit_notlog, fit_log)
names(fits) <- c("notlog", "log")

saveRDS(fits, file = "//amap-data.cirad.fr/work/users/VincyaneBadouard/Modelisation/Fits/TransmittanceTrans/Communitylogvsnotlog.rds")
```

```{r}
fits <- readRDS("//amap-data.cirad.fr/work/users/VincyaneBadouard/Modelisation/Fits/TransmittanceTrans/Communitylogvsnotlog.rds")
```

## Chains
```{r}
mcmc_trace(as.array(fits[["notlog"]]), 
           pars = c("a", "O", "gamma"),
           np = nuts_params(fits[["notlog"]])) +
  ggplot2::labs(title = "Not log")

mcmc_trace(as.array(fits[["log"]]), 
           pars = c("a", "O", "gamma"),
           np = nuts_params(fits[["log"]])) +
  labs(title = "Log")
```

# Predictions
```{r}
# form="log"
dataplot <- 
  lapply(as.list(names(fits)), function(form)
    data.frame(form = form, 
               x = dataM_notlog$Environmentp,
               logx = dataM_log$Environmentp,
               mu = apply(as.matrix(fits[[form]], pars = "p"), 2, median),
               t(apply(as.matrix(fits[[form]], pars = "p"), 2, 
                       quantile, probs = c(0.05, 0.95))),
               Opt = apply(as.matrix(fits[[form]], pars = "O"), 2, median),
               Opt = t(apply(as.matrix(fits[[form]], pars = "O"), 2,
                             quantile, probs = c(0.05, 0.95)))
               
    )) %>% 
  bind_rows()

# View(dataplot[[Log]])
```

```{r}
plot1 <- dataplot %>% filter(form=="log") %>% 
  ggplot(aes(x = logx)) +
  theme_minimal() +
  # Proba
  geom_point(aes(y = mu), size=0.7) +
  geom_ribbon(aes(ymin = `X5.`, ymax = `X95.`), color = 'red', alpha = 0.2) +
  
  # Optimum
  geom_vline(aes(xintercept = Opt), color = "#00AFBB", linewidth=1) + # exp to delog
  geom_vline(aes(xintercept = `Opt.5.`), linetype="dashed") +
  geom_vline(aes(xintercept = `Opt.95.`), linetype="dashed") +
  
  
  labs(title =  paste("Log"), y = "Presence probability", col= "Presence-absence")
# facet_wrap(~ form, scales = "fixed", nrow = 1)

plot2 <- dataplot %>% filter(form=="log") %>% 
  ggplot(aes(x = exp(logx))) +
  theme_minimal() +
  # Proba
  geom_point(aes(y = mu), size=0.7) +
  geom_ribbon(aes(ymin = `X5.`, ymax = `X95.`), color = 'red', alpha = 0.2) +
  
    # Optimum
  geom_vline(aes(xintercept = exp(Opt)), color = "#00AFBB", linewidth=1) + # exp to delog
  geom_vline(aes(xintercept = exp(`Opt.5.`)), linetype="dashed") +
  geom_vline(aes(xintercept = exp(`Opt.95.`)), linetype="dashed") +

  
  labs(title =  paste("Log - delog"), y = "Presence probability", col= "Presence-absence")

plot3 <- dataplot %>% filter(form=="notlog") %>% 
  ggplot(aes(x = x)) +
  theme_minimal() +
  # Proba
  geom_point(aes(y = mu), size=0.7) +
  geom_ribbon(aes(ymin = `X5.`, ymax = `X95.`), color = 'red', alpha = 0.2) +
  
    # Optimum
  # geom_vline(aes(xintercept = Opt), color = "#00AFBB", linewidth=1) + # exp to delog
  # geom_vline(aes(xintercept = `Opt.5.`), linetype="dashed") +
  # geom_vline(aes(xintercept = `Opt.95.`), linetype="dashed") +

  
  labs(title =  paste("Not log"), y = "Presence probability", col= "Presence-absence")
# facet_wrap(~ form, scales = "fixed", nrow = 1)

plot4 <- dataplot %>% filter(form=="notlog") %>% 
  ggplot(aes(x = log(x))) +
  theme_minimal() +
  # Proba
  geom_point(aes(y = mu), size=0.7) +
  geom_ribbon(aes(ymin = `X5.`, ymax = `X95.`), color = 'red', alpha = 0.2) +
  
    # Optimum
  # geom_vline(aes(xintercept = log(Opt)), color = "#00AFBB", linewidth=1) + # exp to delog
  # geom_vline(aes(xintercept = log(`Opt.5.`)), linetype="dashed") +
  # geom_vline(aes(xintercept = log(`Opt.95.`)), linetype="dashed") +

  
  labs(title =  paste("Not log - log"), y = "Presence probability", col= "Presence-absence")


ggpubr::ggarrange(plot1, plot2, plot3, plot4, ncol = 2, nrow = 2)
```

-> Optimum outside of the environmental range in the the non logged case.  
-> logged the transmittance permit a parabola and so to define an optimum defined at the real presence probability maximum.  

-> The log transformation of transmittance produces a parabola which can be used to define an optimum for the maximum presence of the community here.  In fact, the log transformation reduces the probability of a ‘sigmoid/concave at the extremes’, which is a form that goes beyond the definition of the environment and does not allow a precise definition of the niche optimum.

