---
title: "Quantile_residual_test"
subtitle: "On empty model"
format: html
self-contained: true
theme: cosmo
editor: source
code-fold: true
---

# Objective:
Check if quantile residuals have autocorelation when the **model is empty** (null model)

# Packages
```{r setup, include = F}
library(cmdstanr)
library(tidyverse)
library(sf)
library(patchwork)

sp <- 'Dicorynia_guianensis'
```

# Quantile residuals
randomization to achieve continuous residuals when the response variable is discrete
by inverting the fitted distribution function at each response value and finding the equivalent standard normal quantile.

It useful to routinely plot four realizations of the quantile residuals. Any pattern in the residuals which is not consistent across the realizations is then ignored.  

http://www.statsci.org/smyth/pubs/residual.html
https://www.rdocumentation.org/packages/statmod/versions/1.5.0/topics/qresiduals
https://github.com/cran/statmod/blob/f85e32011346fb75d2b967cf2aff1f2e01a10ba8/R/qres.R#L20-L36


```{r data}
path <- "D:/Mes Donnees/PhD/R_codes/PhD/Modelisation/"
load(paste(path, "Realdata/Realsp_25ha.Rdata", sep=''))

DATA <- datalist[[sp]] # only species in sp

```

```{r fit}
chain_path <- paste("../Chains/Null/", sp, sep="") # ".." for the he directory above the current one
fit <- as_cmdstan_fit(list.files(chain_path, full.names = TRUE)[1]) # only 1 chain
```

```{r, eval=F}
fit$draws(c("lp__", "theta")) %>% 
    mcmc_trace()
```

```{r Quantile residuals}
t <- fit$summary("theta", "median") %>% # parameters median
  pivot_wider(names_from = variable, values_from = median) %>% # as col
  mutate(data = list(dplyr::select(DATA, Presence, Xutm, Yutm,
                                   logTransmittance, logTWI, logDBH))) %>% # covariables
  unnest(data) %>%  
  rename(y=Presence) %>% 
  # Compute probabilities predictions
  mutate(p = arm::invlogit(theta)) %>%
  # Compute quantile residuals for bernoulli as statmod::qres.binom()
  mutate(u = runif(n = length(y), 
                   min = pbinom(y - 1, 1, p), # quantile binomial fct
                   max = pbinom(y, 1, p))) %>% 
  mutate(e = qnorm(u)) # quantile normal fct

```

# Residuals distribution
```{r}
xs <- split(t, f = t$y)

p1 <- ggplot(xs$`1`) +
  theme_minimal() +
  geom_histogram(aes(x=e), fill="#009E73", col="white") +
  labs(title = sp)

p2 <- p1 %+% xs$`0`
p1 + ggtitle("Presence")
p2 + ggtitle("Absence")
```

# QQ plot
Le terme de quantile-quantile provient du fait que l'on compare la position de certains quantiles dans la population observée avec leur position dans la population théorique.  
```{r QQ plot}
# QQ plot
ggplot(t, aes(sample = e)) +
  stat_qq_line() + # Black solid lines denote the null distribution
  stat_qq() + # quantile-quantile plot
  theme_bw()
```

```{r, eval =F}
car::qqPlot(t$e)

library(statmod)
fit <- glm(y~1,family=binomial,data=t)
fit$fitted.values <- t$p
all(t$p == fitted(fit))
car::qqPlot(statmod::qres.binom(fit))
```

# Binned residuals plot
```{r binned plot}
# Quantile residual
arm::binnedplot(t$p, t$e, nclass=NULL,
                xlab="Predictions", ylab="Average quantile residual",
                main="Binned residual plot",
                cex.pts=0.8, col.pts=1, col.int="gray")

arm::binnedplot(t$logTWI, t$e, nclass=NULL,
                xlab="logTWI", ylab="Average quantile residual",
                main="Binned residual plot",
                cex.pts=0.8, col.pts=1, col.int="gray")

arm::binnedplot(t$logTransmittance, t$e, nclass=NULL,
                xlab="logTransmittance", ylab="Average quantile residual",
                main="Binned residual plot",
                cex.pts=0.8, col.pts=1, col.int="gray")

arm::binnedplot(t$logDBH, t$e, nclass=NULL,
                xlab="logDBH", ylab="Average quantile residual",
                main="Binned residual plot",
                cex.pts=0.8, col.pts=1, col.int="gray")
```

```{r}
Residuals_covar <- t %>% pivot_longer(cols = c(logDBH, logTransmittance, logTWI),
                                      names_to = "Var", values_to = "Covar")
```

# Residus - relation with models variables
```{r}
xs <- split(Residuals_covar, f = Residuals_covar$y)

# Residuals_covar %>% 
p1 <- xs$`1` %>% 
  ggplot(aes(x= Covar, y= e)) +
  theme_minimal() +
  geom_point() +
  geom_smooth(method='lm', formula= y~x, col="red") +
  ggpubr::stat_cor(aes(label = ..r.label..),
                   label.x.npc = "centre", label.y.npc = "bottom", digits = 1, col="red") +
  theme(axis.title.x=element_blank()) +
  labs(y="Quantile residual") +
  facet_wrap(~Var, scales ="free", nrow = 2, ncol = 3)

p2 <- p1 %+% xs$`0`
p1 + ggtitle("Presence")
p2 + ggtitle("Absence")

# p1/p2 + plot_annotation(title = sp, tag_levels = list(c("1","0")))
```

# Resiuals spatial distribution
```{r, warning=F}
P16 <- terra::vect("D:/Mes Donnees/PhD/R_codes/PhD/test/Plot16.shp") %>% 
  st_as_sf()
TopoLevels <- st_read("D:/Mes Donnees/PhD/SIG_data/Topo_P16_4classes/Topo4Levels.shp") %>% 
  filter(Plot==16) %>% mutate(TopoTypeEn = ifelse(idTopo ==38, "Downslope", TopoTypeEn)) %>% 
  mutate(TopoTypeEn = recode(TopoTypeEn, "Plateau" = "Hilltop")) %>% 
  st_set_crs(st_crs(P16))

xs <- split(t, f = t$y)

p1 <- xs$`1` %>% 
  ggplot() + 
  theme_classic() +
  geom_sf(data = TopoLevels, aes(fill = TopoTypeEn), alpha = 0.2) +
  geom_sf(data = sf::st_cast(P16, "LINESTRING")) +
  scale_fill_manual(values = c("Hilltop" = "#009E73",
                               "Slope"= "#E7B800",
                               "Downslope"= "#bfe6eb", 
                               "Bottomland" = "#1f78b4"),
                    breaks = c("Hilltop", "Slope", "Downslope", "Bottomland")) +
  
  geom_point(aes(x = Xutm, y = Yutm, colour = e), size=0.7) + # , size=DBHcor
  # scale_size_continuous(range = c(0.5, 5)) +
  # coord_fixed(ratio = 1) +
  scale_color_gradient(low = "blue", high = "red") +
  theme(axis.title= element_blank(), axis.text= element_blank()) +
  facet_wrap(~ y, scales ="fixed") + 
  theme(legend.position="bottom") +
  guides(size = F, fill =F)

p2 <- p1 %+% xs$`0`

p1 + p2
```

# Moran
```{r Moran, warning = F}
t <- t %>% 
  sample_n(1000)
moran <- pgirmess::correlog(coords = data.frame(t$Xutm, t$Yutm),
                            t$e,
                            method = "Moran", nbclass = NULL) %>% 
  as.data.frame()
moran %>% 
  filter(dist.class < 500) %>% 
  ggplot(aes(x = dist.class, y = coef)) +
  ylim(-1, 1) +
  theme_minimal() +
  geom_hline(yintercept = 0) +
  geom_point(aes(alpha = p.value < 0.05)) +
  geom_line(col="red", linewidth =0.8) +
  xlab("Distance (m)") + ylab("Moran\'s I") +
  ggtitle(paste(sp,"- Residuals spatial auto-correlation"))
```
