---
params:
  species: Dicorynia_guianensis
title: "glmnet"
subtitle: "*`r params$sp`*"
format: html
self-contained: true
theme: cosmo
editor: source
code-fold: true
---

Glmnet fits generalized linear and similar models via **penalized maximum likelihood**.
It fits linear, **logistic** and multinomial, poisson, and Cox regression models.  

The function glmnet returns a sequence of models for the users to choose from. In many cases, users may prefer the software to select one of them. Cross-validation is perhaps the simplest and most widely used method for that task. **cv.glmnet** is the main function to do cross-validation here.  


```{r setup}
library(readr)
library(tidyverse)
library(glmnet)

sp <- params$species
```

```{r, include=F}
DATA <- read_csv(paste0("D:/Mes Donnees/PhD/Inventories/Data/Agregation/Eigenvectors/dataall_", sp, ".csv")) # %>% filter(Xutm > 285400 & Xutm < 285610 & Yutm > 581460 & Yutm < 581575)

y <- DATA$Presence # response vector
```

```{r, eval=F}
DATA %>% 
  arrange(Presence) %>% 
  ggplot(aes(x= Xutm, y= Yutm, col=as.factor(Presence))) +
  geom_point()
```

```{r only env}
form_ini <- as.formula(" Presence~ logTransmittance + I(logTransmittance^2) + logTWI")

x_ini <- model.matrix(form_ini,data=DATA)[,-1]

fit.glm <- glm(form_ini, data=DATA, family = "binomial")

fit.cv_ini <- cv.glmnet(x_ini, y, family = "binomial", type.measure = "auc") # according to ROC curve
coef.glmnet_ini <- coef(fit.cv_ini, s = "lambda.min") #  model coefficients at that value of λ
coef.glmnet_ini
```

lambda.min =  λ that gives minimum mean cross-validated error
```{r all}
form_full <- as.formula(paste("~ logTransmittance + I(logTransmittance^2) + logTWI",paste(paste0("V",1:200),collapse="+"),sep="+"))

x_full <- model.matrix(form_full, data=DATA)[,-1]

# cross-validation
Sys.time() 
fit.cv <- cv.glmnet(x_full, y, family = "binomial", type.measure = "auc") # according to ROC curve
Sys.time() # 6 min

fit.glmnet <- glmnet(x_full, y, family = "binomial", lambda = fit.cv$lambda.min)
coef.glmnet <- coef(fit.cv, s = "lambda.min") #  model coefficients at that value of λ
coef.glmnet

pred.glmnet <- predict(fit.glmnet, newx = x_full, type="response")
```

```{r}
plot(fit.cv)
```

```{r comparaison}
mean((y-pred.glm)^2)
mean((y-pred.glmnet)^2)
```
pour mettre un poids sur les var env : ‘grplasso’ ou ‘ggplasso’
```{r}
print(fit)
```
Df: number of nonzero coefficients  
%Dev: percent (of null) deviance explained  
Lambda : *?*
coefficient : *?*

The function glmnet returns a sequence of models for the users to choose from. In many cases, users may prefer the software to select one of them. Cross-validation is perhaps the simplest and most widely used method for that task. **cv.glmnet** is the main function to do cross-validation here.  
```{r cross-validation}
filter <- function(x, y, weights, ...) {}

cvfit <- cv.glmnet(x, y,
                   family = "binomial",
                   type.measure = "auc", # ROC curve
                   exclude = filter) # exclude variables
```

```{r}
plot(cvfit)
cvfit$lambda.min #  λ that gives minimum mean cross-validated error
coef(cvfit, s = "lambda.min") # model coefficients at that value of λ
```

“offset”. This is a fixed vector of N numbers that is added into the linear predictor. For example, you may have fitted some other logistic regression using other variables (and data), and now you want to see if the present variables can add further predictive power. To do this, you can use the predicted logit from the other model as an offset in the glmnet call.  


