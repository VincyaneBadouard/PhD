---
title: "Residuals_explo"
format: html
editor: source
---

# Objectives
to see how well our model is fitting the data.  
Residuals are the differences between what we observe and what our model predicts.  

Si les résidus sont uniformément distribués leur médiane est proche de 0, et la valeur mimimum et maximum <3 en absolu. Les résidus supérieurs à la valeur absolue de 3 se situent dans les queues d'une distribution normale standard et indiquent généralement une déformation du modèle.  


Aggregatives species :\
- Anaxagorea_dolichocarpa\
- Tabernaemontana_macrocalyx  
- Eperua_falcata  
- Dicorynia_guianensis  
- Paypayrola_hulkiana  

Raw residual : the difference between what we observe (Y~i~) and the predicted probability (P~i~) for each observation, it ranges between -1 and 1.  

https://library.virginia.edu/data/articles/understanding-deviance-residuals#:~:text=It%20turns%20out%20there%20are,probability%20(%5Epi  



# Packages
```{r setup, include = F}
library(tidyverse)
library(cmdstanr)
# library(bayesplot)

# sp <- "Paypayrola_hulkiana" 
sp <- c("Anaxagorea_dolichocarpa", "Tabernaemontana_macrocalyx", "Eperua_falcata", "Dicorynia_guianensis", "Paypayrola_hulkiana")
```

# Model results and their data
```{r data}
path <- "D:/Mes Donnees/PhD/R_codes/PhD/Modelisation/"

# load real presence-absences data on 25ha 
load(paste(path, "Realdata/Realsp_25ha.Rdata", sep=''))
# View(datalist[[1]])

datalist <- datalist[names(datalist) %in% sp] # only species in sp
# View(datalist[["Iryanthera_hostmannii"]])
```

```{r fits}
fits <- list()
for(S in sp){
  tryCatch({
    chain_path <- file.path("..","Chains", "Hybrid_allpred", S) # ".." for the he directory above the current one
    fits[[S]] <- as_cmdstan_fit(list.files(chain_path,
                                           full.names = TRUE))},
    error=function(e){cat("ERROR :",S, conditionMessage(e), "\n")}
  )
}
```

# Compute raw residuals
get the posterior residuals for each observations, and I take the median across iterations.
```{r}
DATA <- fits[[S]]$summary("p") # p posterior

y <- datalist[[S]]$Presence # Observed values (y = 0 or 1)
p_hat <- DATA$mean # predicted probability from model
raw_e <- y - p_hat # raw residuals
```

# Compute Pearson residuals
It is the raw residual divided by the estimated standard deviation of a binomial distribution with number of trials equal to 1 and p equal to phat.
```{r}
Pearson_e <- raw_e / sqrt(p_hat * (1 - p_hat))
```
# Compute standardized Pearson residual
This is the Pearson residual adjusted for the leverage of predictors using what are called "hat values." Hat values measure the distance of individual predictors from the mean of the predictors. High hat values indicate a subject or row could have outlying predictor values. This in turn could mean that a subject or row has substantial leverage in determining the predicted response. This adjustment then increases the absolute value of certain residuals based on the leverage of the associated predictors  
```{r, eval=F}
variances <- p_hat * (1 - p_hat)  # [iterations x N]
mean_variance <- colMeans(variances)  # average over posterior

# Compute average weights
W_diag <- mean_variance  # length N
W <- diag(W_diag)
XWX_inv <- solve(t(X) %*% W %*% X)

# Now compute hat values
hat_values <- numeric(nrow(X))
for (i in seq_len(nrow(X))) {
  x_i <- X[i, , drop = FALSE]
  hat_values[i] <- x_i %*% XWX_inv %*% t(x_i)
}

StPearson_e <- Pearson_e / sqrt(1 - hat_values)

cbind(y, p_hat, StPearson_e) %>%  
  head()
```

# Compute deviance residuals
```{r}
Deviance_e <- sign(raw_e)*sqrt(-2*(y*log(p_hat) + (1 - y)*log(1 - p_hat)))
```
```{r}
Residuals <- data.frame(y, p_hat, raw_e, Pearson_e, Deviance_e) %>% 
  bind_cols(datalist[[S]] %>% select(Xutm,Yutm, DBHcor))
```

```{r}
cor(raw_e, Pearson_e) # 0.976
cor(raw_e, Deviance_e) # 0.998
cor(Pearson_e, Deviance_e) # 0.982

ggplot() +
  geom_histogram(aes(x=log(raw_e)))
ggplot() +
  geom_histogram(aes(x=log(Pearson_e)), fill="blue")
ggplot() +
  geom_histogram(aes(x=log(Deviance_e)), fill="forestgreen")
```

# Plots the median residuals against the predicted proba
```{r}
Residuals %>% 
  ggplot(aes(x = p_hat, y = Pearson_e, colour = as.factor(y))) +
  geom_point()
```
```{r}
Residuals %>% 
  filter(y == 1) %>%  
  ggplot(aes(x = Xutm, y = Yutm, colour = Deviance_e)) + 
  theme_classic() +
  geom_point(aes(size=DBHcor)) +
  scale_size_continuous(range = c(0.5, 5)) +
  # coord_fixed(ratio = 1) +
  # scale_color_gradient2(low = "blue", high = "red",  midpoint = 0.93) +
  scale_color_gradient(low = "blue", high = "red") +
  ggtitle(S)
```

# Moran's I
```{r }
n <- 10^3
samp <- sample_n(Residuals, n)
# Computes Moran's coefficients on distance classes
cor <- pgirmess::correlog(coords = data.frame(Residuals$Xutm, Residuals$Yutm), # long
                          Residuals$raw_e,
                          method = "Moran", nbclass = 30) %>% 
  as.data.frame()

# Correlogram
cor %>% 
  filter(dist.class < 500) %>% 
  ggplot(aes(x = dist.class, y = coef)) + 
  theme_minimal() +
  geom_hline(yintercept = 0) +
  geom_point(aes(alpha = p.value < 0.05)) + geom_line(col="red", size=0.8) +
  xlab("Distance (m)") + ylab("Moran\'s I") +
  # scale_x_log10() +
  # xlim(0, 500) +
  # ylim(-1, 1) +
  ggtitle("Residuals spatial auto-correlation")
```
