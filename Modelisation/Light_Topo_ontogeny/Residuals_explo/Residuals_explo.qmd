---
title: "Residuals_explo"
format: html
editor: source
---

# Objectives
Compute residuals permit to see how well our model is fitting the data.  
Residuals are the differences between what we observe and what our model predicts.  


Aggregatives species :\
- Anaxagorea_dolichocarpa\
- Tabernaemontana_macrocalyx  
- Eperua_falcata  
- Dicorynia_guianensis  
- Paypayrola_hulkiana  

**Raw residual**: the difference between what we observe (Y~i~) and the predicted probability (P~i~) for each observation, it ranges between -1 and 1.  

**Pearson residual**: it is the raw residual **divided by the estimated standard deviation** of a binomial distribution with number of trials equal to 1 and p equal to phat.  

**Deviance residual**: scaled version of the components of the binomial log likelihood.  

https://library.virginia.edu/data/articles/understanding-deviance-residuals#:~:text=It%20turns%20out%20there%20are,probability%20(%5Epi  



# Packages
```{r setup, include = F}
library(tidyverse)
library(cmdstanr)
library(foreach)
library(parallel)

# sp <- "Tabernaemontana_macrocalyx"
sp <- c("Anaxagorea_dolichocarpa", "Tabernaemontana_macrocalyx", "Eperua_falcata", "Dicorynia_guianensis", "Paypayrola_hulkiana")

sp <- "Dicorynia_guianensis"

```

# Model results and their data
```{r data}
path <- "D:/Mes Donnees/PhD/R_codes/PhD/Modelisation/"

# load real presence-absences data on 25ha 
load(paste(path, "Realdata/Realsp_25ha.Rdata", sep=''))
# View(datalist[[1]])

datalist <- datalist[names(datalist) %in% sp] # only species in sp
# View(datalist[["Iryanthera_hostmannii"]])
```

# Parallelised function
```{r}
source("~/PhD/R_codes/PhD/Modelisation/Light_Topo_ontogeny/Residuals_explo/ResidualExplo.R", echo=TRUE)

Sys.time()
gc()
# parallel::detectCores() # 8
cores = min(c(length(sp), 8)) # nbr of cores to use
i <- NULL
j = length(sp)

# L'enregistrement des clusters
cl <- parallel::makeCluster(cores, outfile = "")
doSNOW::registerDoSNOW(cl)

# Progress bar:
# pb <- txtProgressBar(min = 0, max = j, style = 3)
pb <- txtProgressBar(max=j)
# progress <- function(n) setTxtProgressBar(pb, n)
progress <- function(n) cat(sprintf("Run %d is complete\n", n))
opts <- list(progress = progress)

foreach::foreach(
  i=1:j,
  .packages = c("cmdstanr", "tidyverse", "pgirmess"), # necessary packages
  .options.snow = opts # ProgressBar
) %dopar% {
  ResidualExplo(s= sp[i], datalist,
                fitspath = "D:/Mes Donnees/PhD/R_codes/PhD/Modelisation/Light_Topo_ontogeny/Residuals_explo/Chains/Hybrid_allpred/")
}

# close progressbar and cluster
close(pb)
stopCluster(cl)
Sys.time() # 16h
```

# Detailed code
```{r fits}
fits <- list()
for(S in sp){
  tryCatch({
    # S = "Dicorynia_guianensis"
    chain_path <- paste("D:/Mes Donnees/PhD/R_codes/PhD/Modelisation/Light_Topo/Chains/Hybrid_allpred/",S, sep="")
    # chain_path <- file.path("..","Chains", "Hybrid_allpred", S) # ".." for the he directory above the current one
    fits[[S]] <- as_cmdstan_fit(list.files(chain_path,
                                           full.names = TRUE))},
    error=function(e){cat("ERROR :",S, conditionMessage(e), "\n")}
  )
}
```

# Compute raw residuals
get the posterior residuals for each observations, and I take the median across iterations.
```{r}
DATA <- fits[[S]]$summary("p", "median") # p posterior

y <- datalist[[S]]$Presence # Observed values (y = 0 or 1)
p_hat <- DATA$median # predicted probability from model
raw_e <- y - p_hat # raw residuals
```

# Compute Pearson residuals
It is the raw residual divided by the estimated standard deviation of a binomial distribution with number of trials equal to 1 and p equal to phat.
```{r}
Pearson_e <- raw_e / sqrt(p_hat * (1 - p_hat))
```

# Compute standardized Pearson residual
This is the Pearson residual adjusted for the leverage of predictors using what are called "hat values." Hat values measure the distance of individual predictors from the mean of the predictors. High hat values indicate a subject or row could have outlying predictor values. This in turn could mean that a subject or row has substantial leverage in determining the predicted response. This adjustment then increases the absolute value of certain residuals based on the leverage of the associated predictors  
```{r}
# Compute hat matrix diagonal (hat values)
X <- as.matrix(datalist[[S]] %>% select(logTWI, logTransmittance))  # N x K
XtX_inv <- solve(t(X) %*% X)  # K x K
H <- X %*% XtX_inv %*% t(X)   # N x N
hat_values <- diag(H)

StPearson_e <- Pearson_e / sqrt(1 - hat_values)

```

# Compute deviance residuals
```{r}
Deviance_e <- sign(raw_e)*sqrt(-2*(y*log(p_hat) + (1 - y)*log(1 - p_hat)))
```

```{r}
Residuals <- data.frame(y, p_hat, raw_e, Pearson_e, Deviance_e, StPearson_e) %>% 
  bind_cols(datalist[[S]] %>% select(Xutm,Yutm, DBHcor))
```

# Residuals distribution
```{r}
cor(raw_e, Pearson_e) # 0.976
cor(raw_e, Deviance_e) # 0.998
cor(Pearson_e, Deviance_e) # 0.982
cor(Pearson_e, StPearson_e) # 1


ggplot() +
  geom_histogram(aes(x=log(raw_e)))
ggplot() +
  geom_histogram(aes(x=log(Pearson_e)), fill="blue")
ggplot() +
  geom_histogram(aes(x=log(Deviance_e)), fill="forestgreen")
ggplot() +
  geom_histogram(aes(x=log(StPearson_e)), fill="pink")

```

# Plots the median residuals against the predicted proba
```{r}
Residuals %>% 
  ggplot(aes(x = p_hat, y = StPearson_e, colour = as.factor(y))) +
  geom_point()
```

```{r}
Residuals %>% 
  filter(y == 1) %>%  
  ggplot(aes(x = Xutm, y = Yutm, colour = StPearson_e)) + 
  theme_classic() +
  geom_point(aes(size=DBHcor)) +
  scale_size_continuous(range = c(0.5, 5)) +
  # coord_fixed(ratio = 1) +
  # scale_color_gradient2(low = "blue", high = "red",  midpoint = 0.93) +
  scale_color_gradient(low = "blue", high = "red") +
  ggtitle(S)
```

# Moran's I
```{r }
n <- 2000
samp <- sample_n(Residuals, n)
# Computes Moran's coefficients on distance classes
cor <- pgirmess::correlog(coords = data.frame(samp$Xutm, samp$Yutm), # long
                          samp$StPearson_e,
                          method = "Moran", nbclass = NULL) %>% 
  as.data.frame()

# Correlogram
cor %>% 
  filter(dist.class < 500) %>% 
  ggplot(aes(x = dist.class, y = coef)) + 
  theme_minimal() +
  geom_hline(yintercept = 0) +
  geom_point(aes(alpha = p.value < 0.05)) + geom_line(col="red", size=0.8) +
  xlab("Distance (m)") + ylab("Moran\'s I") +
  # scale_x_log10() +
  # xlim(0, 500) +
  # ylim(-1, 1) +
  ggtitle("Residuals spatial auto-correlation")
```
