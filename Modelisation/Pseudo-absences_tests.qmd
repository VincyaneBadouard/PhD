---
title: "Pseudo-absences_tests"
format: html
editor: visual
---

# Objectives

-   Test the sensibility to absences number relative to presence number (\*1, 10, 100) on simulated data, then on the less and more abundant species and of different spatial structure (Barbet-Massin et al., 2012 method)
-   Check if our simulated pseudo-absences are similarly distributed than our community, with a heatmap (env var and DBH).

Pseudo-absences were always generated without considering the species potential distribution

# Packages

```{r, include = F}
library(tidyverse)
```

# Data

```{r, include = F, message=F}
Inv <- read_csv("D:/Mes Donnees/PhD/Inventories/Data/Understory/Paracou/P16_Paracou_InvandEnv.csv")
```

# Check number of pseudo-absences necessary to represent the community environment

30, 100, 300, 700, 1 000, 3 000, 7 000, 10 000, 26 758

```{r, eval=F}
nrow(Inv %>% na.omit()) # 10181: max number of light values

data <- list()
for(N in c(10, 30, 100, 300, 700, 1000, 3000, 7000, 10000, nrow(Inv))){ # , nrow(Inv)
  data[[as.character(N)]] <- data.frame(
    N= N,
    # Transmittance = sample(na.omit(Inv$Transmittance), N, replace=F),
    Elevation = sample(Inv$Elevation, N, replace=F))
}
draws <- bind_rows(data, .id = "N") %>% 
  mutate(N = factor(N, levels = c("10","30", "100", "300", "700", "1000", "3000", "7000", "10000", as.character(nrow(Inv)))))


ggplot(draws, aes(x= N, y = Elevation, group=N)) +
  geom_boxplot() +
  theme_minimal() +
  theme(axis.title= element_text(size=18), axis.text= element_text(size=18)) +
  labs(y="Elevation (m)", x="N random draws")

ggsave("Elevation_draws_boxplot.png",
       path = "D:/Mes Donnees/PhD/Figures/EnvVar_explo",
       width = 15, height = 10)


ggplot(draws, aes(x= N, y = Transmittance, group=N)) +
  geom_boxplot() +
  scale_y_continuous(trans="log", labels = scales::number_format(accuracy = 0.001)) +
  theme_minimal() +
  theme(axis.title= element_text(size=18),
        axis.text= element_text(size=18)) +
  labs(y="log(transmittance)", x="N random draws")

ggsave("Light_draws_boxplot.png",
       path = "D:/Mes Donnees/PhD/Figures/EnvVar_explo",
       width = 15, height = 10)
```

```{r, eval=F}
# Histograms of elevation distribution à different draws nbr
ggplot(draws, aes(x= Elevation)) +
  geom_histogram(data= draws %>%
                   filter(as.numeric(as.character(N))== nrow(Inv)) %>% select(-N),
                 binwidth=1, fill="#69b3a2", color="#e9ecef", alpha=0.9) +
  geom_histogram(binwidth=1, fill="grey", color="#e9ecef", alpha=0.9) +
  facet_wrap(~N, scales = "fixed") +
  theme(title= element_text(size=18),
        axis.title= element_text(size=18),
        axis.text= element_text(size=18),
        strip.text.x = element_text(size=18)) +
  labs(title = "N random draws", x="Elevation (m)")

ggsave("Elevation_draws_hist.png",
       path = "D:/Mes Donnees/PhD/Figures/EnvVar_explo",
       width = 15, height = 10)

# Histograms of light distribution à different draws nbr
ggplot(draws, aes(x= Transmittance)) +
  geom_histogram(data = draws %>%
                   filter(as.numeric(as.character(N)) == 10000) %>%
                   select(-N), binwidth=0.1, fill="#69b3a2", color="#e9ecef", alpha=0.9) +
  geom_histogram(binwidth=0.1, fill="grey", color="#e9ecef", alpha=0.9) +
  scale_x_continuous(trans="log", labels = scales::number_format(accuracy = 0.001)) +
  facet_wrap(~N, scales = "fixed") +
  theme(title= element_text(size=18),
        axis.title= element_text(size=18),
        axis.text= element_text(size=18),
        strip.text.x = element_text(size=18)) +
  labs(title = "N random draws", x="log(transmittance)")

ggsave("Transmittance_draws_hist.png",
       path = "D:/Mes Donnees/PhD/Figures/EnvVar_explo",
       width = 15, height = 10)
```

```{r, eval=F}
# sample individuals
data <- list()
for(N in c(10, 30, 100, 300, 700, 1000, 3000, 7000, 10000)){ # , nrow(Inv)
  data[[as.character(N)]] <- data.frame(
    N= N,
    idTree = sample(na.omit(Inv)$idTree, N, replace=F))
}
draws <- bind_rows(data, .id = "N") %>% 
  left_join(Inv, by="idTree") %>% 
  mutate(N = factor(N, levels = c("10","30", "100", "300", "700", "1000", "3000", "7000", "10000", as.character(nrow(Inv)))))

# heatmaps for Elevation-DBH spatial distribution à different draws nbr
ggplot(draws, aes(x=DBHcor, y=Elevation)) + 
  geom_tile() + # heatmap
  geom_bin2d(bins = 50) + # for counts
  scale_x_continuous(trans="log", labels = scales::number_format(accuracy = 1)) +
  labs(title="N random draws", y="Elevation (m)", x="log(DBH)") +
  theme(title= element_text(size=18),
        axis.title= element_text(size=18),
        axis.text= element_text(size=18),
        strip.text.x = element_text(size=18)) +
  facet_wrap(~N, scales = "fixed")

ggsave("Elevation_draws_heatmap.png",
       path = "D:/Mes Donnees/PhD/Figures/EnvVar_explo",
       width = 15, height = 10)

# heatmaps for Light-DBH spatial distribution à different draws nbr
ggplot(draws, aes(x=DBHcor, y=Transmittance)) + 
  geom_tile() + # heatmap
  geom_bin2d(bins = 50) + # for counts
  scale_y_continuous(trans="log", labels = scales::number_format(accuracy = 0.001)) +
  scale_x_continuous(trans="log", labels = scales::number_format(accuracy = 1)) +
  labs(title="N random draws", y="log(transmittance)", x="log(DBH)") +
  theme(title= element_text(size=18),
        axis.title= element_text(size=18),
        axis.text= element_text(size=18),
        strip.text.x = element_text(size=18)) +
  facet_wrap(~N, scales = "fixed")

ggsave("Light_draws_heatmap.png",
       path = "D:/Mes Donnees/PhD/Figures/EnvVar_explo",
       width = 15, height = 10)
```

# Find parameters for each species temperament

```{r, eval=F}
# When log(X) and opt = 0.07 and a =1/10:
# noeffect = 0; 0
# concavebell = -4; (-b/(opt*2)) (=-0.8)
# convexvebell = 4; (-b/(opt*2)) (=0.8)
# negsigmoid = -1; -(-b/(opt*2)) (=0.2)
# possigmoid = 0.5; -(-b/(opt*2)) (=-0.09)


test <- Inv %>% 
  na.omit() %>% 
  # mutate(X =  Transmittance)
  mutate(X =  log(Transmittance))

# Parameters
# log(0) = -inf ; log(0.01) = -4.6 ; log(0.07) = -2.7 ; log(0.5) = -0.7 ; log(1) = 0
opt <-log(median(Inv$Transmittance)) # community median to have sufficient number of presence 
# a <- rstanarm::logit((700)/(700+10000)) # intercept ; logit(0.5)= 0) autant de 0 que de 1
a <- rstanarm::logit(0.1)
b <- -4 
c <- -b/(opt*2)# ; pour une linéaire : inv_logit(-9) ~ 0


# Compute presence probability
logit_p <- a + b * test$X + c * test$X^2 # equation
data <- data.frame(X = test$X, y = logit_p)
plot(data)

p <- 1 / (1 + exp(-logit_p))  # logistique transformation (inverse logit)

# Generate presence-absence data from probability
presence_absence <- rbinom(nrow(test), size = 1, prob = p) # Bernoulli = 1 trial

# data.frame of simulated data
data <- data.frame(X = test$X, Presence = presence_absence)

# Visualisation of simulated data
ggplot(data, aes(x= X, y= Presence)) +
  geom_point() +
  theme_minimal() +
  stat_function(fun=function(x) 1 / (1 + exp(-(a + b * x + c * x^2))), col = "blue", linewidth = 1) +
  labs(y="Presence (1) / Absence (0)", x="Explicative variable (X)")

table(data$Presence)
```

# Simulate data

N presence: 30 (nmin), 100 (median), 700 (nmax) randomly chosen from the species distribution\
N absence: 30, 100, 300, 700, 1 000, 3 000, 7 000, 10 000, 26 758 (= maximum community abundance)\
Species distribution: no effect, concave, convex or left truncated bell, negative and positive sigmoid.

Pseudo-absences selection method: random selection from all inventoried individuals including the species of interest.

```{r}
# When X not log and opt = 0.5 and a =0.5:
# opt= 0.1
# noeffect c(b= 0, c= 0)
# concavebell c(b= 15, c= -15)
# leftbell c(b= 50, c= -125)
# possigmoid c(b= 15, c= 15)
# leftconvexbell c(b= -50, c= 125)
# negsigmoid c(b= -50, c= -125)
```

```{r, function simulate data}
# When log(X) and opt = 0.07 and a =1/10:
# noeffect = 0; 0
# concavebell = -4; (-b/(opt*2)) (=-0.8)
# convexvebell = 4; (-b/(opt*2)) (=0.8)
# negsigmoid = -1; -(-b/(opt*2)) (=0.2)
# possigmoid = 0.5; -(-b/(opt*2)) (=-0.09)


# N1 = 30 # n presence
# N2 = "*1" # n absence
# temperament = "concavebell"
# include=F


Inv <- Inv %>% 
  na.omit() %>% # to remove data without env data
  mutate(logTransmittance =  log(Transmittance))

simulatedata_PA <- function(N1, # n presence
                            N2, # n absence
                            include, # include interest species in the absences
                            # a =  rstanarm::logit(0.1), # intercept à 0.1 : rstanarm::logit(0.1) = -2.2
                            temperament = NULL, # character
                            b = NULL, c = NULL) {
  
  # print(temperament)
  # print(paste("N1=",N1)); print((paste("N2=",N2)))
  # print((paste("include=",include)))
  
  # # if(is.null(a)) {a = rstanarm::logit((N1)/(N1+N2))} # intercept
  
  if(temperament == "noeffect") {b= 0; c= 0}
  if(temperament == "concavebell") {b= -4; c= -0.8} # {b= 15; c= -15}
  if(temperament == "convexbell") {b= 4; c= 0.8} # {b= -50; c= 50}
  if(temperament == "negsigmoid") {b= -1; c= 0.2} # {b= -15; c= -15}
  if(temperament == "possigmoid") {b= 0.5; c= -0.09} # {b= 15; c= 15}
  
  # Intercept at he median of light and for a proba of 0.2
    # logit(P) = a + b*median(log(Transmittance)) - c*median(log(Transmittance))^2
  a = rstanarm::logit(0.1) - (b*median(Inv$logTransmittance)) - (c*median(Inv$logTransmittance)^2) # 

  # Na <- c("*1", "max/2", "max")
  if(N2 == "*1") {N2= N1}
  if(N2 == "max/2" & include) {N2= nrow(Inv)/2}
  if(N2 == "max/2" & !include) {N2= (nrow(Inv)/2)-N1}
  if(N2 == "max" & include) {N2= nrow(Inv)}
  if(N2 == "max" & !include) {N2= nrow(Inv)-N1}
  
  print(temperament)
  print(paste("a=",a)); print(paste("b=",b)); print((paste("c=",c)))
  print(paste("N1=",N1)); print((paste("N2=",N2))) ; print((paste("include=",include)))
  
  repeat { # repeat until there is sufficient number of presences
    test <- try(
        Inv %>%
      select(idTree, logTransmittance) %>%
      rowwise() %>%
      # Full community 
      mutate(TotProbability = 1 / (1 + exp(-(
        a + b * logTransmittance + c * logTransmittance^2)))) %>% # (inverse logit(Eq))
      mutate(TotPresence = rbinom(1, size = 1, # Bernoulli = 1 trial
                                  prob = TotProbability)) %>%
      ungroup() %>%
      # Sampling
      mutate(SelectPres = if_else(rownames(.) %in% sample(which(TotPresence==1), N1, replace=F), 1, NA)) # among the presences
    )
    
     if (!(inherits(test,"try-error")))
      break
  }
    
    # Include interest psecies or not
    if(include==T){
      test <- test %>% mutate(SelectAbs = if_else(rownames(.) %in% sample(1:nrow(.), N2, replace=F), 0, NA)) # N2 absences among all the community
    }else if(include==F){
      test <- test %>% mutate(SelectAbs = if_else(rownames(.) %in% sample(which(is.na(SelectPres)), N2, replace=F), 0, NA)) # N2 absences among all exept the presences
      
    }
    
  test_piv <- test %>%
    pivot_longer(cols = c("SelectPres", "SelectAbs"),
                 values_to = "Presence") %>%
    # Recompute proba of the sampling
    # courbe verte : intercept = N1/(N1+N2), b1 b2 je garde et on recalcule les proba
    mutate(Probability = 1 / (1 + exp(-(
      ( rstanarm::logit((N1)/(N1+N2)) ) + b * logTransmittance + c * logTransmittance^2)))) %>% # (inverse logit(Eq))
    
    na.omit() %>%
    mutate(temperament = temperament) %>%
    mutate(NSelectPres = N1) %>%
    mutate(NSelectAbs = nrow(test[!is.na(test$SelectAbs) & test$SelectAbs==0,])) %>% 
    mutate(IncludeSp = include)
  
  
  # checks
  # print(paste("NSelectPres ==",N1,":", nrow(test[!is.na(test$SelectPres) & test$SelectPres==1,]) == N1))
  # print(paste("NSelectAbs ==",N2,":",nrow(test[!is.na(test$SelectAbs) & test$SelectAbs==0,]) == N2))
  # nrow(test_piv)==N1+N2
  # 
  # p <- ggplot(test, aes(x= logTransmittance, y= Presence)) +
  #   geom_point() +
  #   theme_minimal() +
  #   stat_function(fun=function(x) 1 / (1 + exp(-(a + b * x + c * x^2))), col = "blue", linewidth = 1) +
  #   labs(title=paste(temperament,
  #                    "; a=",round(a,1), "b=",b, "c=",c,"N1=",N1,"N2=",N2),
  #        y="Presence (1) / Absence (0)", x="Explicative variable (X)")
  
  return(test_piv)
} # end function
```

```{r, eval=F}
# lapply(temperaments, function(t)
#     simulatedata_PA(var = "logTransmittance",
#                     N1 = 30, # n presence
#                     N2 = 100), # n absence
#                     temperament = t) # character
# )

# Generates all combination of variables ; 90
combinaisons <- tidyr::crossing(
  temperaments =  c("noeffect", "concavebell","convexbell", "possigmoid", "negsigmoid"),
  Np = c(30, 100, 700),
  Na = factor(c("*1", "max/2", "max"), levels= c("*1", "max/2", "max")),
  includeSP = c(T, F) # with or without interest sp
)

plist <- mapply(FUN = simulatedata_PA,
                N1 = combinaisons$Np, 
                N2 = combinaisons$Na, 
                include = combinaisons$includeSP, 
                temperament = combinaisons$temperaments,
                SIMPLIFY = F) 

names(plist) <- lapply(1:length(plist), \(x) paste(
  unique(plist[[x]]$temperament), unique(plist[[x]]$NSelectPres), unique(plist[[x]]$NSelectAbs), unique(plist[[x]]$IncludeSp), sep = "-")
)
names(plist)
plist[[1]]

# plots <- gridExtra::marrangeGrob(plist, nrow = 3, ncol = 3)
# # plots
# 
# ggsave(paste("Pseudo-abs_simulatedata.pdf",sep=""),
#        path = "D:/Mes Donnees/PhD/R_codes/PhD/Inventory_scripts/Exploration/pdf",
#        plots, width = 15, height = 10)

saveRDS(plist, file = "./Simdata/simulatedata_PA.rds")

View(plist[[1]])
```

```{r}
plist <- readRDS("./Simdata/simulatedata_PA.rds")
```

# Run models

```{r}
library(rstan)
rstan_options(auto_write = TRUE) # option pour ne pas recompiler à chaque fois !!! gain de temps
options(mc.cores = parallel::detectCores()) #option pour ajouter des coeurs au calcul
rstan_options(disable_march_warning = TRUE)

library(rstanarm) # for Bayesian automatic regression modelling using stan
library(brms) # Bayesian generalized multivariate non-linear multilevel models using stan
library(foreach) # parallisation
library(parallel)
```

```{r, eval=F}
# fits <- readRDS("./Fits/Pseudo_abs_tests.rds")
# behaviour <- ""
```

```{r, eval=F}
rm(a, include, includeSP, N1, N2, Na, Np, temperament, temperaments, simulatedata_PA)
```

```{r}
plist <- plist[1:18] # only concave
# faire le na.omit ici
```

```{r Create a liste with data definitions as in the rstan file}
dataM <- lapply(plist, function(x) list(N = nrow(x), #les noms des var doivent etre les memes que dans le fichier stan
                                        Presence = x$Presence,
                                        Environment = x$logTransmittance))

# dataM[[1]]$Presence


Model <- stan_model("Bernoulli_EnvOnly_quadratic.stan") # remove rds file if doest work
# fit <- stan(file= "Bernoulli_EnvOnly_quadratic.stan", data = dataM[["concavebell-30-100"]], chains = 4, iter = 2000)
# fit
gc()
cores = 5 # nbr of cores to use
# parallel::detectCores() # 8
i <- NULL

vec <- 1:length(dataM)
# vec <- 64:length(dataM)

# D=55
# j=63

for(D in split(vec, ceiling(seq_along(vec)/18))) {
  
  j = max(D) # length(dataM)
  
  # L'enregistrement des clusters
  cl <- parallel::makeCluster(cores, outfile = "")
  doSNOW::registerDoSNOW(cl)
  
  # writeLines(c(""), "PAlog.txt") # to create a log file
  
  # Progress bar:
  # pb <- txtProgressBar(min = 0, max = j, style = 3)
  pb <- txtProgressBar(max=j)
  # progress <- function(n) setTxtProgressBar(pb, n)
  progress <- function(n) cat(sprintf("Run %d is complete\n", n))
  opts <- list(progress = progress)
  
  fits <- foreach::foreach(
    i=min(D):j,
    .packages = c("rstan"), # necessary packages
    .options.snow = opts, # ProgressBar
    .combine = c
  ) %dopar% {
    # sink("PAlog.txt", append=TRUE) # for the log file
    # the function to parallelise:
    stan(file= "Bernoulli_EnvOnly_quadratic.stan", data = dataM[[i]], chains = 4, iter = 2000)
  }
  # close progressbar and cluster
  close(pb)
  stopCluster(cl)
  
  names(fits) <- names(dataM[min(D):j]) 
  
  saveRDS(fits, file = paste("D:/Mes Donnees/PhD/R_codes/PhD/Modelisation/Fits/Pseudo_abs_tests_concaves.rds", sep=""))
  
}
gc()
```

# Bind all the fits

```{r, eval=F}
# rm(fits, cores, cl, pb, Model, opts, i, j) ; gc()
# 
# files <- list.files("D:/Mes Donnees/PhD/R_codes/PhD/Modelisation/Fits", pattern = "Pseudo_abs_tests_", full.names = T)# 10 files
# 
# allfits <- list() #create empty list
# 
# #loop through the files
# gc()
# for (i in files) {
#   print(i)
#   allfits[[i]] <- get(load(i)) #add files to list position
# }
# gc()
# save(allfits, file ="D:/Mes Donnees/PhD/R_codes/PhD/Modelisation/Fits/Pseudo_abs_tests_all.Rdata")
# rm(D, files, vec) ; gc()  

# load("D:/Mes Donnees/PhD/R_codes/PhD/Modelisation/Fits/Pseudo_abs_tests_all.Rdata")
# gc()
# 
# my_list_new <- unlist(allfits, recursive = FALSE)
# names(my_list_new) <- gsub(".*Rdata.", "", names(my_list_new))
# rm(allfits,names);gc()

# save(my_list_new, file ="D:/Mes Donnees/PhD/R_codes/PhD/Modelisation/Fits/Pseudo_abs_tests.Rdata")

load("D:/Mes Donnees/PhD/R_codes/PhD/Modelisation/Fits/Pseudo_abs_tests.Rdata")

```

# Evaluation - Goodness of fit

loo_R2 bayes_R2 https://avehtari.github.io/bayes_R2/bayes_R2.html#References

```{r}
library(loo) # model evaluation

loo_R2(fits[1]) # A real value per response variable indicating the LOO-adjusted R-squared.

# compute R2 with new data
nd <- data.frame(mpg = c(10, 20, 30), wt = c(4, 3, 2), cyl = c(8, 6, 4))
loo_R2(fit, newdata = nd)
```
