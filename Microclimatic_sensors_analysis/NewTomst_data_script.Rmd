---
title: "Tomst data script"
author: "Vincyane Badouard"
date: "`r Sys.Date()`"
output: html_document
---

```{r, include=FALSE}
knitr::opts_chunk$set(
  message = FALSE, echo = FALSE, fig.width = 6
)
```

**FAIRE CALIBRATION HUMIDITE !!**

- Tomst mauvais horaires : confronter température de tomst et hobo pour recaller les horaires, vérifier que j’ai bien fait -3h

*2 sites :\
- Paracou (pour comparaison aux données Lidar)\
- Nouragues : car hydrologie potentiellement différente

*Objectives:\
- open the Tomst data\
- create a script to open Tomst data in several folders\
- prepare Tomst data for analysis\
- spatialiser tous les capteurs en x,y (trilateration) (A FAIRE)\
- descriptive analysis*

*Problematics:\
- A quelle échelle la variabilité est la plus forte (saison, mois, jour, jour/nuit, 15min) ?\
- La température de l'air et la lumière sont-elles liées à l'ouverture de canopée ? à la topographie ?*

*Variables à calculer :\
moyenne, sd, coefficient de variation, min, max :\
- de l'année\
- diurne\
- nocturne\
- saison sèche\
- saison des pluies*

# *Packages*

```{r, include = F, echo = T,results = 'hide', message=FALSE}
library(readr)
library(tidyverse)
library(stringr)
library(lubridate) # for dates and time
library(chron) # for dates and time
library(corrplot)
library(RColorBrewer)
```

# *Read*

## Flux tower data
**2023-204** :
Date Year Month Code Day heure+min Time TimeB

- Pluie : Rainfall (mm)

- Temp(55) : Air Temp at 55m high (°C)
- Hr(55) : Air humidity at 55 m high (%)

- Temp(2,0) : Air Temp at 2m high (°C)
- Hr(2,0) : Air humidity at 2 m high (%)  

- Tsoil : mean Soil temperature  (°C) à différentes profondeurs, issues du capteur CS650.
"T_AVG_10cm"     "T_AVG_20cm"     "T_AVG_80cm"     "T_AVG_140cm"   "T_AVG_190cm"     
- VWC : mean Soil water content (m3 m-3) (Les données VWC sont des données de SWC issues d’une fosse récente, avec des capteurs CS650) (La fosse est à proximité de la Tour, sous couvert)
"VWC_AVG_10cm"   "VWC_AVG_20cm"   "VWC_AVG_80cm"   "VWC_AVG_140cm"  "VWC_AVG_190cm"

Définition saison sèche au mois : < 100 mm par mois (Bonal et al. 2008)
```{r}
# Données capteurs de mars 2023 à mars 2024
# FluxTowerData2023 <- readr::read_delim("~/PhD/Microclimate/TourAFlux-2023.csv", 
#                                        delim = ";", locale = locale(decimal_mark = ","),
#                                                                       escape_double = FALSE, trim_ws = TRUE)

TourAFlux_2023_2024 <- readxl::read_excel("~/PhD/Microclimate/TourAFlux-2023-2024.xlsx", 
                                          sheet = "Gx meteo_2023-2024", col_types = c("date", "numeric", "numeric","numeric","numeric","numeric","numeric","numeric","numeric","numeric","numeric","numeric", "numeric", "numeric", "numeric","numeric","numeric","numeric","numeric","numeric","numeric","numeric","numeric", "numeric", "numeric","numeric","numeric","numeric","numeric","numeric"))

names(TourAFlux_2023_2024)

TourAFlux_2023_2024 <- TourAFlux_2023_2024 %>% 
  filter(Date >= mdy_hms("04/01/2023 00:00:00") & Date < mdy_hms("03/31/2024 24:00:00")) %>% 
  rename(Date_Time = Date) %>% 
  mutate(Date = date(Date_Time)) %>%
  # mutate(Date = as.Date(Day, origin = "2022-12-31")) %>% # Julian Day to calendar date (pour 2023 data)
  mutate(Hour =  hms::as_hms(format(Date_Time, format = "%H:%M:%S"))) %>% 
  # mutate(Hour =  hms::hms(seconds_to_period(`heure+min` * 3600))) # (pour 2023 data)
  select(Date_Time, Year, Month, Day, Date, Hour, `heure+min`, Time, # 365 days, 12 months
         Pluie, `Temp(55)`, `Temp(2,0)`, `Hr(55)`, `Hr(2,0)`, T_AVG_10cm, VWC_AVG_10cm) %>% 
  
  # mutate(Season = ifelse(Month  %in% c(2,3, 8:11), # mars, aout-nov = dry season
  #                        "Dry", "Wet")) %>% 
  group_by(Month) %>%
  mutate(Rain_sum_Month = sum(Rain,na.rm = T)) %>% 
  ungroup() %>%
  mutate(Season = ifelse(Rain_sum_Month < 100,"Dry", "Wet")) %>% # Dry season: < 100 mm precipitation per month (Bonal et al. 2008)
  mutate(Month = factor(Month)) %>% 
  mutate(Pluie = as.numeric(Pluie)) %>% 
  group_by(Day) %>% 
  mutate(Rain_day = sum(Pluie)) %>%  # il faut sommer la pluie par jour pour visualiser les saisons
  ungroup()


for(Y in c(2023,2024)){
  print(
    TourAFlux_2023_2024 %>% 
      # filter(Year==Y) %>% 
      ggplot(aes(x = Month,y = Rain_day)) +
      geom_boxplot(aes(color = Season)) +
      labs(title= paste("FluxTower ", Y," - Daily rainfall over the seasons"),
           x ="Month", y = "Daily rainfall (mm)")
  )
}

for(V in c("Temp(55)", "Temp(2,0)", "Hr(55)", "Hr(2,0)")){
  print(
    TourAFlux_2023_2024 %>% 
      filter(get(V) > 0) %>%
      ggplot(aes(x = Month, y = get(V))) +
      geom_boxplot(aes(color = Season)) +
      labs(title= paste("FluxTower 2023 - ",V," over the seasons"),
           x ="Month", y = V)
  )
}


# Plots enregistrés à width = 900
```

## *Sensor environnment data*

```{r include = F}
Tomst_Paracou_env <- read_csv("~/PhD/Microclimate/HOBO_Tomst_environment/Tomst-HOBO sensors - Paracou - Data.csv") %>% 
  select(-`...1`, -Operator, -FieldDate) %>% 
  mutate(TopoHabitat = factor(TopoHabitat, levels = c("Bottomland", "Lower slope", "Mid slope", "Upper slope", "Plateau")))

Tomst_Nouragues_env <- read_csv("~/PhD/Microclimate/HOBO_Tomst_environment/Tomst sensors - Nouragues - Data.csv") %>% 
  select(-Operator, -FieldDate) %>%  # -Tomst_Material_info_30_03_23
  mutate(TopoHabitat = factor(TopoHabitat, levels = c("Bottomland", "Lower slope", "Mid slope", "Upper slope", "Plateau")))

env_Par <- Tomst_Paracou_env %>% 
  select(TomstID,Transect,LightHabitat,TopoHabitat)

env_Nour <- Tomst_Nouragues_env %>% 
  select(TomstID,Transect,LightHabitat,TopoHabitat)
```

## *Sensor data*

### *Data formatting function*

*Columns :\
- index number of the measure,\
- date and time in UTC,\
- time zone = 4 (French Guiana is UTC-3)\
- T1, T2, T3,\
- soil moisture count,\
- shake = 0\
- errFlag (if =1 the device couldn't convert time from PCF chip) = NA*

```{r}
format_tms <- function(
    data_path # path of the data (character) with ".csv"
){
  
  # Data name
  file_name <- data_path 
  
  # Subset data
  data <- read.csv2(data_path, header = F); # row 1 is not the headers
  
  # The Time in UTC
  Time_UTC <- ymd_hm(data$V2, tz = "UTC")
  # Time <- ymd_hm(data$V2, tz = "America/Cayenne") # UTC-3
  # strptime(data$V2,"%Y.%m.%d %H:%M"))
  
  TimeZone <- data$V3 # semblent dire n'importe quoi
  
  # Temperature data
  SoilTemp <- data$V4
  SurfaceTemp <- data$V5
  AirTemp <- data$V6
  
  # Moisture data
  Moisture <- data$V7
  
  # Bind columns
  data2 <- cbind(as.data.frame(Time_UTC),
                 as.data.frame(TimeZone),
                 as.data.frame(SoilTemp), # soil T°
                 as.data.frame(SurfaceTemp), # surface T°
                 as.data.frame(AirTemp), # air T°
                 as.data.frame(Moisture))
  
  Output <- list("data" = data2 #,# dataset
                 # "file_name" = file_name, 
                 # "length" = length(SoilTemp)
  ) # length of eah dataset
  
  return(Output)
}
```

### *Format all the files*

```{r}
path <- "D:/Mes Donnees/PhD/Microclimate/Tomst - data and scripts/LollyData/Paracou/Paracou_2024_03_25"
files <- list.files(path, pattern = "data", full.names = T)# [1:32] # 32 files

data <- lapply(files, format_tms)

# Just keep the TomstSensorNum
files <- str_remove(files, path)
files <- str_remove(files, "_2024_03_25_0.csv")
# files <- str_remove(files, "_2024_03_26_0.csv")
files <- str_remove(files, "/data_")
length(files) # 32

names(data) <- files

Tomstdata <- bind_rows(data, .id = "TomstSensorNum") %>% # df number -> TomstSensorNum column
  unnest(cols = c(data)) #%>% 
# mutate(TomstSensorNum = gsub(paste0(path, "/"), "", TomstSensorNum)) # %>% 
# select(Time, SoilTemp, SurfaceTemp, AirTemp, Moisture) %>% 
# reshape2::melt("Time") # c'était pour le facet_wrap

# filtrer à partir de la date d'installation sur le site

summary(Tomstdata)
```

```{r, echo = F, include = F}
unique(Tomstdata[Tomstdata$SoilTemp<0,]$TomstSensorNum) # que ceux de Jérome
unique(Tomstdata[Tomstdata$SoilTemp<0,]$Time_UTC) # only 2022
```

# *Combine data and environnment*

```{r, include = F}
Tomstdata <- Tomstdata %>% 
  mutate(TomstSensorNum = as.numeric(TomstSensorNum)) %>%
  left_join(Tomst_Paracou_env, by = "TomstSensorNum")
```

## *NA ?*

```{r}
Na_tabble <- Tomstdata %>%
  filter(is.na(Moisture) | is.na(SoilTemp) | is.na(SurfaceTemp) | is.na(AirTemp))
```

# *Manage date and hours*

```{r}
Tomstdata <- Tomstdata %>% 
  mutate(Time = Time_UTC-(3 * 60 * 60)) %>%  # UTC-3
  mutate(Date = date(Time)) %>% 
  mutate(Month = month(Date)) %>%
  mutate(Hour = hms::as_hms(Time)) %>% # format Date-times: 2023-03-30 18:15:00
  # filtrer sur les dates d'étude (1 an) (même dates que les HOBO):
  filter(Time >= mdy_hms("04/01/2023 00:00:00") & Time < mdy_hms("03/31/2024 24:00:00"))

Tomstdata$Time[1] >= mdy_hms("04/01/2023 00:00:00")
```

# *From raw TDT signal to volumetric moisture content, calibrated from granulometry (a faire)*

Voir annexe A du papier des Tomst pour la transformation du signal en % volumique d'humidité et une calibration à partir de la granulométrie

*theta=ax\^2+bx+c*, where theta is volumetric moisture content and x is raw TDT signal.

Si la granulo match pas avec mes données, il y a la possibilité d'utiliser leur excel pour faire du sur mesure (pas accès à la formule)

%clay, silt, sand, bulk density (g/cm3)
```{r}
CalibParam <- read_delim("~/PhD/Microclimate/Tomst - data and scripts/Tomst_humidity_granulo_parameters.csv", 
                         delim = ";", escape_double = FALSE, trim_ws = TRUE) # from A appendix of the Tomst article

mutate(VolumetricMoisture = a*Moisture^2 + b*Moisture + c)
```

# Data checks

-   Maximum values of T° of each day are at midday
-   Higher values of T° of each day are for sensors in gaps
-   Sensors data \< flux tower data
-   Sensors data follow flux tower data

```{r}
names(Tomstdata) # "SoilTemp", "SurfaceTemp", "AirTemp", "Moisture"

# Maximum values of T° of each day are at midday (!fail!)
test <- Tomstdata %>% 
  group_by(Date, TomstID) %>% 
  mutate(MaxDailyAirTemp = max(AirTemp)) %>%
  mutate(MaxDailySurfaceTemp = max(SurfaceTemp)) %>%
  mutate(MaxDailySoilTemp = max(SoilTemp)) %>%
  ungroup()

range(as.character(test[test$AirTemp == test$MaxDailyAirTemp,]$Hour))
median(as.character(test[test$AirTemp == test$MaxDailyAirTemp,]$Hour))


# Higher values of each day are for sensors in gaps (not in understory) (! artefacts !)
test <- Tomstdata %>%
  group_by(Date) %>% 
  mutate(MaxDailyAirTemp = max(AirTemp)) %>%
  mutate(MaxDailySurfaceTemp = max(SurfaceTemp)) %>%
  mutate(MaxDailySoilTemp = max(SoilTemp)) %>%
  ungroup()

test[test$AirTemp == test$MaxDailyAirTemp,]$LightHabitat
test[test$AirTemp == test$MaxDailyAirTemp & test$LightHabitat == "Understory",] # ! artefact !


# Sensors data < flux tower data (le faire avec données tour 2023-2024)
# `Temp(55)` : Mean Air temperature at 55 m (°C)
test <- Tomstdata %>%
  # mutate(Day = day(Date)) %>% # for 2022 tower data
  mutate(Month = factor(Month)) %>% 
  group_by(Date) %>% 
  # mutate(MeanDailyTemp = mean(Temp)) %>% 
  ungroup() %>% 
  select(TomstID, Date, Month, Hour, LightHabitat, TopoHabitat, SoilTemp, SurfaceTemp, AirTemp, Moisture) %>% 
  # left_join(TourAFlux_2023_2024, by= c("Month","Day")) %>% # for 2022 tower data
  left_join(TourAFlux_2023_2024, by= c("Date", "Month", "Hour")) %>% # for 2023-2024 tower data
  # select(Date, Month, Hour, LightHabitat, TopoHabitat, SoilTemp, SurfaceTemp, AirTemp, Moisture, `Temp(55)`) %>% 
  mutate(Tempdiff = AirTemp - `Temp(55)`) %>% 
  unique()

plot(AirTemp~`Temp(55)` , data=test)
abline(lm(AirTemp~`Temp(55)`, data=test), col = "red") # ok
cor(test$AirTemp, test$`Temp(55)`) # 0.89
range(test$Tempdiff) # écart à la T° de la tour: -5°C; 10°C
test1 <- test[test$Tempdiff>5,] # which sensor T° are higher than tower T°
test1[order(test1$Tempdiff),] # autour de midi en gap

# Sensors data follow flux tower data 
test %>% 
  # unite(Day, Month, col = "Date", sep = "-", remove = F) %>% 
  # mutate(Date = as.Date(Date,"%d-%m", origin = "2023-03-31")) %>% 
  # filter(`Temp(55)` > AirTemp) %>%
  ggplot(aes(x = Month)) +
  geom_boxplot(aes(y = `Temp(55)`, colour = "Flux Tower: at 55 m")) +
  geom_boxplot(aes(y = AirTemp, colour = LightHabitat)) + # colour = "Tomst: at 1 m"
  # scale_colour_manual(values = c("Flux Tower: at 55 m" = "red", 
  #                                "Tomst: at 1 m" = "forestgreen")) + 
  labs(title="Tomst vs Flux Tower data", y = "Air temperature (°C)") +
  labs(color = "Data")

# pour 1 jour
test %>% 
  filter(Date=="2023-04-01") %>% # pour 1 jour
  # filter(`Temp(55)` > AirTemp) %>%
  ggplot(aes(x = Hour)) +
  geom_line(aes(y = `Temp(55)`, colour = "Flux Tower: at 55 m"))+
  geom_point(aes(y = AirTemp, colour = LightHabitat)) + # colour = "Tomst: at 1 m"
  # scale_colour_manual(values = c("Flux Tower: at 55 m" = "red", 
  #                                "Tomst: at 1 m" = "forestgreen")) +
  labs(title="Tomst vs Flux Tower data", y = "Air temperature (°C)") +
  labs(color = "Data") +
  scale_x_time(breaks = scales::breaks_width("1 hour"))

```
# Plot data of each sensor

une ligne d'une couleur pour chaque jour le temps en abscisse la lumière
en ordonnée

```{r}
Tomstdata <- test %>% 
  group_by(Month, Hour) %>% 
  mutate(Temp_55_mean = mean(`Temp(55)`)) %>%  ungroup()

Tomstdata$Date[1]

n <- length(unique(Tomstdata$TomstID))*length(unique(Tomstdata$Month))

# Define nrow and ncol for the facet
if(n<4) {i = 1}else{ i = 4}

pdf("Tomst_Temperature.pdf", width = 15, height = 10)
for(p in 1:(ceiling(n/16))){
  print(
    Tomstdata %>% 
      # filter(Hour > hms("06:00:00") & Hour < hms("19:00:00")) %>%
      # filter(TomstID == 1) %>%
      # filter(Month == 4) %>%
      # filter(Light < 1000) %>%
      # filter(Date <= ymd("2023-04-15")) %>% # "2023-03-30"
      ggplot(aes(x = Hour)) +
      geom_line(aes(y = AirTemp, color = factor(Date)), show.legend = F) +
      geom_line(aes(y = Temp_55_mean),  color = "black", linewidth = 1, show.legend = F) +
      scale_x_time(breaks = scales::breaks_width("4 hour")) +
      ggforce::facet_wrap_paginate(vars(TomstID, Month, LightHabitat),
                                   scales = "free_y",
                                   ncol = min(n,4), nrow = i, page = p)
    
  )
}
dev.off() # Close the final graphics device

# faire le meme graph pour chaque hauteur de T° moyennéee à l'heure pour chaque mois
```

# *Relation between moisture and temperatures*

```{r, echo = F}
ggplot(Tomstdata) +
  aes(x = AirTemp, y = SurfaceTemp) +
  geom_point(size = 0.2) +
  stat_smooth(method = "lm",
              formula = y ~ x,
              geom = "smooth")
cat("cor:",cor(Tomstdata$AirTemp, Tomstdata$SurfaceTemp)) # 0.96


ggplot(Tomstdata) +
  aes(x = AirTemp, y = SoilTemp) +
  geom_point(size = 0.2) +
  stat_smooth(method = "lm",
              formula = y ~ x,
              geom = "smooth")
cat("cor:",cor(Tomstdata$AirTemp, Tomstdata$SoilTemp)) # 0.53


ggplot(Tomstdata) +
  aes(x = SurfaceTemp, y = SoilTemp) +
  geom_point(size = 0.2) +
  stat_smooth(method = "lm",
              formula = y ~ x,
              geom = "smooth")
cat("cor:",cor(Tomstdata$SurfaceTemp, Tomstdata$SoilTemp)) # 0.69

ggplot(Tomstdata) +
  aes(x = Moisture, y = SoilTemp) +
  geom_point(size = 0.2) +
  stat_smooth(method = "lm",
              formula = y ~ x,
              geom = "smooth")
cat("cor:",cor(Tomstdata$Moisture, Tomstdata$SoilTemp)) # -0.02


ggplot(Tomstdata) +
  aes(x = Moisture, y = AirTemp) +
  geom_point(size = 0.2) +
  stat_smooth(method = "lm",
              formula = y ~ x,
              geom = "smooth")
cat("cor:",cor(Tomstdata$Moisture, Tomstdata$AirTemp)) # -0.005

ggplot(Tomstdata) +
  aes(x = Moisture, y = SurfaceTemp) +
  geom_point(size = 0.2) +
  stat_smooth(method = "lm",
              formula = y ~ x,
              geom = "smooth")
cat("cor:",cor(Tomstdata$Moisture, Tomstdata$SurfaceTemp)) # 0.02

```

*Très bien corrélés : Air et surface temp.*

*Surafec et soil temp corrèlent moins bien.*

*Air et soil temp corrèlent encore moins bien. -\> la température du sol est tamponnée*

*Pas corrélé du tout : humidité du sol et les différentes température même pas celle du sol (**pas normal**).*

# *Day/night*

```{r}
# Memes heures que les HOBO
Tomstdata <- Tomstdata %>%
  mutate(Phase = ifelse((Hour <= hms::as_hms("18:45:00") & 
                           Hour >= hms::as_hms("06:15:00")),
                        "Day", "Night"))

cat("Night AirTemp range:",range(Tomstdata[Tomstdata$Phase == "Night",]$AirTemp), "°C") # 21.25 - 28.00 °C
cat("Day AirTemp range:",range(Tomstdata[Tomstdata$Phase == "Day",]$AirTemp), "°C") # 20.50 - 36.75 °C
```

Ma délimitation du jour et de la nuit sur la base des données de lumière des HOBO.

Jour : de 06:15 à 18:45

```{r, echo = F}
ggplot(Tomstdata, aes(x = Hour,y = AirTemp)) +
  geom_point(aes(color = Phase)) +
  labs(title="Air temperature over the day",
       x ="Hour", y = "Air temperature (°C)")

ggplot(Tomstdata, aes(x = Phase,y = AirTemp)) +
  geom_boxplot(aes(color = Phase)) +
  labs(title="Air temperature (°C) over the day",
       x ="Phase", y = "Air temperature (°C)")

ggplot(Tomstdata, aes(x = Hour,y = SoilTemp)) +
  geom_point(aes(color = Phase)) +
  labs(title="Soil temperature over the day",
       x ="Hour", y = "Soil temperature (°C)")

ggplot(Tomstdata, aes(x = Phase,y = Moisture)) +
  geom_boxplot(aes(color = Phase)) +
  labs(title="Moisture over the day",
       x ="Phase", y = "Moisture")

```

Peut-être que les données ne sont pas au bon fuseau horaire, pourtant elles étaient en UTC et je les ais mises en "America/Cayenne".

Et peut-être qu'il faut corriger les données d'humidité...

# *Seasons*
Définition saison sèche au mois : < 100 mm par mois (Bonal et al. 2008)
```{r}
Tomstdata <- Tomstdata %>%
  mutate(Season = ifelse(Month  %in% c(2,3, 8:11), # juill-nov et mars
                         "Dry", "Wet"))
```

```{r, echo = F}
ggplot(Tomstdata, aes(x = as.character(Month),y = AirTemp)) +
  geom_boxplot(aes(color = Season)) +
  labs(title="Air temperature over the seasons",
       x ="Month", y = "Air temperature (°C)")

ggplot(Tomstdata, aes(x = as.character(Month),y = Moisture)) +
  geom_boxplot(aes(color = Season)) +
  labs(title="Moisture over the seasons",
       x ="Month", y = "Moisture")
```

A travers les saisons l'humidité n'est pas incohérente.

# *Variables à calculer*

*à l'échelle du capteur :\
- moyenne de l'année\
- moyenne diurne\
- moyenne nocturne\
- moyenne saison sèche\
- diurne\
- nocturne\
- moyenne saison des pluies\
- diurne\
- nocturne\
- coefficient variation à ces échelles*

```{r}
annual_stats <- Tomstdata %>%
  group_by(TomstID) %>%
  summarise(across(c("Moisture", "SoilTemp", "SurfaceTemp", "AirTemp"),
                   list(annual_mean = ~mean(.),
                        annual_sd = ~sd(.),
                        annual_varcoef = ~(sd(.) / mean(.)) * 100,
                        annual_max = ~max(.),
                        annual_min = ~min(.)),
                   .names = "{.col}_{.fn}"))

phase_stats <- Tomstdata %>%
  group_by(TomstID,Phase) %>%
  summarise(across(c("Moisture", "SoilTemp", "SurfaceTemp", "AirTemp"),
                   list(mean = ~mean(.),
                        sd = ~sd(.),
                        varcoef = ~(sd(.) / mean(.)) * 100,
                        max = ~max(.),
                        min = ~min(.)),
                   .names = "{.col}_{.fn}"))

# "Phase" variable as an index for the computed variables
phase_stats <- pivot_wider(phase_stats, names_from = Phase,
                           values_from = names(phase_stats)[-c(1:2)],
                           names_glue = "{.value}_{Phase}")


season_stats <- Tomstdata %>%
  group_by(TomstID,Season) %>%
  summarise(across(c("Moisture", "SoilTemp", "SurfaceTemp", "AirTemp"),
                   list(mean = ~mean(.),
                        sd = ~sd(.),
                        varcoef = ~(sd(.) / mean(.)) * 100,
                        max = ~max(.),
                        min = ~min(.)),
                   .names = "{.col}_{.fn}")) 

# "Season" variable as an index for the computed variables
season_stats <- pivot_wider(season_stats, names_from = Season,
                            values_from = names(season_stats)[-c(1:2)],
                            names_glue = "{.value}_{Season}")

```

# *Stats dataset*

```{r}
stats <- annual_stats %>% 
  left_join(season_stats, by="TomstID") %>%
  left_join(phase_stats, by="TomstID")

stats <- left_join(stats, env_Par, by="TomstID")
```

# *Some plots*

```{r, echo = F}
stats %>%
  filter(!is.na(TopoHabitat)) %>%
  ggplot() +
  aes(x = TopoHabitat, y = Moisture_max_Wet) +
  geom_boxplot(fill = "#4698B4") +
  labs(x ="Topographic Habitat", y = "Maximum wet season moisture") +
  theme_minimal()

cat("Bizarre. Ya un souci avec l'humidité")

stats %>%
  filter(!is.na(TopoHabitat)) %>%
  ggplot() +
  aes(x = TopoHabitat, y = Moisture_mean_Wet) +
  geom_boxplot(fill = "#4698B4") +
  labs(x ="Topographic Habitat", y = "Average wet season moisture") +
  theme_minimal()

cat("Toujours bizarre")

stats %>%
  filter(!is.na(TopoHabitat)) %>%
  ggplot() +
  aes(x = TopoHabitat, y = AirTemp_max_Night) +
  geom_boxplot(fill = "yellow") +
  labs(x ="Topographic Habitat", y = "Maximum night air temperature (°C)") +
  theme_minimal()

cat("plus normal: il fait plus chaud dans les sols les plus secs")

stats %>%
  filter(!is.na(TopoHabitat)) %>%
  ggplot() +
  aes(x = TopoHabitat, y = AirTemp_mean_Wet) +
  geom_boxplot(fill = "yellow") +
  labs(x ="Topographic Habitat", y = "Average wet season air temperature (°C)") +
  theme_minimal()

stats %>%
  filter(!is.na(LightHabitat)) %>%
  ggplot() +
  aes(x = LightHabitat, y = AirTemp_annual_mean) +
  geom_boxplot(fill = "yellow") +
  labs(x ="Light Habitat", y = "Average annual air temperature (°C)") +
  theme_minimal()

stats %>%
  filter(!is.na(LightHabitat)) %>%
  ggplot() +
  aes(x = LightHabitat, y = SoilTemp_annual_mean) +
  geom_boxplot(fill = "brown") +
  labs(x ="Light Habitat", y = "Average annual soil temperature (°C)") +
  theme_minimal()

stats %>%
  filter(!is.na(LightHabitat)) %>%
  ggplot() +
  aes(x = LightHabitat, y = SoilTemp_annual_max) +
  geom_boxplot(fill = "brown") +
  labs(x ="Light Habitat", y = "Maximum annual soil temperature (°C)") +
  theme_minimal()

stats %>%
  filter(!is.na(LightHabitat)) %>%
  ggplot() +
  aes(x = LightHabitat, y = SurfaceTemp_annual_mean) +
  geom_boxplot(fill = "#8FB120") +
  labs(x ="Light Habitat", y = "Average annual surface temperature (°C)") +
  theme_minimal()


stats %>%
  filter(!is.na(LightHabitat)) %>%
  ggplot() +
  aes(x = LightHabitat, y = AirTemp_annual_mean) +
  geom_boxplot(fill = "#8FB120") +
  labs(x ="Light Habitat", y = "Average annual air temperature (°C)") +
  theme_minimal()

cat("la température à la lumière c'est bon")

```

# *Correlation test*

```{r, fig.height = 20}
DF_cor <- stats %>% 
  mutate(TopoHabitat = as.numeric(factor(TopoHabitat, levels = c("Bottomland", "Lower slope", "Mid slope", "Upper slope", "Plateau")))) %>% 
  mutate(LightHabitat = as.numeric(factor(LightHabitat, levels = c("Understory", "Sunfleck", "Gap border", "Gap")))) %>% 
  mutate(Transect = as.numeric(factor(Transect, levels = c("Topo", "Gap")))) %>% 
  na.omit()

CorMatrixS <- Hmisc::rcorr(as.matrix(DF_cor))
CorMatrixS <- CorMatrixS$r[-c(103:104),103:104]

CorMatrix <- round(CorMatrixS, digits = 2)  # matrice de corrélation
# Pval_corr <- CorMatrixS$P # p-values

# Plot de la matrice de corrélation :
corrplot(CorMatrix, method="circle",
         col=brewer.pal(n=8, name="PuOr"), cl.pos = "n", tl.col="black", tl.cex = 0.5)
```

*Srongly linked to LightHabitat:*

-   *Maximum annual air and surface temperature*

-   *Average annual air temperature*

-   *Average dry season surface temperature*

-   *Maximum wet season air and surface temperature*

-   *Average dry and wet season air temperatures*

<!-- -->

-   *Average day surface and air temperature*

-   *Maximum day air and surface temperature*

-   *Maximum night surface temperature*

*Linked to TopoHabitat:*

-   Maximum night air and surface temperature (+)

-   les sd et les varcoef (**je ne sais pas comment les interporéter**)

# *Sensors coordinates (mis de côté, à continuer)*

```{r, include = F}
coord_table <- Tomst_Paracou_env %>% 
  select(TomstID, SubPlot,
         TreeNum1, TreeNum2, TreeNum3, # IDs of neighbouring trees
         DTree1, DTree2, DTree3) %>% # distances to neighbouring trees
  na.omit()

idTrees <- unique(c(coord_table$TreeNum1, coord_table$TreeNum2, coord_table$TreeNum3))

Paracou16_2020 <- read_csv("~/PhD/Inventories/Data/Adults/Paracou16_2020.csv") %>% 
  filter(TreeFieldNum %in% idTrees) %>% 
  filter(SubPlot %in% unique(coord_table$SubPlot)) %>% 
  select(SubPlot, TreeFieldNum, Xfield, Yfield, Xutm, Yutm)

RefTrees <- Paracou16_2020
Target <- coord_table
# stop("Sensors coordinates: mis de côté, à continuer")
```

## *Trilateration*

```{r}

```

# *Save the stats dataset*

```{r}
# write.csv(stats, "~/PhD/Microclimate/Tomst/Tomst_stats.csv")
```
