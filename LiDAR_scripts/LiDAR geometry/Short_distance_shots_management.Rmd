---
title: "Algorithme détection des faux tirs sans écho (courte distance)"
author: "Vincyane Badouard"
date: "`r Sys.Date()`"
output: html_document
---
Algorithme de détection des tirs interrompus par des obstacles trop proches pour être détectés (< range minimum).  


Cas d'absence de retour à courte distance :  
1) vrai tir manquant : il n'y avait effectivement pas d'objet : trouée.  

2) faux tir manquant : objet présent mais le faisceux ne l'a pas vu car trop proche.  

3) interception partielle du signal : mais sans écho car dans zone aveugle (il manque un écho : sous-estimation de la densité, et mauvaise pondération des échos (qu'on a de toute facon pcq il garde que 3 échos)).  Solutionné si ne considère que l’écho d’intensité max (MIR).  

Echo d'intensité max : faiseaux arrété non traversant. Ce qui est le cas pour tout objet complètement touché par le faisceaux.  

Quelle est la nature de la transition entre zone aveugle et zone non-aveugle ? franche ou progressive ? 


Principe :  les faux tirs vides probables peuvent être détectés **s’ils intersectent des voxels denses/non vides à proximité (<50cm) de la source (= dans la zone aveugle).**
Dans ce cas, ces tirs sont éliminés (-> NA).
Les tirs sans échos (direction et position de départ) doivent être reconstruits au préalable.

Mise en œuvre : 

1) coder que les acquisitions entre 0 et 1.50 ne sont donc pas des tirs vides
2) Au préalable (unqiquement pour le calcul du voisinage dans la zone de cécité) :
- décimer le ndp dans les zones de fortes densité (2.5 cm) (edit>subsample (0.025m)) sur CloudCompare
- dont le range est supérieur à 1.5m pour exclure l’opérateur
- ne charger que les coordonnées et les points sous R

**Version avec AMAPvox** :
3) on filtre les échos suffisamment proches du trajet optique, susceptibles de renseigner sur les faux tirs vides (e.g. <60cm) ; cela peut être fait avec la fonction *nn2* de RANN après **sous-échantillonnage de la trajecto** (e.g. tous les ~10 cm) afin d’éviter de rater les zones aveugles tout en évitant la redondance d’informations qu’on aurait à plus petite échelle spatiale.

4) voxelisation de ces échos proches à haute résolution (e.g. 5 cm ?) ; application d’un nombre d’échos définissant la non-lacunarité (par défaut 1 écho)

5) suivi des trajets optiques (via AMAPVox) des seuls tirs sans retours ; si un tir intersecte un voxel proche non vide (à une distance inférieure ou égale à distance de cécité + epsilon) il est marqué comme « faux tir vide »

6) voxelisation standard après exclusion des faux tirs vides

Zone aveugle : < 50 cm de la source

**Version uniquement sous R** : 
3) sur la trajecto sélectionner un point tous les ~10cm
4) sélectionner dans le NDP tous les points à moins de 60cm des points de la trajecto 
5) Retracer les tirs sans écho (vecteurs)
6) Projeter un nuage de points d'après ces vecteurs dans la zone de cécité tous les 5 cm entre 0 et 50cm
7) Calculer le voisinage à 10 cm de chaque point projeté par le vecteur
8) Tester pour chaque vecteur si un point projeté par le vecteur 
 - a au moins un voisin « proche » (à moins de 10 cm)
 - a un voisinage encombré (bcp de points proches)
 - a un voisinage dense (ratio points/tirs élevé)
 9) Si oui c'est un faux tir vide : le supprimer. Si non c'est un vrai tir vide (trouée) le garder projeté à 500m.


script d'origine de Greg : Y:\users\VincyaneBadouard\codemartyr\DetectClutteredVolumesCloseToSensor.R

# Packages
```{r, include = F}
library(data.table)
library(lidR)
# library(zoo) # permet de synchroniser temps gps et tirs
library(interp)
library(RANN) # Fast Nearest Neighbour Search
library(ggplot2)
library(plot3D)
library(rgl) # visulaisation 3D
```

# The point cloud and trajectory 
```{r}
ST <- readLAS("Z:/users/VincyaneBadouard/Lidar/Hovermap/Scans Hovermap ST-X/Escadrone180723_ss_filtre/local/out3_laz1_4.laz")

Traj <- fread("Z:/users/VincyaneBadouard/Lidar/Hovermap/Scans Hovermap ST-X/Escadrone180723_ss_filtre/local/out3_traj.xyz")
```

# View data
```{r}
Traj
ST@data

range(ST@data$gpstime)
range(Traj$gpstime)

plot3d(Traj[,.(x,y,z)])
```
Filtrer entre 0.5 et 1.50 sur cloud compare et on voit la personne qui scanne

# Caractérisation de l'encombrement proche du capteur

## Sur la trajecto sélectionner un point tous les ~10cm
```{r}
## Function modulo 
mod <- function(n,m) {n - m * floor(n/m)} # pas trop compris ça 

sel_ds <- Traj[mod(1:nrow(Traj),10) == 0,] # un point tous les 10° de seconde
#sel_s=Traj[mod(1:nrow(Traj),100)==0,]
plot3d(sel_ds[,.(x,y,z)], aspect=F) # si on zoom on voit les points plus espacés
```

## Lecture du nuage de points
Au préalable (unqiquement pour le calcul du voisinage dans la zone de cécité) :
- décimer le ndp dans les zones de fortes densité (2.5 cm) (edit>subsample (0.025m)) sur CloudCompare
- dont le range est supérieur à 1.5m pour exclure l’opérateur mobile
- ne charger que les coordonnées et les points sous R


Tout ceci afin d’alléger le coût mémoire.

-> Décimation sur jeu test permet de passer de 173 10^6 à 28*10^6 pts
-> Exclusion des échos proches de la source réduit à 27*10^6 pts

En cas de coût prohibitif en mémoire penser à daller le nuage de points et d’étendre les trajecto à la jonction des dalles.

```{r}
ndp <- readLAS(
  "Z:/users/VincyaneBadouard/Lidar/Hovermap/Data_test/out1_laz1_4_decim- Cloud.laz",
  select = "xyz")
plot(ndp)
```

## Sélection des points proches de la trajecto (points d'émission)
Sélectionner dans le NDP tous les points à moins de 60cm des points de la trajecto (dans la zone de cécité)

```{r}
start.time <- Sys.time()
# Nearest Neighbour Search with nn2()
encomb <- nn2(ndp@data[,.(X,Y,Z)], sel_ds[,.(x,y,z)],
              treetype="kd", # k-dimensional tree : partition de l'espace
              k=min(50,nrow(ndp@data[,.(X,Y,Z)])), # maximum number of nearest neighbours to compute : 50
              searchtype = "radius", radius = 1.5) # 0.6

# A list of length 2 with elements:
# nn.idx : A N x k integer matrix returning the near neighbour indices.

end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken # 24 sec

idx <- unique(as.vector(as.matrix(encomb$nn.idx))) # near neighbour indices
length(idx) # 9224

plot3d(ndp@data[idx, .(X,Y,Z)], aspect=F, col="green") # the neighbours
points3d(sel_ds[,.(x,y,z)], aspect=F, col="red", add=T) # emission points

```


# Retracer les tirs sans écho
**avec** la zone 1.5m **non enlevée** : sans filtre (= l'opérateur)
et les données non décimées

```{r}
source("~/PhD/R_codes/PhD/LiDAR_scripts/Functions/trace_shots_with_echo.R")

vector_coord <- trace_shots_with_echo(ST, Traj, SampleTime = 3, OneRing = F)

source("~/PhD/R_codes/PhD/LiDAR_scripts/Functions/trace_shots_without_echo.R")

Gaps_vect_coord <- trace_shots_without_echo(ST, Traj, vector_coord, SampleTime = 3, OneRing = F, frot = 20)

# pq tirs vides dans le plafond 

```

# Projeter un nuage de points (B) d'après ces vecteurs dans la zone de cécité tous les 5 cm
Pour tous les tirs sans échos, tracer un segment de points ROUGES tous les 5cm entre 0 et 50cm
```{r}
options(digits = 2)

project_points <- function(Gaps_vect_coord, p = 0.05){
  XB = Gaps_vect_coord$X0 + Gaps_vect_coord$x_dir * p
  YB = Gaps_vect_coord$Y0 + Gaps_vect_coord$y_dir * p
  ZB = Gaps_vect_coord$Z0 + Gaps_vect_coord$z_dir * p
  
  cloud_virt <- data.frame(XB = XB,
                           YB = YB,
                           ZB = ZB,
                           Dist = p,
                           gpstime = Gaps_vect_coord$gpstime)
  return(cloud_virt)
}

cloud_virt <- c()
for(p in seq(0.05,1.50, by= 0.05)){
  cloud_virt <- rbind(cloud_virt, project_points(Gaps_vect_coord, p = p))
}

cloud_virt <- as.data.table(cloud_virt)

encomb <- ndp@data[idx, .(X,Y,Z)] 

rgl::plot3d(cloud_virt, aspect = F, col = "red")# points projetés par le vecteur 
rgl::plot3d(encomb, aspect = F, add = T, col = "green") # Voisinage à 60 cm
rgl::plot3d(Traj[,.(x,y,z)], aspect = F, add = T, col = "black")

```

# Calculer le voisinage à 10 cm de chaque point projeté par le vecteur 
```{r}

neigh <- nn2(na.omit(cloud_virt[,.(XB,YB,ZB)]), encomb,
             treetype="kd", # k-dimensional tree : partition de l'espace
             k=min(1,nrow(ndp@data[,.(X,Y,Z)])), # maximum number of nearest neighbours to compute
             searchtype = "radius", radius = 0.1)

rgl::plot3d(cloud_virt[,.(XB,YB,ZB)], aspect = F, col = "red")# points projetés par le vecteur 
rgl::plot3d(neigh, aspect = F, add = T, col = "green") # Voisinage à 60 cm
rgl::plot3d(Traj[,.(x,y,z)], aspect = F, add = T, col = "black")


options(digits=22)
fake_empty <- unique(cloud_virt[neigh$nn.idx, gpstime]) # les faux vides
length(fake_empty) # 666
head(sort(fake_empty))
```


# Tester pour chaque vecteur si un point projeté par le vecteur (rouge) (A FAIRE)
 - a au moins un voisin « proche » (à moins de 10 cm)
 - a un voisinage encombré (bcp de points proches)
 - a un voisinage dense (ratio points/tirs élevé)
```{r}

```
 

# Classement des vrais et faux tirs sans écho courte distance (A FAIRE)
Si oui c'est un faux tir vide : le supprimer. Si non c'est un vrai tir vide (trouée) le garder projeté à 500m.
```{r}

```


# Vérifier que notre script fonctionne
Recréer un buffer cécité plus longue distance :1-2m autour de chaque point d'émission
Enlever tous les points dans ce buffer pour un faisceau
faire tourner l'algo
voir si l'algo détecte que ce sont des faux tirs vides
et n'en crée pas trop 




