---
title: "Get LiDAR spatial geometry"
author: "Vincyane Badouard"
date: '`r Sys.Date()`'
output:
  html_document:
    df_print: paged
  pdf_document: default
---

# Packages
```{r, include = F}
library(data.table)
library(lidR)
# library(zoo) # permet de synchroniser temps gps et tirs
library(rgl) # visulaisation 3D
library(interp)
library(ggplot2)
library(plot3D)
```

# The point cloud and trajectory paths 
```{r}
HovermapST_X_path <- "Z:/users/VincyaneBadouard/Lidar/Hovermap/Scans Hovermap ST-X/Hand Scan/gcp_output/STX_third04_laz1_4.laz"

HovermapST_X_traj <- "Z:/users/VincyaneBadouard/Lidar/Hovermap/Scans Hovermap ST-X/Hand Scan/gcp_output/STX_third04_traj.xyz"
```

# Import the points cloud
```{r}
ST <- readLAS(HovermapST_X_path)
ST
ST@data

hist(ST@data$Ring) # 32 faisceaux

unique(ST@data$ReturnNumber) # 0 or 1 or 2
unique(ST@data$NumberOfReturns) # 0

table(ST@data$NumberOfReturns) # CONTINU. normalment : echo 1 = 0, echo 2 = 1
table(ST@data$ReturnNumber) # echo 1 = 62963145, echo 2 = 1078485, echo 3 = 608917 

# Vérifier l'unicité des gpstime
options(digits=22)
length(unique(ST@data$gpstime)) # 39956846. doit être égal ou supérieur à la somme des échos
sum(table(ST@data$ReturnNumber)) # 64650547
dup1 <- ST@data[anyDuplicated(ST@data$gpstime),]
dup <- ST@data[duplicated(gpstime),.(gpstime)]
dup <- ST@data[gpstime %in% dup$gpstime, .(gpstime, Ring)]
# les gpstime sont dupliqués par couple de faisceaux : ils acquièrent en meme temps 
# pas un problème pcq on traite par faisceau par faisceau : pas de conflit de temps

# plot(ST) # trop lourd
```

# Import the trajectory
```{r}
Traj <- fread(HovermapST_X_traj)
Traj 

plot3d(Traj[,.(x, y,z)], aspect=F) # plot the trajectory (x,y,z)
# options(digits=12)
```

# Take only the 1st echo
```{r}
Cloud <- ST@data[ReturnNumber == 0]
```

# Sample only few seconds of the data to work
gpstime in the las and in the traj files is in seconds
The gpstime in the las file is the emission time (same as trajectory time), not the impact time.
```{r}
fstsec <- 1679488739.935013055801
# 3 seconds
Cloud <- Cloud[gpstime >= fstsec-3 & gpstime<= fstsec]
Traj <- Traj[gpstime >= fstsec-3 & gpstime<= fstsec]

plot3d(Traj[,.(x, y,z)], aspect=F) 
```


# Separate data of each ring in different tables
```{r}
# 31 rings
Ring1 <- Cloud[Ring == 1]
Ring1
```

# Compute the unit vectors between sensor position and the acquired point 

## For shots with echo
```{r}
# Remove useless columns
Ring1 <- Ring1[,.(Ring, gpstime, X,Y,Z, Range)]
Traj <- Traj[,.(gpstime, x,y,z)]
```

Emission point: A
Acquired points coordinates : B
-> Compute the direction vector (AB) between the emission and the acquired point.

```{r}
# Acquired points coordinates (B)
Xb <- Ring1$X
Yb <- Ring1$Y
Zb <- Ring1$Z

# Interpolate coordinates of the emission point (A) (in the traj) from coordinates before and after (= barycentric interpolation)
length(Traj$gpstime) # 300
length(Traj$x) # 300
length(Ring1$gpstime) # 20002
max(Traj$gpstime) # 1679488739.935
max(Ring1$gpstime) #1679488739.931

Xa <- approx(x = Traj$gpstime, y = Traj$x , xout = Ring1$gpstime)$y # x : temps de la traj, xout : temps du cloud, $y pour avoir les coordonées x et non les temps
Ya <- approx(Traj$gpstime, y = Traj$y , Ring1$gpstime)$y
Za <- approx(Traj$gpstime, y = Traj$z , Ring1$gpstime)$y

# Compute the coordinates of the AB vector between the emission and the acquired point
vector_coord <- data.frame(x_dir = Xb-Xa,
                           y_dir = Yb-Ya,
                           z_dir = Zb-Za) # coordinates

# Compute the norm of the direction vector (AB)
vector_coord$Distance <- sqrt(
  (vector_coord$x_dir)^2 + (vector_coord$y_dir)^2 + (vector_coord$z_dir)^2
) 
# Transform in direction vector of norm = 1
vector_coord$x_dir <- vector_coord$x_dir / vector_coord$Distance
vector_coord$y_dir <- vector_coord$y_dir / vector_coord$Distance
vector_coord$z_dir <- vector_coord$z_dir / vector_coord$Distance

# Add A (emission) coordinates in the table
vector_coord$X0 <- Xa
vector_coord$Y0 <- Ya
vector_coord$Z0 <- Za

# and associated time 
vector_coord$gpstime <- Ring1$gpstime 
```

### Check that we retrieve the original point for emission point, direction vector and distance:

Recalculer x,y,zb : à partir de x,y,zo : xb = x0 + xdir * distance
pour vérifier qu'on est bon
```{r}
check_B <- data.frame(XB = vector_coord$X0 + vector_coord$x_dir * vector_coord$Distance,
                      YB = vector_coord$Y0 + vector_coord$y_dir * vector_coord$Distance,
                      ZB = vector_coord$Z0 + vector_coord$z_dir * vector_coord$Distance)

# Check that we retrieve the original point from emission point, direction vector and distance:
all(check_B$XB - Ring1$X == 0)
all(check_B$YB - Ring1$Y == 0)
all(check_B$ZB - Ring1$Z == 0)
```

### Plot vectors
```{r}
# vect_matrix <- vector_coord %>% 

plot3d(Traj[,.(x, y,z)], aspect=F) # plot the trajectory (x,y,z)

subset <- seq(1, nrow(vector_coord), by=200) # each 200 pulses

# Direction vectors
png("D:/Mes Donnees/PhD/Figures/Directions_vectors.png", width = 900, height = 800)
arrows3D(
  x0 = vector_coord$X0[subset],
  y0 = vector_coord$Y0[subset],
  z0 = vector_coord$Z0[subset],
  
  x1 = (vector_coord$X0[subset] + vector_coord$x_dir[subset]),
  y1 = (vector_coord$Y0[subset] + vector_coord$y_dir[subset]),
  z1 = (vector_coord$Z0[subset] + vector_coord$z_dir[subset]), col = "grey", bty = "g", pch = 20, cex = 1, ticktype = "detailed") # cex : text size

points3D(x = vector_coord$X0[subset], # emission points
         y = vector_coord$Y0[subset],
         z = vector_coord$Z0[subset], col = "red", add=T)

points3D(x = (vector_coord$X0[subset] + vector_coord$x_dir[subset]), # collected points
         y = (vector_coord$Y0[subset] + vector_coord$y_dir[subset]),
         z = (vector_coord$Z0[subset] + vector_coord$z_dir[subset]),
         colvar = vector_coord$gpstime[subset], add=T)

scatter3D(Traj$x, Traj$y, Traj$z, colvar = NULL, add=T) 
dev.off()

# Initial vectors
png("D:/Mes Donnees/PhD/Figures/Initial_vectors.png", width = 900, height = 800)
arrows3D(
  x0 = vector_coord$X0[subset], y0 = vector_coord$Y0[subset], z0 = vector_coord$Z0[subset],
  x1 = Xb[subset], y1 = Yb[subset], z1 = Zb[subset],
  col="grey", bty = "g", pch = 20, cex = 1, ticktype = "detailed")

points3D(x = vector_coord$X0[subset], # emission points
         y = vector_coord$Y0[subset],
         z = vector_coord$Z0[subset], col = "red", add=T)

points3D(x = Xb[subset], y = Yb[subset], z = Zb[subset], # collected points
         colvar = vector_coord$gpstime[subset], add=T)


scatter3D(Traj$x, Traj$y, Traj$z, colvar = NULL,  bty = "g",
          pch = 20, cex = 1, ticktype = "detailed", add=T) 
dev.off()
```

## For shots without echo
### Find the temporal gaps in the regular time step
```{r}
unique(as.integer(Ring1$gpstime)) # seems to be not a lots of time value
Ring1$gpstime[1]==Ring1$gpstime[2] # but in real it's not the same time values

plot(Traj$gpstime) # lots of values

hist(diff(Ring1$gpstime)) # 2 digits
options(digits=22) # to see all the digits

# Compute time step
diff_time <- diff(Ring1$gpstime)
diff_time # 0.00005 seems to be the most regular value
dt_mean <- mean(diff_time[diff_time < 0.00006]) # pas de temps de référence (dt) (moyenne des réguliers)
gaps <- diff_time[diff_time > 0.00006] # ceux qui ne sont pas réguliers
gaps
ngaps <- round(gaps/dt_mean) # nombre de shots sans écho qui on pu se faire entre ceux avec écho
ngaps

index<-which(diff_time > 0.00006) # indice des shots pas réguliers

all(Ring1$gpstime[index+1]-Ring1$gpstime[index] == gaps) # vérifier que le temps de gaps correspond au temps entre  entre 2 shots à écho

# Calculer les gps time manqués :
# chaque index a un ngaps
# Ring1$gpstime[index] + seq(ngaps) * dt_mean # temps de chaque tir manqué par index

gpstime_gaps <- unlist(sapply(seq(ngaps), function(i)
   # temps annormal + (nbr)
  Ring1$gpstime[index][i] + seq(ngaps[i]) * dt_mean # un index pour chaque tir sans écho
))
# question : on devrait pas mettre -1 à index
all(diff(gpstime_gaps) < 0.00006) # pas tous vrai : normal pcq il manque gpstime des tirs à écho
all_gpstime <- c(Ring1$gpstime, gpstime_gaps)
all(diff(all_gpstime[order(all_gpstime)]) < 0.00006) # tous bien < 0.00006

length(gpstime_gaps) == sum(ngaps) # check qu'il y a autant de temps gps que de tirs sans écho
```

### retrieve direction vectors
```{r}
# Interpolate coordinates of the emission point (A) (in the traj) for the gaps gpstime (shots without echo)
Xa <- approx(x = Traj$gpstime, y = Traj$x, xout = gpstime_gaps)$y # x : temps de la traj, xout : temps des gaps, $y pour avoir les coordonées x et non les temps
Ya <- approx(Traj$gpstime, y = Traj$y , gpstime_gaps)$y
Za <- approx(Traj$gpstime, y = Traj$z , gpstime_gaps)$y

# Interpolate the direction vectors of this shots without echo (intercalate between vectors of the shots with echo)
x_dir <- approx(x = vector_coord$gpstime, y = vector_coord$x_dir, xout = gpstime_gaps)$y
y_dir <- approx(vector_coord$gpstime, y = vector_coord$y_dir, gpstime_gaps)$y
z_dir <- approx(vector_coord$gpstime, y = vector_coord$z_dir, gpstime_gaps)$y


# In a table:
gaps_vector_coord <- data.frame(x_dir = x_dir, # vector coordinates
                                y_dir = y_dir,
                                z_dir = z_dir,
                                Distance = 100,# m. Il n'y a pas de distance puisqu'il n'y a pas d'echo
                                gpstime = gpstime_gaps) 

# Compute the norm of the direction vector
gaps_dir_norm <- sqrt(gaps_vector_coord$x_dir^2 + gaps_vector_coord$y_dir^2 + gaps_vector_coord$z_dir^2)# n'a pas conservé une norme =1

# Transform in unit vector (norm = 1)
gaps_vector_coord$x_dir <- gaps_vector_coord$x_dir / gaps_dir_norm
gaps_vector_coord$y_dir <- gaps_vector_coord$y_dir / gaps_dir_norm
gaps_vector_coord$z_dir <- gaps_vector_coord$z_dir / gaps_dir_norm

gaps_vector_coord$X0 <- Xa
gaps_vector_coord$Y0 <- Ya
gaps_vector_coord$Z0 <- Za

```

## Cas des tirs ayant eu le temps de faire un demi tour
```{r}
    # Inverser les vecteurs qui on changé de plan de rotation par rapport aux
    # vecteurs dont ils sont interpolés : ils ont dépassé le demi-tour (n fois)
    # (1/40)/(5*(10^-5))
    # (1/frot)/2 = 1/40 : temps mis pour faire un demi tour
    # gaps>(1/40) -> vecteurs inversés
    demitour <- (1/frot)/2 # frot : frequency of rotation in Hz
    val <- ceiling(gpstime_gaps/demitour)-1 # ils ont dépassé le demi-tour
    # Les impairs c'est dans le plan oposé à ceux des vecteurs dont ils sont interpolés 
    # Les pairs ont eu le temps de revcenir dans le même plan
    impair <- val%%2 != 0 # T = pair
    
    
    gaps_vector_coord$x_dir[impair] <-  gaps_vector_coord$x_dir[impair]*(-1)
    gaps_vector_coord$y_dir[impair] <- gaps_vector_coord$y_dir[impair]*(-1)
    gaps_vector_coord$y_dir[impair] <- gaps_vector_coord$z_dir[impair]*(-1)
```

## Cas de tour complet vide
```{r}

```

# Test our calcul for shots without echo
To check if our calcul works, we can remove a part of known data and check if we retrieve it : créer des faux sans écho
We can remove:
- randomly 10% of known data
- a continuous part of known data
We can also quantified the error at 100 m :
1) avec le vecteur directeur on projette les points à 100m (distance) 
2) après je vire les 10%  (on fait des faux sans écho)
3) après on essaye de les retouver les faux tirs sans écho (on compare le Xb Initial à 100m et celui estimé à 100m)

If we retrieve the removed points means that the sensor rotation speed is stable.

## Project the points 100 m from their point of emission 
Emission point (X,Y,Z0) + coord of the direction vector(x,y,z_dir) * Distance (100 m)
```{r}
vector_coord$XB100 = vector_coord$X0 + vector_coord$x_dir * 100
vector_coord$YB100 = vector_coord$Y0 + vector_coord$y_dir * 100
vector_coord$ZB100 = vector_coord$Z0 + vector_coord$z_dir * 100
```


## Remove randomly 10% of known data
```{r}
setDT(vector_coord) # as data.table
Test_10Cloud <- copy(vector_coord)
Test_10Cloud[sample(nrow(Test_10Cloud), 0.1 * nrow(Test_10Cloud)), c("XB100", "YB100", "ZB100") := NA_real_]

removed <- which(is.na(Test_10Cloud$XB100))
retained <- which(!is.na(Test_10Cloud$XB100))

```

## Remove a continuous part of known data
500 lignes pour un demi-tour
prendre 800
```{r}
Test_contCloud <- copy(vector_coord)

# gpstime>1660049400 & gpstime<1660049401
Test_contCloud[100:800, c("XB100", "YB100", "ZB100") := NA_real_] # 100 points

removed <- which(is.na(Test_contCloud$XB100))
retained <- which(!is.na(Test_contCloud$XB100))
```

## Check if we retrieve initial data
```{r}
# We have only the gps time of the shots to estimate

# Interpolate coordinates of the emission point (A) (in the traj) for the gaps gpstime (shots without echo)
removed_time <- vector_coord$gpstime[removed]
X0 <- approx(x = Traj$gpstime[Traj$gpstime != removed_time],
             y = Traj$x[Traj$gpstime != removed_time],
             xout = removed_time)$y 
# any(is.na(Xa))
Y0 <- approx(x = Traj$gpstime[Traj$gpstime != removed_time],
             y = Traj$y[Traj$gpstime != removed_time],
             xout = removed_time)$y
Z0 <- approx(x = Traj$gpstime[Traj$gpstime != removed_time],
             y = Traj$z[Traj$gpstime != removed_time],
             xout = removed_time)$y

# Interpolate the direction vectors of this shots without echo (intercalate between vectors of the shots with echo)
x_dir <- approx(x = vector_coord$gpstime[retained],
                y = vector_coord$x_dir[retained],
                xout = vector_coord$gpstime[removed])$y
y_dir <- approx(x = vector_coord$gpstime[retained],
                y = vector_coord$y_dir[retained],
                xout = vector_coord$gpstime[removed])$y
z_dir <- approx(x = vector_coord$gpstime[retained],
                y = vector_coord$z_dir[retained],
                xout = vector_coord$gpstime[removed])$y

# Compute the norm of the direction vector
dir_norm <- sqrt(x_dir^2 + y_dir^2 + z_dir^2)

# Transform in unit vector (norm = 1)
x_dir <- x_dir / dir_norm
y_dir <- y_dir / dir_norm
z_dir <- z_dir / dir_norm

check_B <- data.frame(XB = X0 + x_dir * 100,
                      YB = Y0 + y_dir * 100,
                      ZB = Z0 + z_dir * 100)

# Check that we retrieve the original point from emission point, direction vector and distance:
all(check_B$XB - vector_coord$XB100[removed] == 0)
all(check_B$YB - vector_coord$YB100[removed] == 0)
all(check_B$ZB - vector_coord$ZB100[removed] == 0)

all(X0 - vector_coord$X0[removed] == 0)
all(Y0 - vector_coord$Y0[removed] == 0)
all(Z0 - vector_coord$Z0[removed] == 0) # the emission coordinates are well retrieved!

check_B$XB[1]; vector_coord$XB100[removed][1]
check_B$YB[1]; vector_coord$YB100[removed][1]
check_B$ZB[1]; vector_coord$ZB100[removed][1] # the direction vector are not exactly the same

# mean difference
mean(check_B$XB - vector_coord$XB100[removed])
mean(check_B$YB - vector_coord$YB100[removed])
mean(check_B$ZB - vector_coord$ZB100[removed])

```

Plot the difference
```{r}
subset <- seq(1, nrow(check_B), by=100) # each 200 pulses

arrows3D(
  x0 = X0[subset],
  y0 = Y0[subset],
  z0 = Z0[subset],
  
  x1 = check_B$XB[subset],
  y1 = check_B$YB[subset],
  z1 = check_B$ZB[subset], col = "red", bty = "g", pch = 20, cex = 1, ticktype = "detailed") # cex : text size

arrows3D(
  x0 = X0[subset],
  y0 = Y0[subset],
  z0 = Z0[subset],
  
  x1 = vector_coord$XB100[removed][subset],
  y1 = vector_coord$YB100[removed][subset],
  z1 = vector_coord$ZB100[removed][subset], col = "green", bty = "g", pch = 20, cex = 1, ticktype = "detailed") # cex : text size

# same!
```

## Remove a continuous part of known data

## Check if we retrieve initial data


## Pour tous le jeu de données (A FAIRE)
```{r}
source("~/PhD/R_codes/PhD/LiDAR_scripts/Functions/trace_shots_with_echo.R")

vector_coord <- trace_shots_with_echo(ST, Traj, OneRing = F)

source("~/PhD/R_codes/PhD/LiDAR_scripts/Functions/trace_shots_without_echo.R")

Gaps_vect_coord <- trace_shots_without_echo(ST, Traj, vector_coord, OneRing = F, frot = 20)
```

Pour bosser dans amapvox
projeter les points sans écho originellement en dehors de la zone d'étude (à 500 m par ex) et enregistrer ces points sous un nouveau laz.

## Project the points 500 m from their point of emission (A FAIRE)
Emission point (X,Y,Z0) + coord of the direction vector(x,y,z_dir) * Distance (500 m)
```{r}
distance <- 500
vector_coord$XB = vector_coord$X0 + vector_coord$x_dir * distance
vector_coord$YB = vector_coord$Y0 + vector_coord$y_dir * distance
vector_coord$ZB = vector_coord$Z0 + vector_coord$z_dir * distance
```


# Ajouter les points projetés dans le nuage de points
soit compléter le laz existant soit faire un laz à part et binder avec lidr (A FAIRE)
```{r}
# transform in a LAS object
las2 <- LAS(vector_coord[,.(XB,YB,ZB)], ST@header)

# This triggers some warning because we input some inccorectly quantized coordinates. Check the output of las_check()
las_check(las2)
# We can fix that
las2 <- las_quantize(las2, TRUE)
las2 <- las_update(las2)

las_check(las2)

# To combine the ST and las2 they must have the same columns.
# We need to make them manually.
# Here if you load only XYZ in las the job is easier.

las2@data$gpstime = 0
las2@data$Intensity = 0L
las2@data$ReturnNumber = 1L
las2@data$NumberOfReturns = 1L
las2@data$ScanDirectionFlag = 0L
las2@data$EdgeOfFlightline = 0L
las2@data$Classification = 0L
las2@data$Synthetic_flag = FALSE
las2@data$Keypoint_flag = FALSE
las2@data$Withheld_flag = FALSE
las2@data$ScanAngleRank = 0L
las2@data$UserData = 0L
las2@data$PointSourceID = 0L

# Bind
Output <- lidR::rbind(ST, las2)

writeLAS(Output, "Z:/users/VincyaneBadouard/ALS2022/P16_ALS2022_without_echo.laz")
```

