---
title: "Algorithme détection des faux tirs sans écho (courte distance)"
author: "Vincyane Badouard"
date: "`r Sys.Date()`"
output: html_document
---
Algorithme de détection des tirs interrompus par des obstacles trop proches pour être détectés


1) Lorsqu'on aura acquis nos données, avant de filtrer pour enlever l'humain il faut coder que les acquitions entre 0 et 1.50 sont donc pas des tirs vides.

2) 




Algorithme de détection des tirs interrompus par des obstacles trop proches pour être détectés.  

Cas problématiques :  
1) aucune interception : voxel non vide mais le faisceux ne l'a pas vu et n'a rien intercepté derrière : sans retour.  

2) interception partielle mais sans écho car dans zone aveugle (il manque un écho : sous-estimation de la densité, et mauvaise pondération des échos)  


Solutions :
- faire démarrer les trajets optiques à 50 cm de la source  

il nous reste le biais de la mauvaise pondération des échos, mais qu'on a de toute facon pcq il garde que 3 échos (dont l'écho max)  

Peut-être que prendre l'écho d'intensité max : faiseaux arrété non traversant. Ce qui est le cas pour tout objet complètement touché par le faisceaux.  



On pourrait en principe tout faire hors d'AMAPvox mais l'algorithme de suivi des rayons étant déjà implémenté dans AMAPVox le plus efficace serait de s'en servir.  

Principe :  les faux tirs vides probables peuvent être détectés **s’ils intersectent des voxels denses/non vides à proximité (<50cm) de la source (= dans la zone aveugle).**
Dans ce cas, ces tirs sont éliminés (-> NA).
Les tirs sans échos (direction et position de départ) doivent être reconstruits au préalable.

Mise en œuvre : 

1) on filtre les échos suffisamment proches du trajet optique, susceptibles de renseigner sur les faux tirs vides (e.g. <60cm) ; cela peut être fait avec la fonction *nn2* de RANN après **sous-échantillonnage de la trajecto** (e.g. tous les ~10 cm) afin d’éviter de rater les zones aveugles tout en évitant la redondance d’informations qu’on aurait à plus petite échelle spatiale.

2) voxelisation de ces échos proches à haute résolution (e.g. 5 cm ?) ; application d’un nombre d’échos définissant la non-lacunarité (par défaut 1 écho)

3) suivi des trajets optiques (via AMAPVox) des seuls tirs sans retours ; si un tir intersecte un voxel proche non vide (à une distance inférieure ou égale à distance de cécité + epsilon) il est marqué comme « faux tir vide »

4) voxelisation standard après exclusion des faux tirs vides

Zone aveugle : < 50 cm de la source

script d'origine de Greg : Y:\users\VincyaneBadouard\codemartyr\DetectClutteredVolumesCloseToSensor.R

# Packages
```{r, include = F}
library(data.table)
library(lidR)
# library(zoo) # permet de synchroniser temps gps et tirs
library(interp)
library(RANN) # Fast Nearest Neighbour Search
library(ggplot2)
library(plot3D)
library(rgl) # visulaisation 3D
```

# The point cloud and trajectory 
```{r}
ST <- readLAS("Z:/users/VincyaneBadouard/Lidar/Hovermap/Data_test/out1_laz1_4.laz")

Traj <- fread("Z:/users/VincyaneBadouard/Lidar/Hovermap/Data_test/out1_traj.xyz")
```

# View data
```{r}
Traj
ST@data

range(ST@data$gpstime)
range(Traj$gpstime)
```
Filter entre 0.5 et 1.50 sur cloud compare et on voit la personne qui scanne

# Part 1: caractérisation de l'encombrement proche du capteur

## Lecture de la trajectoire (IMU)
```{r}
traj <- fread("Z:/users/VincyaneBadouard/Lidar/Hovermap/Data_test/out1_traj.xyz")
plot3d(traj[,.(x,y,z)])
```

## Sur la trajecto sélectionner un point tous les ~10cm
```{r}
## Function modulo 
mod <- function(n,m) {n - m * floor(n/m)} # pas trop compris ça 

sel_ds <- traj[mod(1:nrow(traj),10) == 0,] # un point tous les 10° de seconde
#sel_s=traj[mod(1:nrow(traj),100)==0,]
plot3d(sel_ds[,.(x,y,z)], aspect=F) # si on zoom on voit les points plus espacés
```

## Lecture du nuage de points
Au préalable :
- décimer le ndp dans les zones de fortes densité (2.5 cm) (edid>subsample (0.025m)) sur CloudCompare
- dont le range est supérieur à 1.5m pour exclure l’opérateur mobile
- ne charger que les coordonnées et les points sous R


Tout ceci afin d’alléger le coût mémoire.

-> Décimation sur jeu test permet de passer de 173 10^6 à 28*10^6 pts
-> Exclusion des échos proches de la source réduit à 27*10^6 pts

En cas de coût prohibitif en mémoire penser à daller le nuage de points et d’étendre les trajecto à la jonction des dalles.

```{r}
#ndp <- readLAS("y:/users/VincyaneBadouard/Lidar/Hovermap/Scans Hovermap ST-X/Escadrone180723_ss_filtre/local/out3_subsampled_laz1_4.laz")
#ndp <- readLAS("y:/users/VincyaneBadouard/Lidar/Hovermap/Scans Hovermap ST-X/Escadrone180723_ss_filtre/local/out3_laz1_4.laz",
#            select="xyzRange")

ndp_clutter <- readLAS(
  "Z:/users/VincyaneBadouard/Lidar/Hovermap/Data_test/out1_laz1_4_decim- Cloud.laz",
  select = "xyz")
plot(ndp_clutter)
ndp <- ndp_clutter
rm(ndp_clutter)
```

## Sélection des points proches de la trajecto
Sélectionner dans le NDP tous les points à moins de 60cm des points de la trajecto 
Pour tous les tirs sans échos, tracer un segment de points ROUGES tous les 5cm entre 0 et 50cm

```{r}
start.time <- Sys.time()
# Nearest Neighbour Search with nn2()
encomb <- nn2(ndp@data[,.(X,Y,Z)], sel_ds[,.(x,y,z)],
              treetype="kd", # k-dimensional tree : partition de l'espace
              k=min(50,nrow(ndp@data[,.(X,Y,Z)])), # maximum number of nearest neighbours to compute
              searchtype = "radius", radius = 1.5) # 0.6

# A list of length 2 with elements:
# nn.idx : A N x k integer matrix returning the near neighbour indices.

end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken # 24 sec

idx <- unique(as.vector(as.matrix(encomb$nn.idx))) # near neighbour indices
length(idx) # 9224

plot3d(ndp@data[idx, .(X,Y,Z)], aspect=F, col="green") # the neighbours
points3d(sel_ds[,.(x,y,z)], aspect=F, col="red", add=T) # emission points

```


# Partie 2 - Retracer les tirs sans écho
**avec** la zone 1.5m **non enlevée** : sans filtre (= l'humain)

```{r}
vector_coord <- trace_shots_with_echo(ST, Traj, SampleTime = 3, OneRing = TRUE)

Gaps_vect_coord <- trace_shots_without_echo(ST, Traj, vector_coord, SampleTime = 3, OneRing = TRUE)

# pq tirs vides dans le plafond 

```


```{r}

XB <- c()
YB <- c()
ZB <- c()
# for(i in 1:nrow(Gaps_vect_coord)){
for(p in seq(0.05,1.50, by= 0.05)){ 
  p= 0.05
  XB = Gaps_vect_coord$X0 + Gaps_vect_coord$x_dir * p
  YB = Gaps_vect_coord$Y0 + Gaps_vect_coord$y_dir * p
  ZB = Gaps_vect_coord$Z0 + Gaps_vect_coord$z_dir * p
  # idx = # reccupérer l'id du vecteur 
  # pas : # 5, 10, 15 etc
}
# }

options(digits = 2)
project_points <- function(Gaps_vect_coord, p = 0.05){
  XB = Gaps_vect_coord$X0 + Gaps_vect_coord$x_dir * p
  YB = Gaps_vect_coord$Y0 + Gaps_vect_coord$y_dir * p
  ZB = Gaps_vect_coord$Z0 + Gaps_vect_coord$z_dir * p
  
  cloud_virt <- data.frame(XB = XB,
                           YB = YB,
                           ZB = ZB,
                           Dist = p,
                           gpstime = Gaps_vect_coord$gpstime)
  return(cloud_virt)
}

res <- c()
for(p in seq(0.05,1.50, by= 0.05)){
  res <- rbind(res, project_points(Gaps_vect_coord, p = p))
}

mapply(project_points, )



cloud_virt <- data.frame(XB = XB,
                         YB = YB,
                         ZB = ZB)
# idx = nrow(),
# pas = )
encomb <- ndp@data[idx, .(X,Y,Z)] 

cloud_virt <- as.data.table(res)

rgl::plot3d(cloud_virt, aspect = F, col = "red")
rgl::plot3d(encomb, aspect = F, add = T, col = "green")
rgl::plot3d(Traj[,.(x,y,z)], aspect = F, add = T, col = "black")

```

```{r}

neigh <- nn2(na.omit(cloud_virt[,.(XB,YB,ZB)]), encomb,
             treetype="kd", # k-dimensional tree : partition de l'espace
             k=min(1,nrow(ndp@data[,.(X,Y,Z)])), # maximum number of nearest neighbours to compute
             searchtype = "radius", radius = 0.1) # 0.6
options(digits=22)
fake_empty <- unique(cloud_virt[neigh$nn.idx, gpstime]) # les faux vides
length(fake_empty) # 666
head(sort(fake_empty))
```


# tester pour chaque vecteur si un point ROUGE 
- a au moins un voisin « proche » e.g à moins de 10 cm
- a un voisinage encombré (bcp de points proches)
- a un voisinage dense (ratio points/tirs élevé)


# Vérifier que notre script fonctionne
Recréer un buffer cécité plus longue distance :1-2m autour de chaque point d'émission
Enlever tous les points dans ce buffer pour un faisceau
faire tourner l'algo
voir si l'algo détecte que ce sont des faux tirs vides
et n'en crée pas trop 


