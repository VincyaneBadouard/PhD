---
title: "Get LiDAR spatial geometry"
author: "Vincyane Badouard"
date: "`r Sys.Date()`"
output: pdf_document
---

# Packages
```{r, include = F}
library(data.table)
library(lidR)
# library(zoo) # permet de synchroniser temps gps et tirs
library(rgl) # visulaisation 3D
library(interp)
library(ggplot2)
```

# The point cloud and trajectory paths 
```{r}
Hovermap_path <- "Z:/users/VincyaneBadouard/Lidar/Hovermap/20220908ST0412Scan/Output/st0142target_09_Output_gcp_global_laz1_4.laz"
HovermapST_X_path <- "Z:/users/VincyaneBadouard/Lidar/Hovermap/Scans Hovermap ST-X/Hand Scan/gcp_output/STX_third04_laz1_4.laz"

Hovermap_traj <- "Z:/users/VincyaneBadouard/Lidar/Hovermap/20220908ST0412Scan/Output/st0142target_09_Output_gcp_global_traj.xyz"
HovermapST_X_traj <- "Z:/users/VincyaneBadouard/Lidar/Hovermap/Scans Hovermap ST-X/Hand Scan/gcp_output/STX_third04_traj.xyz"
```

# Import the points cloud
```{r}
ST <- readLAS(HovermapST_X_path)
ST
ST@data

hist(ST@data$Ring) # 15 faisceaux

unique(ST@data$ReturnNumber) # 0 or 1 or 2
unique(ST@data$NumberOfReturns) # 0

min(ST@data$NumberOfReturns) # CONTINU. normalment : echo 1 = 0, echo 2 = 1
table(ST@data$ReturnNumber) # echo 1 = 17049347, echo 2 = 178201 

plot(ST) # trop lourd
```

# Import the trajectory
```{r}
Traj <- fread(HovermapST_X_traj)
Traj 

plot3d(Traj[,.(x, y,z)], aspect=F) # plot the trajectory (x,y,z)
# options(digits=12)
```

# Take only the 1st echo
```{r}
Cloud <- ST@data[ReturnNumber == 0]
```

# Sample only few seconds of the data to work
gpstime in the las and in the traj files is in seconds
The gpstime in the las file is the emission time (same as trajectory time), not the impact time.
```{r}
fstsec <- Cloud$gpstime[1]
# 3 seconds
Cloud <- Cloud[gpstime >= fstsec & gpstime<= fstsec +3]
Traj <- Traj[gpstime >= fstsec & gpstime<= fstsec +3]

plot3d(Traj[,.(x, y,z)], aspect=F) 
```


# Separate data of each ring in different tables
```{r}
# 31 rings
Ring1 <- Cloud[Ring == 1]
Ring1
```

# Compute the unit vectors between sensor position and the acquired point 

## For shots with echo
```{r}
# Remove useless columns
Ring1 <- Ring1[,.(Ring, gpstime, X,Y,Z, Range)]
Traj <- Traj[,.(gpstime, x,y,z)]
```

Emission point: A
Acquired points coordinates : B
-> Compute the direction vector (AB) between the emission and the acquired point.

```{r}
# Acquired points coordinates (B)
Xb <- Ring1$X
Yb <- Ring1$Y
Zb <- Ring1$Z

# Interpolate coordinates of the emission point (A) (in the traj) from coordinates before and after (= barycentric interpolation)
Xa <- approx(x = Traj$gpstime, y = Traj$x , xout = Ring1$gpstime)$y # x : temps de la traj, xout : temps du cloud, $y pour avoir les coordonées x et non les temps
Ya <- approx(Traj$gpstime, y = Traj$y , Ring1$gpstime)$y
Za <- approx(Traj$gpstime, y = Traj$z , Ring1$gpstime)$y

# Compute the coordinates of the AB vector between the emission and the acquired point
vector_coord <- data.frame(x_dir = Xb-Xa,
                           y_dir = Yb-Ya,
                           z_dir = Zb-Za) # coordinates

# Compute the norm of the direction vector (AB)
vector_coord$Distance <- sqrt(
  (vector_coord$x_dir)^2 + (vector_coord$y_dir)^2 + (vector_coord$z_dir)^2
) 
# Transform in direction vector of norm = 1
vector_coord$x_dir <- vector_coord$x_dir / vector_coord$Distance
vector_coord$y_dir <- vector_coord$y_dir / vector_coord$Distance
vector_coord$z_dir <- vector_coord$z_dir / vector_coord$Distance

# Add A (emission) coordinates in the table
vector_coord$X0 <- Xa
vector_coord$Y0 <- Ya
vector_coord$Z0 <- Za

# and associated time 
vector_coord$gpstime <- Ring1$gpstime
```

### Plot vectors
```{r}
# vect_matrix <- vector_coord %>% 

plot3d(Traj[,.(x, y,z)], aspect=F) # plot the trajectory (x,y,z)

subset <- seq(1, nrow(vector_coord), by=200) # each 200 pulses

# Direction vectors
png("D:/Mes Donnees/PhD/Figures/Directions_vectors.png", width = 900, height = 800)
arrows3D(
  x0 = vector_coord$X0[subset],
  y0 = vector_coord$Y0[subset],
  z0 = vector_coord$Z0[subset],
  
  x1 = (vector_coord$X0[subset] + vector_coord$x_dir[subset]),
  y1 = (vector_coord$Y0[subset] + vector_coord$y_dir[subset]),
  z1 = (vector_coord$Z0[subset] + vector_coord$z_dir[subset]), col = "grey", bty = "g", pch = 20, cex = 1, ticktype = "detailed") # cex : text size

points3D(x = vector_coord$X0[subset], # emission points
         y = vector_coord$Y0[subset],
         z = vector_coord$Z0[subset], col = "red", add=T)

points3D(x = (vector_coord$X0[subset] + vector_coord$x_dir[subset]), # collected points
         y = (vector_coord$Y0[subset] + vector_coord$y_dir[subset]),
         z = (vector_coord$Z0[subset] + vector_coord$z_dir[subset]),
         colvar = vector_coord$gpstime[subset], add=T)

scatter3D(Traj$x, Traj$y, Traj$z, colvar = NULL, add=T) 
dev.off()

# Initial vectors
png("D:/Mes Donnees/PhD/Figures/Initial_vectors.png", width = 900, height = 800)
arrows3D(
  x0 = vector_coord$X0[subset], y0 = vector_coord$Y0[subset], z0 = vector_coord$Z0[subset],
  x1 = Xb[subset], y1 = Yb[subset], z1 = Zb[subset],
  col="grey", bty = "g", pch = 20, cex = 1, ticktype = "detailed")

points3D(x = vector_coord$X0[subset], # emission points
         y = vector_coord$Y0[subset],
         z = vector_coord$Z0[subset], col = "red", add=T)

points3D(x = Xb[subset], y = Yb[subset], z = Zb[subset], # collected points
         colvar = vector_coord$gpstime[subset], add=T)


scatter3D(Traj$x, Traj$y, Traj$z, colvar = NULL,  bty = "g",
          pch = 20, cex = 1, ticktype = "detailed", add=T) 
dev.off()
```

## For shots without echo
```{r}
# Find the temporal gaps in the regular time step
unique(as.integer(Ring1$gpstime)) # seems to be not a lots of time value
Ring1$gpstime[1]==Ring1$gpstime[2] # but in real it's not the same time values

plot(Traj$gpstime) # lots of values

hist(diff(Ring1$gpstime)) # 2 digits
options(digits=22) # to see all the digits

# Compute time step
diff_time <- diff(Ring1$gpstime)
diff_time # 0.00005 seems to be the most regular value
dt_mean <- mean(diff_time[diff_time < 0.00006]) # pas de temps de référence (dt) (moyenne des réguliers)
gaps <- diff_time[diff_time > 0.00006] # ceux qui ne sont pas réguliers
gaps
ngaps <- round(gaps/dt_mean) # nombre de shots sans écho qui on pu se faire entre ceux avec écho
ngaps

index<-which(diff_time > 0.00006) # indice des shots pas réguliers

all(Ring1$gpstime[index+1]-Ring1$gpstime[index] == gaps) # vérifier que le temps de gaps correspond au temps entre  entre 2 shots à écho

# Calculer les gps time manqués :
# chaque index a un ngaps
# Ring1$gpstime[index] + seq(ngaps) * dt_mean # temps de chaque tir manqué par index

# Arrété la
gpstime_gaps <- unlist(sapply(seq(ngaps), function(i)
   # temps de chaque tir manqué
  Ring1$gpstime[index][i] + seq(ngaps[i]) * dt_mean # chaque index a un ngap
))

length(gpstime_gaps) == sum(ngaps) # check qu'il y a autant de temps gps que de tirs sans écho
```


```{r}
Xa <- approx(Traj$gpstime, y = Traj$x , gpstime_gaps)$y # x : temps de la traj, # xout : temps gps
Ya <- approx(Traj$gpstime, y = Traj$y , gpstime_gaps)$y
Za <- approx(Traj$gpstime, y = Traj$z , gpstime_gaps)$y

x_dir <- approx(vector_coord$gpstime, y = vector_coord$x_dir, gpstime_gaps)$y # x : temps de la traj, # xout : temps gps
y_dir <- approx(vector_coord$gpstime, y = vector_coord$y_dir, gpstime_gaps)$y
z_dir <- approx(vector_coord$gpstime, y = vector_coord$z_dir, gpstime_gaps)$y


# Compute the unit vector between the emission and the acquired point
gaps_vector_coord <- data.frame(x_dir = x_dir,
                                y_dir = y_dir,
                                z_dir = z_dir,
                                Distance = 100,# m
                                gpstime = gpstime_gaps) # coordinates

gaps_dir_norm <-sqrt(gaps_vector_coord$x_dir^2 + gaps_vector_coord$y_dir^2 + gaps_vector_coord$z_dir^2)# n'a pas conservé ma norme =1

gaps_vector_coord$x_dir <- gaps_vector_coord$x_dir / gaps_dir_norm
gaps_vector_coord$y_dir <- gaps_vector_coord$y_dir / gaps_dir_norm
gaps_vector_coord$z_dir <- gaps_vector_coord$z_dir / gaps_dir_norm

gaps_vector_coord$X0 <- Xa
gaps_vector_coord$Y0 <- Ya
gaps_vector_coord$Z0 <- Za

```
faire pour tous les rings et pour tous les temps
Recalculer x,y,zb : à partir de x,y,zo : xb = x0 + xdir * distance
pour vérifier qu'on est bon

```{r}
check_B <- data.frame(XB = vector_coord$X0 + vector_coord$x_dir * vector_coord$Distance,
                      YB = vector_coord$Y0 + vector_coord$y_dir * vector_coord$Distance,
                      ZB = vector_coord$Z0 + vector_coord$z_dir * vector_coord$Distance)

check_B$XB - Ring1$X
check_B$YB - Ring1$Y
check_B$ZB - Ring1$Z

```


# Test our calcul
To check if our calcul works, we can remove a part of known data and check if we retrieve it.
We can remove:
- randomly 10% of known data
- a continuous part of known data
We can also quantified the error at 100 m : avec le vecteur directeur on projette les points à 100m (distance)
après je vire les 10%  (on fait des faux sans écho)
après on essaye de les retouver les tirs sans écho (on compare le Xb Initial à 100m et celui estimé à 100m)

If we retreive the removed points means that the sensor rotation speed is stable.

## Remove randomly 10% of known data
```{r}
Test_10Cloud <- copy(Cloud)
Test_10Cloud[sample(nrow(Test_10Cloud), 0.1 * nrow(Test_10Cloud)), c("X", "Y", "Z") := NA_real_]
```

## Remove a continuous part of known data
```{r}
Test_contCloud <- copy(Cloud)

# gpstime>1660049400 & gpstime<1660049401
Test_contCloud[100:200, c("X", "Y", "Z") := NA_real_] # 100 points
```

## Check if we retrieve initial data
```{r}

```


## Quantified the error at 100 m
```{r}

```


## Remove a continuous part of known data

## Check if we retrieve initial data

## Quantified the error at 100 m
