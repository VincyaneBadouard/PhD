---
title: "Get LiDAR spatial geometry"
author: "Vincyane Badouard"
date: "`r Sys.Date()`"
output: pdf_document
---

# Packages
```{r, include = F}
library(data.table)
library(lidR)
# library(zoo) # permet de synchroniser temps gps et tirs
library(rgl) # visulaisation 3D
library(interp)
```

# The point cloud and trajectory paths 
```{r}
Hovermap_path <- "Z:/users/VincyaneBadouard/20220908ST0412Scan/Output/st0142target_09_Output_gcp_global_laz1_4.laz"

Hovermap_traj <- "Z:/users/VincyaneBadouard/20220908ST0412Scan/Output/st0142target_09_Output_gcp_global_traj.xyz"
```

# Import the points cloud
```{r}
ST <- readLAS(Hovermap_path)
ST
ST@data

hist(ST@data$Ring) # 15 faisceaux

unique(ST@data$ReturnNumber) # 0 or 1
unique(ST@data$NumberOfReturns) # 0

min(ST@data$NumberOfReturns) # CONTINU. normalment : echo 1 = 0, echo 2 = 1
table(ST@data$ReturnNumber) # echo 1 = 17049347, echo 2 = 178201 

# plot(ST@data) # trop lourd
```

# Import the trajectory
```{r}
Traj <- fread(Hovermap_traj)
Traj 

plot3d(Traj[,.(x, y,z)], aspect=F) # plot the trajectory (x,y,z)
plot(Traj$gpstime)
# options(digits=12)
```

# Take only the 1st echo
```{r}
Cloud <- ST@data[ReturnNumber == 0]
```

# Sample only few seconds of the data to work
gpstime in the las and in the traj files is in seconds
The gpstime in the las file is the emission time (same as trajectory time), not the impact time.
```{r}
# 3 seconds
Traj <- Traj[gpstime>= 1660049400 & gpstime<= 1660049403]
Cloud <- Cloud[gpstime>= 1660049400 & gpstime<= 1660049403]

plot3d(Traj[,.(x, y,z)], aspect=F) # question : pq je n'arrive pas à l'afficher
# plot(Cloud) # ça semble tjrs trop lourd
```


# Separate data of each ring in different tables
```{r}
# 15 rings
Ring1 <- Cloud[Ring == 1]
```

# Compute the unit vectors between sensor position and the acquired point 

## For shots with echo
```{r}
# Remove useless columns
Ring1 <- Ring1[,.(Ring, gpstime, X,Y,Z, Range)]
Traj <- Traj[,.(gpstime, x,y,z)]
```

Question : les temps gps du laz sont les memes que les temps de la traj donc il n'en manque apriori pas et à la même seconde il se déplace
donc pour un meme temps il y a plusieurs points colectés pour un meme faisceau

Question : c'est interp() du package interp qu'il faut prendre (il faut spatialiser les données) utiliser aprox()
```{r}
# Take a first acquired point B
Ring1

# its gpstime
Tb <- Ring1$gpstime

#its coordinates
Xb <- Ring1$X
Yb <- Ring1$Y
Zb <- Ring1$Z

# Interpolate coordinates of the emission point (A) from coordinates before and after (=barycentric interpolation)
Xa <- approx(Traj$gpstime, y = Traj$x , Ring1$gpstime)$y # x : temps de la traj, # xout : temps gps
Ya <- approx(Traj$gpstime, y = Traj$y , Ring1$gpstime)$y
Za <- approx(Traj$gpstime, y = Traj$z , Ring1$gpstime)$y

# Compute the unit vector between the emission and the acquired point
vector_coord <- data.frame(x_dir = Xb-Xa,
                           y_dir = Yb-Ya,
                           z_dir = Zb-Za) # coordinates
vector_coord$Distance <- sqrt(
  (vector_coord$x)^2 + (vector_coord$y)^2 + (vector_coord$z)^2
  ) # norm

vector_coord$x_dir <- vector_coord$x_dir / vector_coord$Distance
vector_coord$y_dir <- vector_coord$y_dir / vector_coord$Distance
vector_coord$z_dir <- vector_coord$z_dir / vector_coord$Distance

vector_coord$X0 <- Xa
vector_coord$Y0 <- Ya
vector_coord$Z0 <- Za

vector_coord$gpstime <- Ring1$gpstime
```
A FAIRE : ploter les vecteurs 1 sur 10 
couleur en fct de temps
## For shots without echo
Question : ya pas de trous dans le temps
```{r}
# Find the temporal gaps in the regular time step
unique(as.integer(Ring1$gpstime))
Ring1$gpstime[1]==Ring1$gpstime[2]

unique(as.integer(Traj$gpstime))

hist(diff(Ring1$gpstime)) # 2 dixits
options(digits=22)

diff_time <- diff(Ring1$gpstime)
dt_mean <- mean(diff_time[diff_time < 0.00006]) # pas de temps de référence (dt)
gaps <- diff_time[diff_time > 0.00006]
ngaps <- round(gaps/dt_mean)

index<-which(diff_time > 0.00006)

all(Ring1$gpstime[index+1]-Ring1$gpstime[index] == gaps)

# créer une table à rmeplir avec les gps time manqué : chaque index a un ngaps
# Ring1$gpstime[index] + seq(ngaps) * dt_mean # temps de chaque tir manqué par index

gpstime_gaps <- unlist(sapply(seq(ngaps), function(i) Ring1$gpstime[index][i] + seq(ngaps[i]) * dt_mean))

length(gpstime_gaps) == sum(ngaps)
```
```{r}
Xa <- approx(Traj$gpstime, y = Traj$x , gpstime_gaps)$y # x : temps de la traj, # xout : temps gps
Ya <- approx(Traj$gpstime, y = Traj$y , gpstime_gaps)$y
Za <- approx(Traj$gpstime, y = Traj$z , gpstime_gaps)$y

x_dir <- approx(vector_coord$gpstime, y = vector_coord$x_dir, gpstime_gaps)$y # x : temps de la traj, # xout : temps gps
y_dir <- approx(vector_coord$gpstime, y = vector_coord$y_dir, gpstime_gaps)$y
z_dir <- approx(vector_coord$gpstime, y = vector_coord$z_dir, gpstime_gaps)$y


# Compute the unit vector between the emission and the acquired point
gaps_vector_coord <- data.frame(x_dir = x_dir,
                           y_dir = y_dir,
                           z_dir = z_dir,
                           Distance = 100,# m
                           gpstime = gpstime_gaps) # coordinates

gaps_dir_norm <-sqrt(gaps_vector_coord$x_dir^2 + gaps_vector_coord$y_dir^2 + gaps_vector_coord$z_dir^2)# n'a pas conservé ma norme =1

gaps_vector_coord$x_dir <- gaps_vector_coord$x_dir / gaps_dir_norm
gaps_vector_coord$y_dir <- gaps_vector_coord$y_dir / gaps_dir_norm
gaps_vector_coord$z_dir <- gaps_vector_coord$z_dir / gaps_dir_norm

gaps_vector_coord$X0 <- Xa
gaps_vector_coord$Y0 <- Ya
gaps_vector_coord$Z0 <- Za

```
faire pour tous les rings et pour tous les temps
Recalculer x,y,zb : à partir de x,y,zo : xb = x0 + xdir * distance
pour vérifier qu'on est bon

```{r}
check_B <- data.frame(XB = vector_coord$X0 + vector_coord$x_dir * vector_coord$Distance,
                      YB = vector_coord$Y0 + vector_coord$y_dir * vector_coord$Distance,
                      ZB = vector_coord$Z0 + vector_coord$z_dir * vector_coord$Distance)

check_B$XB - Ring1$X
check_B$YB - Ring1$Y
check_B$ZB - Ring1$Z

```


# Test our calcul
To check if our calcul works, we can remove a part of known data and check if we retrieve it.
We can remove:
- randomly 10% of known data
- a continuous part of known data
We can also quantified the error at 100 m : avec le vecteur directeur on projette les points à 100m (distance)
après je vire les 10%  (on fait des faux sans écho)
après on essaye de les retouver les tirs sans écho (on compare le Xb Initial à 100m et celui estimé à 100m)

If we retreive the removed points means that the sensor rotation speed is stable.

## Remove randomly 10% of known data
```{r}
Test_10Cloud <- copy(Cloud)
Test_10Cloud[sample(nrow(Test_10Cloud), 0.1 * nrow(Test_10Cloud)), c("X", "Y", "Z") := NA_real_]
```

## Remove a continuous part of known data
```{r}
Test_contCloud <- copy(Cloud)

# gpstime>1660049400 & gpstime<1660049401
Test_contCloud[100:200, c("X", "Y", "Z") := NA_real_] # 100 points
```

## Check if we retrieve initial data
```{r}

```


## Quantified the error at 100 m
```{r}

```


## Remove a continuous part of known data

## Check if we retrieve initial data

## Quantified the error at 100 m
