---
title: "Work_with_AMAPvox"
author: "Vincyane Badouard"
date: "`r Sys.Date()`"
output: pdf_document
---

https://amapvox.org/

# Install AMAPVox
```{r}
# install "remotes" package if not already installed
if (!any(grepl("remotes", rownames(installed.packages())))) install.packages("remotes")
# install latest stable version from source
remotes::install_github('umr-amap/AMAPVox')
```

# Packages
```{r, include = F}
library(tidyverse)
library(zoo) # permet de synchroniser temps gps et tirs
library(lidR)
library(data.table)
library(rgl) # visulaisation 3D
library(terra)
library(AMAPVox)
library(sf)
```

# The point cloud 

# données classifiées dallées
```{r}
ctg <- readLAScatalog(folder= "D:/Mes Donnees/PhD/Lidar", filter=keep) # las catalog
crs(ctg)
plot(ctg)
ctg <- st_set_crs(ctg, 2972) # attribuer le dernier crs
crs(ctg)
roi <- vect("Z:/users/VincyaneBadouard/ALS2022/Parcelles_Understory.shp")
roi <- st_as_sf(roi) # as sf object
roi <- st_set_crs(roi, 2972) # attribuer le dernier crs
crs(roi)
plot(roi)
PC <- clip_roi(las = ctg, roi) # trop long

truc <- rbind(PC[[1]], PC[[2]], PC[[3]], PC[[4]])
plot(truc)
table(truc@data$Classification)
truc@data <- truc@data[Classification != 7,]

writeLAS(truc, "Z:/users/VincyaneBadouard/ALS2022/P16_2022_v2_4ha.laz")
```


```{r}
ALS_P16_2022_path <- "Z:/users/VincyaneBadouard/ALS2022/P16_2022_dnz_4ha.laz"
```

# Import the points cloud
```{r}
ST <- readLAS(ALS_P16_2022_path)
hist(ST@data$Intensity)
# hist(ST@data$Ring) # YA PAS 
hist(ST@data$NumberOfReturns) # CONTINU. normalment : echo 1 = 0, echo 2 = 1
table(ST@data$ReturnNumber) # echo 1 = 17049347, echo 2 = 178201 
ST@data
range(ST$Z) # min et max de l'altitude

plot(ST) 
```


# Read, bind and rewrite the trajectory files in the folder
```{r , include = F}
trajfilenames <- list.files("Z:/users/VincyaneBadouard/ALS2022/trajecto", pattern="*.txt", full.names=TRUE) # catch the name of all the files of the folder

df_list <- lapply(trajfilenames, fread) # read all the folder files
ALS_P16_2022_traj <- bind_rows(df_list)

ALS_P16_2022_traj <- ALS_P16_2022_traj %>% 
  select(V1,V2,V3,V4) %>% 
  rename(time = V1) %>% 
  rename(X = V2) %>% 
  rename(Y = V3) %>% 
  rename(Z = V4) 
view(ALS_P16_2022_traj)

fwrite(ALS_P16_2022_traj, "Z:/users/VincyaneBadouard/ALS2022/trajecto/ALS_P16_2022_traj.txt")
```

# Import the trajectory
```{r}
traj <- ALS_P16_2022_traj
traj 

plot3d(traj[,2:4], aspect=F) # plot the trajectory (x,y,z)

options(digits=12)
```


# Netoyer les points isolés avant AMAPVox
- statistical points removal (enlève les points isolés)
- autre méthode : dans un espace voxel selon densité de points
```{r}

```

```{r}
ST <- truc
# Modèle numérique de terrain
mnt <- rast("Z:/users/VincyaneBadouard/ALS2022/mnt_roi36ha_1m.asc")
plot(mnt)

# Normaliser la hauteur du sol
ST_norm <- lidR::normalize_height(ST, mnt) # applati le relief
plot(ST_norm)# sol plat
hist(ST_norm@data$Z)

# Classifier les points
ST_norm@data[(Z>(-0.2) & Z< 0.5), Classification := 2] 

table(ST_norm@data$Classification) # 7 = bruit, 2 = sol, vegetation = 3,4,5
# plot(ST_norm, color = "Classification") # trop long

# Dénormaliser la hauteur du sol
ST <- lidR::unnormalize_height(ST_norm) 

```

# Garder uniquement les points de végétation
On enlève tout le sol, on garde que les tirs qui atteignent la végétation
```{r}
# Prendre que ce qui concerne la végétation
GP=ST@data[(Classification==2|Classification==7),] # Ground Points
GS=ST@data[gpstime %in% GP$gpstime,] # temps gps des tirs dont l'echo est au sol
VP=ST@data[!(gpstime %in% GP$gpstime),] # données aux temps gps uniquement des tirs qui n'ont pas touché le sol
# question : pq enlever tous les tirs pris en meme temps que les tirs ayant touché le sol, et pas juste enlever les données sol ?
rm(GP)
rm(GS)
```

Calculer la moyenne de réflectance (appelée intensité) par écho
```{r}
# Compute Intensity
VP$initial_intensity <- VP$Intensity 

VP$Intensity = 10^(VP$Reflectance/10) # On utilise la réflectance pour calculer l'intensité en calculant la réflectance apparente en ratio (albedo) = intensité qu'on va utiliser par la suite
# réflectance initialment en decibel (et selon une référence connue)

VP_samp <- sample(1:dim(VP)[1], 2000) # just a sample to plot

plot(initial_intensity~Intensity, data = VP[VP_samp,])

```

# Calculer la matrice de poids
```{r}
# Compute average intensity per Number Of Returns x Return Number
# get max return number (variable!)

mx_rn=max(VP[,ReturnNumber]) # nbr max de retours

# VP$ReturnNumber=as.factor(VP$ReturnNumber)
# VP$NumberOfReturns=as.factor(VP$NumberOfReturns)
#mod1=lm(Intensity~NumberOfReturns:ReturnNumber, data=VP)
#mean1=allEffects(mod1)
#mat1=matrix((mean1[[1]]$fit),nrow=mx_rn, ncol=mx_rn)

mat1 <- matrix(data=NA, nrow=mx_rn, ncol=mx_rn) # matrice vide

#fill in mean intensities
for (i in 1:mx_rn){
  for (j in 1:i)
  {
    mat1[i,j] <- (mean(VP[NumberOfReturns==i & ReturnNumber==j,Intensity],
                     na.rm=T)) # moy des intensités retours par rang d'écho
  }
}

mat_rel1 <- mat1/rowSums (mat1, na.rm = T, dims = 1) # poids relatifs à chacun des échos tous tirs confondus     
# il faut une matrice carré !!

# single=list(name=m, matrix=mat_rel1)
# len <- length(mat_list)
# mat_list[[len+1]] <- single


# Enregistrer cette matrice dans le dossier de travail
fwrite(mat_rel1, "Z:/users/VincyaneBadouard/ALS2022/WeightingMatrix.txt",
       sep= " ", na="NaN", row.names = F, col.names = F)
```

# AMAPVox
extraction de la zone d'intéret plus grande que la zone d'étude
rotationer le nuage de points pour etre aligné avec la grille

pour calculer la matrice VOP on enlève les points sol

```{r}
remotes::install_github('umr-amap/AMAPVox')

# ça marche pas
AMAPVox::run()
AMAPVox::getRemoteVersions()
AMAPVox::installVersion("1.10.4")
AMAPVox::run("1.10.4", check.update = FALSE)
```

PAD = 2*attenuation

fct d'atténuation selon un modèle sphérique (orientation aléatoire des feuilles)

```{r}
VX <- readVoxelSpace("Z:/users/VincyaneBadouard/ALS2022/AMAVox_output_test")
AMAPVox::plot(VX)
VX@data$PadBVtotal <- VX@data$attenuation_FPL_biasedMLE # pas corrigé le sous-échantillonage (pour bosser sur les voxels vides)

writeVoxelSpace(VX, "Z:/users/VincyaneBadouard/ALS2022/AMAVox_output_PAD")

```

## Fill empty voxels
voxel pas vu pas échantilloné (occlusion), pas de données, ou mal échantilloné (selon un seuil)
estimer selon le plus probable selon les besoins
qui ne sont pas des trouées, mais des voxels perdus dans le nuage végétal
(long)
```{r}

```

## Generate light maps from a voxel space
```{r}
```

