---
title: "Work_with_AMAPvox"
author: "Vincyane Badouard"
date: "`r Sys.Date()`"
output: pdf_document
---

https://amapvox.org/

Le principe est d’utiliser le LiDAR pour reconstruire en 3D la canopée forestière en représentant au mieux les caractéristiques de transmittance locale de la végétation puis de simuler à partir de cette maquette et d’un modèle d’ensoleillement la quantité relative de lumière disponible en tout point de la canopée.


# Install AMAPVox
V2.2 : //amap-data.cirad.fr/work\users\PhilippeVerley\amapvox\nightly-build\AMAPVox-2.2.0-windows
```{r}
# install "remotes" package if not already installed
if (!any(grepl("remotes", rownames(installed.packages())))) install.packages("remotes")
# install latest stable version from source
remotes::install_github('umr-amap/AMAPVox')
```

# Packages
```{r Setup, include = F}
library(tidyverse)
library(lidR)
library(data.table)
library(rgl) # visulaisation 3D
library(terra)
library(raster)
library(lidR)
library(tidyterra)
library(sf)
library(corrplot)
library(RColorBrewer)
```
# Paths
```{r}
local <- "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/"

folders <- 
  # "P16_C14C15/Processed/"
  "P16_C19C20/Processed/"

file <-
  # "UAV_C14C15"
  "UAV_C19C20"
```

# Load points cloud
ctg : catalog of laz files
```{r}
# Si en dalles :
# ST <- readLAScatalog(folder = "D:/Mes Donnees/PhD/Lidar", filter = "keep") # las catalog. filter only 1st returns

# Si 1 fichier
# ST <- readLAS(paste(local,"P16_C14C15/Decimated/Processed/Subsampled_Returns_and_gpstime_corrected_lastoolsclassif.laz", sep="") # décimé
ST <- readLAS(
  "//amap-data.cirad.fr/work/users/VincyaneBadouard/DZ_test/LAZ/DZ_buff_2023_HAF_RefAsInt_New.laz"
  # paste(local,folders, "Returns_and_gpstime_corrected_lastoolsclassif.laz", sep=""))
# UAV_C19C20_retranslated_lastoolsclassif
# "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/Processed/UAV_C14C15_retranslated_lastoolsclassif.laz"
# "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/HighAltitudeFlight/Raw_laz/HighFlight_alt4ha_buff100m_2023_RefAsInt_New.laz"
# "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/LowAltitudeFlight/Raw_laz/LowFlight_alt4ha_buff100m_2023_RefAsInt_New.laz"
# ST <- readLAS("//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/HighAltitudeFlight/LAZ/P16_2023_4ha_HighAlt_buffer_intensitycor.laz")
)
hist(ST$Intensity, breaks=1000)
crs(ST) # no crs
ST <- st_set_crs(ST, 2972) # attribuer le dernier crs
lidR::crs(ST)

# plot(ST)
```

# Extraire la zone d'intéret dont buffer (données classifiées dallées)
Ne garder que la zone d'intéret dans le nuage de point, en le clipant sur un fichier vecteur (polygone) de la zone d'intéret (ROI), si possible sous forme rectangulaire stricte.

ROI : Region of Interest
```{r, create ROI}
# Region of Interest (ROI)
ROI <- vect("//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2022/Plot16_4ha_buffer100m.shp") # interest zone + 100m buffer
plot(ROI)
class(ROI) # SpatVector (terra)

ROI <- st_as_sf(ROI) # as sf object
ROI <- st_set_crs(ROI, 2972) # attribuer le dernier crs

# plot(PC@data, )
# plot(ROI, add=T)
```

# Clip the point cloud in region of interest
```{r, crop laz}
PC <- lidR::clip_roi(las = ST, geometry = ROI) # très long
ST;PC
```

```{r}
rm(ST);gc()
```

# pas toujours nécessaire
```{r, crop laz}
plot(PC)

## For 1 file
str(PC) # List of 4 las

# Join the 4 las if there are different of each others
# usethis::edit_r_environ()
PCall <- rbind(PC[[1]], PC[[2]], PC[[3]], PC[[4]])

# or if only the first is not empty
PC <- PC[[1]]
# lidR::plot(PC)
```

# Enlever le bruit (sous sol et au dessus canopée) et reclassifier si besoin
```{r}
# PC <- ST; rm(ST)
table(PC@data$Classification) # 7 = bruit, 2 = sol, veg = 3,4,5, non-classified = 1
PC@data <- PC@data[Classification != 7,]
# plot(PC)
```

# Crop the DEM in region of interest
```{r, crop DEM}
ROI <- vect("//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2022/Plot16_4ha_buffer101m.shp") # buffer plus grand pour éviter les effets de bords lors de la voxélisation
# ROI <- vect("//amap-data.cirad.fr/work/users/VincyaneBadouard/DZ_test/Shp/DZ_buffer.shp") # DZ + buffer
ROI <- st_as_sf(ROI) # as sf object
ROI <- st_set_crs(ROI, 2972) # crs

# Modèle numérique de terrain
# //amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2022/mnt_roi36ha_1m.asc""
# mnt <- rast(paste("//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/P16_C14C15/Decimated/Processed/Subsampled_Returns_and_gpstime_corrected_DEM.tif", sep = "")) # decimated
mnt <- rast(
  # paste(local,folders,"Returns_and_gpstime_corrected_DEM.tif", sep = "")
"//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/HighAltitudeFlight/MNT/PARACOU2023_DTM_1m.tif"
# "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/lowAltitudeFlight/dtm2023.asc"
)

ggplot() + 
  geom_spatraster(data = mnt, aes(fill = Z)) + # mnt_roi36ha_1m # dtm2023 ; MNT_0.5m_IRD_500m_Paracou_284000_579500
  scale_fill_gradientn(name = "Elevation (m)",
                       colors = terrain.colors(30, rev=T),
                       na.value="white") +
  theme_classic() +
  geom_sf(data = sf::st_cast(ROI, "LINESTRING"))

crs(mnt) <- crs(ROI) 
mntROI <- raster::mask(mnt,ROI)
mntROI <- raster::crop(mntROI,ROI)
mntROI;ROI
# plot(mntROI)
ggplot() + 
  geom_spatraster(data = mntROI, aes(fill = Z)) + # mnt_roi36ha_1m # dtm2023 ; MNT_0.5m_IRD_500m_Paracou_284000_579500
  scale_fill_gradientn(name = "Elevation (m)",
                       colors = terrain.colors(30, rev=T),
                       na.value="white") +
  theme_classic() +
  geom_sf(data = sf::st_cast(ROI, "LINESTRING"))

ggsave(paste(file, "_DEM_1m_crop.png", sep = "" ), path = "D:/Mes Donnees/PhD/Figures/lidar/UAV", width = 25, height = 15, units = "cm", dpi=800, bg="white")

writeRaster(raster(mntROI),
            paste(local,"AMAPVox/MNT/dtm2023_4ha_",file,"_buffer.asc", sep = ""),
            format="ascii", overwrite=T) # decimated

# writeRaster(raster(mntROI),
# # "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/HighAltitudeFlight/MNT/dtm2023_4ha_HighAlt_buffer.asc"
# # "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/lowAltitudeFlight/dtm2023_4ha_buffer.asc"
# # "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2022/dtm2022_4ha_buffer.asc"
# # "//amap-data.cirad.fr/work/users/VincyaneBadouard/DZ_test/MNT/dtm2023_HighAlt_DZ_buffer.asc",
#             format="ascii", overwrite=T)
```

# Read, bind and rewrite the trajectory files in the folder
```{r , include = F}
# if multiple files :
trajfilenames <- list.files("//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2022/trajecto", pattern="*.txt", full.names=TRUE) # catch the name of all the files of the folder
df_list <- lapply(trajfilenames, fread) # read all the folder files
traj <- bind_rows(df_list)

# if one file :
path <- "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/trajecto/trajecto1000m.txt"
# "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2022/trajectory.txt"
# "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/trajecto/trajecto500m.txt"
traj <- fread(path)
traj
plot3d(traj[,2:4], aspect=F) # plot the trajectory (x,y,z)
range(traj$x) # 283900.7434999999823049 317113.9602999999769963
range(traj$y) #  560039.9923999999882653 588274.3286999999545515

traj <- traj %>% 
  select(V1,V2,V3,V4) %>% 
  rename(time = V1) %>% 
  rename(X = V2) %>% 
  rename(Y = V3) %>% 
  rename(Z = V4) 
view(traj)

# Crop trajectory
options(digits=22)
range(traj$t) # 382365103.0212569832802 382378020.8453729748726
range(PC@data$gpstime) # 382366761.4412953257561 382376006.5801081061363
traj <- traj[t<=max(PC@data$gpstime) & t>=min(PC@data$gpstime),]

# Keep only points inside the polygon (faut pas faire ça)
# traj_sf <- st_as_sf(traj, coords = c("X","Y"))
# traj_sf <- st_set_crs(traj_sf, 2972)
# traj_crop <- sf::st_intersection(traj_sf, ROI)
# XY <- st_coordinates(traj_crop)
# st_geometry(traj_crop) <- NULL # no more sf object
# traj_crop <- cbind(traj_crop, XY) # bind XY coord
# setDT(setcolorder(traj_crop, c("time","X", "Y", "Z"))) # order col places
# traj_crop <- traj_crop[, c(1:7), with = FALSE]

# fwrite(traj_crop, "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2022/traj_crop.txt")

fwrite(traj, "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/HighAltitudeFlight/ALS_P16_2023_4ha_HighAlt_buffer_traj.txt")
# "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2022/ALS_P16_2022_4ha_buffer_traj.txt"
# "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/trajecto/ALS_P16_2023_traj.txt"
```

# Check points cloud data
```{r}

table(PC@data$NumberOfReturns) # 14 echos ALS 2023 LowAlt; 12 HighAlt ; UAV : 4
PC@data
range(PC$Z) # min et max de l'altitude: 4.19 65.74 m

plot(PC) 
```

# Classifier les points sol
```{r}
# Normaliser la hauteur du sol
PC_norm <- lidR::normalize_height(PC, mntROI) # applati le relief
# plot(PC_norm) # sol plat
hist(PC_norm@data$Z)

# Classifier les points sol
PC_norm@data[(Z>(-0.2) & Z< 0.5), Classification := 2] 

table(PC_norm@data$Classification) # 7 = bruit, 2 = sol, vegetation = 0,3,4,5
# plot(PC_norm, color = "Classification") # trop long

# Dénormaliser la hauteur du sol
PC <- lidR::unnormalize_height(PC_norm) 
```

# Garder uniquement les points de végétation (pas nécessaire avant amapvox)
On enlève tout le sol, on garde que les tirs qui atteignent la végétation
```{r}
# GP <- PC@data[(Classification==2 | Classification==7),] # Ground Points
# GS <- PC@data[gpstime %in% GP$gpstime,] # temps gps des tirs dont l'echo est au sol
# VP <- PC@data[!(gpstime %in% GP$gpstime),] # données aux temps gps uniquement des tirs qui n'ont pas touché le sol
# # question : pq enlever tous les tirs pris en meme temps que les tirs ayant touché le sol, et pas juste enlever les données sol ?
# rm(GP)
# rm(GS)
```

# Calculer la réflectance apparente (appelée intensité) par écho (Greg l'a déjà mis dans les laz bruts)

On utilise la réflectance pour calculer l'intensité
en calculant la réflectance apparente en ratio (albedo)
= intensité qu'on va utiliser par la suite.

Réflectance (ou Albedo) = énergie lumineuse réfléchie/énergie lumineuse incidente

```{r}
anyNA(PC@data$Intensity) # 10748 62215
names(PC@data)

# Compute Intensity
PC@data$initial_intensity <- PC@data$Intensity


# Intensité = réflectance apparente en ratio (albedo)
PC@data[, Intensity := as.integer((10^(Reflectance/10))*100)] # Réflectance initialement en decibel (et selon une référence connue)
range(PC@data$Intensity) # 0.9817479 2228435149

PC_samp <- sample(1:dim(PC@data)[1], 2000) # just a sample to plot

# initial_intensity vs Intensity
plot(initial_intensity~Intensity, data = PC@data[PC_samp,])

PC@data$initial_intensity <- NULL
```

# Rectifier les réflectances pour pouvoir prendre en compte les propriétés optiques des matériaux dans le calcul de la transmittance dans AMAPVox
```{r}
# Reclassif que pour UAV
PC@data[, Classification := ifelse(Classification == 1L, 3L, Classification)] # 1 -> 3 veg 
table(PC@data$Classification)
# lidR::plot(PC) 
```

```{r}
# PC <- readLAS("//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/HighAltitudeFlight/P16_2023_4ha_HighAlt_buffer.laz")

means <- PC@data[NumberOfReturns == 1, .(mean=mean(Intensity)), by = Classification] # Reflectance mean by classification (veg, ground)

ratio <- means[Classification==2,]$mean/means[Classification==3,]$mean # ratio sol/veg reflectance 

PC@data <- PC@data %>% 
  mutate(Intensity = ifelse(Classification==2, as.integer(as.numeric(Intensity)/ratio), Intensity)) %>%  # Ground reflectance corrected by the ratio
  mutate(Classification = ifelse(Classification==2, 1L, Classification)) # for AMAPVox to give the soil without know it (?)

table(PC@data$Classification)

writeLAS(PC,
         # paste(local,"AMAPVox/LAZ/P16_2023_",file,"_buffer_intensitycor.laz", sep="")
# "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/AMAPVox/LAZ/P16_2023_UAV_C14C15_buffer_intensitycor.laz"
# "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/LowAltitudeFlight/LAZ/P16_2023_4ha_LowAlt_buffer_intensitycor.laz"
# "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/HighAltitudeFlight/LAZ/P16_2023_4ha_HighAlt_buffer_intensitycor.laz"
# "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2022/P16_2022_4ha_buffer.laz"
"//amap-data.cirad.fr/work/users/VincyaneBadouard/DZ_test/LAZ/HighFlight_DZ_buffer_2023_intensitycor.laz"
)
```

# Calculer la matrice de pondération des échos (matrice de poids) (pas la meilleur méthode)
```{r}
# Compute average intensity per Number Of Returns x Return Number (rang de l'écho)
# get max return number (variable!)

mx_rn=max(VP[,ReturnNumber]) # nbr max de retours

# VP$ReturnNumber=as.factor(VP$ReturnNumber)
# VP$NumberOfReturns=as.factor(VP$NumberOfReturns)
#mod1=lm(Intensity~NumberOfReturns:ReturnNumber, data=VP)
#mean1=allEffects(mod1)
#mat1=matrix((mean1[[1]]$fit),nrow=mx_rn, ncol=mx_rn)

mat1 <- matrix(data=NA, nrow=mx_rn, ncol=mx_rn) # matrice vide

#fill in mean intensities
for (i in 1:mx_rn){
  for (j in 1:i)
  {
    mat1[i,j] <- (mean(VP[NumberOfReturns==i & ReturnNumber==j,Intensity],
                       na.rm=T)) # moy des intensités retours par rang d'écho
  }
}

mat_rel1 <- mat1/rowSums(mat1, na.rm = T, dims = 1) # poids relatifs à chacun des échos tous tirs confondus     
# il faut une matrice carrée (même nbr de lignes et de colonnes) !!

# single=list(name=m, matrix=mat_rel1)
# len <- length(mat_list)
# mat_list[[len+1]] <- single


# Enregistrer cette matrice dans le dossier de travail
fwrite(mat_rel1, "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/WeightingMatrix.txt",
       sep= " ", na="NaN", row.names = F, col.names = F)
```

# Calcul de matrice de rotation (alignement N-S d’un bord de ROI)

Créer une matrice 'VOP'(Voxels Oriented Patches) (.txt).
Rotationer le nuage de points pour etre aligné avec la grille

script : **Create_VOP.Rmd**

# Compute the clearness index from the tower data

Le "clearness" de AMAPVox est bien le clearness de la "littérature" scientifique et est utilisé dans la routine d'AMAPVox pour calculer : 

1/ l'éclairement total (le RG extraterrestre est recalculé à partir de la date, de l'heure et de la geolocalisation)
2/ la répartition rayonnement direct/diffus.

Il faut donc bien reprendre les données de rayonnement incident mesuré à la tour à Flux pour calculer l'évolution saisonnière de clearness index.

Clearness index = rapport entre l'irradiation solaire globale mesurée au niveau du sol G et sa contrepartie estimée au sommet de l'atmosphère Gext : k=G/Gext (Liu and Jordan, 1960).

Clearness index = global solar irradiance (données de la tour)/top of atmosphere (extraterrestrial radiation) (données de ref des satellites (site soda)

all on the same periode, and in the same unit

Method: https://www.fao.org/3/x0490e/x0490e07.htm#solar%20radiation

Définition saison sèche au mois : < 100 mm precipitation par mois (Bonal et al. 2008)
```{r}
# Load tower data
# Rg in MJ m^-2 day^-1 (megajoules per square metre and per day)
# FluxTowerData <- readr::read_delim("~/PhD/Lidar/GX-METEO+EDDY-2004-2022E - JOUR - NEW2023 - GV.csv", 
#                                        delim = ";", escape_double = FALSE, trim_ws = TRUE)

FluxTowerData <- readxl::read_excel("~/PhD/Microclimate/TourAFlux-2023-2024.xlsx", 
                                    sheet = "Gx meteo_2023-2024")
View(FluxTowerData)

names(FluxTowerData) 
# "Year", "Day", "Time"
# Pluie
# - Rg : Global radiation (W m-2)
# - CNR4_SW_up_Avg : Global radiation from CNR4 sensor (W m-2)

# FluxTowerData[FluxTowerData$Rg < (-999),]

FluxTowerData <- FluxTowerData %>% 
  filter(Date >= mdy_hms("04/01/2023 00:00:00") & Date < mdy_hms("03/31/2024 24:00:00")) %>% 
  rename(Rain = Pluie) %>% 
  rename(Rg_W = Rg) %>% 
  group_by(Day) %>%
  mutate(Rg = sum(Rg_W *1800 * 10^(-6))) %>% # Rg (MJ m-2 day-1) = Somme de Rg (W m-2) *1800 * 10^(-6)
  ungroup() %>%
  filter(Rg > 0) %>%
  group_by(Day) %>% 
  mutate(Rain_day = sum(as.numeric(Rain))) %>%  # il faut sommer la pluie par jour pour visualiser les saisons
  ungroup() %>%
  select(Date, Year, Day, Month, Rain, Rain_day, Rg) %>% # 365 days, 12 months
  # mutate(Season = ifelse(Month  %in% c(2,3, 8:11), # mars, aout-nov = dry season
  #                        "Dry", "Wet")) %>%
  group_by(Month) %>%
  mutate(Rain_sum_Month = sum(Rain,na.rm = T)) %>% 
  ungroup() %>%
  mutate(Season = ifelse(Rain_sum_Month < 100,"Dry", "Wet")) %>% # Dry season: < 100 mm precipitation per month (Bonal et al. 2008)
  unique()

ggplot(FluxTowerData, aes(x = as.factor(Month),y = Rain_day)) +
  geom_boxplot(aes(color = Season)) +
  theme_minimal() +
  labs(title="Daily rainfall over the seasons",
       x ="Month", y = "Daily rainfall (mm)")

ggsave("FluxTower_2023_2024_Rainfall_over_the_seasons.png",
       path = "D:/Mes Donnees/PhD/Figures/Macroclimate",
       width = 25, height = 15, units = "cm", dpi=800, bg="white")

ggplot(FluxTowerData, aes(x = as.factor(Month),y = Rain)) +
  geom_bar(aes(x = as.factor(Month),y = Rain, fill = Season), stat="identity") +
  theme_minimal() +
  labs(title="Monthly rainfall over the seasons",
       x ="Month", y = "Sum monthly rainfall (mm)")

ggsave("FluxTower_2023_2024_Monthly_Rainfall_over_the_seasons.png",
       path = "D:/Mes Donnees/PhD/Figures/Macroclimate",
       width = 25, height = 15, units = "cm", dpi=800, bg="white")

# Compute extraterrestrial radiation per day (because unit it's per day)
G <- 0.0820 # solar constant (MJ m-2 min-1)
phi <- 5*(pi/180) # latitude (rad) 5° à Paracou
# J <- # Julian day


FluxTowerData <- FluxTowerData %>%
  mutate(d = 1+0.033*cos(((2*pi)/365)*Day),#inverse relative distance Earth-Sun
         delta = 0.409*sin(((2*pi)/365)*Day-1.39),  # solar decimation (rad)
         omega = acos(-tan(phi)*tan(delta)),         # sunset hour angle (rad) 1.527) 
         Re = ((24*60)/pi)*G*d*(omega*sin(phi)*sin(delta)+cos(phi)*cos(delta)*sin(omega))) # in MJ m^-2 day^-1

# Compute clearness for each day (because unit it's per day)
ClearnessIndex <- FluxTowerData %>% 
  mutate(Clearness_daily = Rg/Re) %>% # daily
  group_by(Month) %>% 
  mutate(Clearness_monthly = mean(Clearness_daily)) %>% # monthly
  ungroup() %>% 
  group_by(Season) %>% 
  mutate(Clearness_seasonly = mean(Clearness_daily)) %>% # seasonly
  ungroup() %>% 
  mutate(Clearness_annual = mean(Clearness_daily)) %>% # annual
  select(Year, Day, Month, Season, Clearness_daily, Clearness_monthly, Clearness_seasonly, Clearness_annual)

# Compute clearness index for 1 year
# mean(FluxTowerData$Clearness) # 2022: 0.46 ; 2023-2024: 0.52
# 
# # Compute clearness index for wet and dry season
# mean(FluxTowerData[FluxTowerData$Season=="Wet",]$Clearness) # 2022: 0.39 ; 2023-2024: 0.47
# mean(FluxTowerData[FluxTowerData$Season=="Dry",]$Clearness) # 2022: 0.55 ; 2023-2024: 0.56
# 
# ClearnessIndex <- data.frame(Clearness_annual = Clearness_annual,
#                              ClearnessWet = ClearnessWet,
#                              ClearnessDry = ClearnessDry)

write.csv(ClearnessIndex, "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/ClearnessIndex_2023_2024.csv")
```


# AMAPVox
```{r}
library(AMAPVox)

# For the 1st time
# AMAPVox::run()
AMAPVox::run(jvm.option = "-Xms16g") # pour allouer 16Go de RAM # 

AMAPVox::run(jvm.option = "-Xms16g", version = "1.10.4")  

# Get the configuration file
xmlfile <- "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2022/P16_2022_4ha_buffer.xml"
# Run with the previous configuration file
AMAPVox::run(xml = xmlfile, jvm.option = "-Xms16g")

```

PAD = 2*attenuation

fct d'atténuation selon un modèle sphérique (orientation aléatoire des feuilles)

pad calculé dans le script de remplissage des voxels vides donc pas besoin de celui-ci

```{r}
VX <- readVoxelSpace("//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/HighAltitudeFlight/P16_2023_HighAlt_4ha_buffer_equalecho2m.vox")
# "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/lowAltitudeFlight/P16_2023_LowAlt_4ha_buffer.vox"
VXdf <- as.data.frame(VX@data) %>% mutate(i=as.numeric(i)) %>% mutate(j=as.numeric(j)) %>% mutate(k=as.numeric(k))
VoxR::plot_voxels(VXdf)
AMAPVox::plot(VX, variable.name = "nbSampling") # fermer la fenetre de plot entre 2 plots
AMAPVox::plot(VX, variable.name = "ground_distance") # ground distance bizarre sur les cotes
VX1 <- VX
VX <- VX1
VX@data <- VX@data[!is.na(distLaser)]
AMAPVox::plot(VX, variable.name = "distLaser")

# 2.5 est la densité max de feuillage qui ait un sens biologique 
VX <- VX1
VX@data <- VX@data[!is.na(attenuation_FPL_biasedMLE) & attenuation_FPL_biasedMLE<2.5]
AMAPVox::plot(VX, variable.name = "attenuation_FPL_biasedMLE")  

VX <- VX1
VX@data <- VX@data[!is.na(attenuation_FPL_unbiasedMLE) & attenuation_FPL_unbiasedMLE<2.5 & attenuation_FPL_unbiasedMLE>0]
AMAPVox::plot(VX, variable.name = "attenuation_FPL_unbiasedMLE")
# FPL : une grande partie des valeurs aberrantes devrait disparaître après recalcul des zones faiblement échantillonnées à l'aide des voisins.

VX <- VX1
VX@data <- VX@data[!is.na(attenuation_PPL_MLE) & attenuation_PPL_MLE<2.5]
AMAPVox::plot(VX, variable.name = "attenuation_PPL_MLE") # ça a l'air mieux il y a une plus forte atténuation proche du sol, mais ça n'a pas l'air très graduel
# PPL : il faudrait préférablement  réduire les PPL de plus de 2.5 - qui correspondent à des valeurs aberrantes) à 2.5 - qui correspond à la densité max de feuillage qui ait un sens biologique et non 20 comme dans le cas présent 

# VX <- VX1
# VXdata <- VX@data
# 
# VX@data$PadBVtotal <- VX@data$attenuation_FPL_biasedMLE # pas corrigé le sous-échantillonage (pour bosser sur les voxels vides)
# 
# writeVoxelSpace(VX, "//amap-data.cirad.fr/work/users/VincyaneBadouard/ALS2023/AMAVox_output_PAD")

```

# Pour UAV, crop vox and remove drone path
```{r}
VX <- readVoxelSpace(
  "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/AMAPVox/Intensity_2m/P16_2023_UAV_4ha_buffer_intensity2m.vox"
  # "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/AMAPVox/Intensity_1m/P16_2023_UAV_4ha_buffer_intensity1m.vox"
)
# View(VX@data)
AMAPVox::plot(VX, variable.name = "ground_distance") 
```

```{r}
# i, j, k = index not coordinates
VX@data[, c("x", "y", "z") := getPosition(VX)[, .(x, y, z)]]
# range(VX@data$x) ; range(VX@data$y)

I <- range(VX@data[x>=(-90) & x<=190 & y<=190,][z<66,i]) # 1m: 61 340 ; 2m: 31 170
J <- range(VX@data[x>=(-90) & x<=190 & y<=190,][z<66,j]) # 1m:  0 340 ; 2m: 0 170
K <- range(VX@data[x>=(-90) & x<=190 & y<=190,][z<66,k]) # 1m:  0 66 ; 2m: 0 33

VX <- crop(VX, imin = I[1], imax = I[2], jmin = J[1], jmax = J[2], kmin = K[1], kmax = K[2]) 

range(VX@data$z)

prod(VX@header$dim) == nrow(VX@data) # doit etre cohérent

AMAPVox::plot(VX, variable.name = "ground_distance") 
AMAPVox::plot(VX, variable.name = "nbSampling") 

VX20 <- VX
VX20@data <- VX20@data[nbSampling < 20,]
AMAPVox::plot(VX20, variable.name = "nbSampling")
```

```{r}
writeVoxelSpace(VX, 
                "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/AMAPVox/Intensity_2m/P16_2023_UAV_4ha_buffer_intensity2m_crop.vox"
                # "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/AMAPVox/Intensity_1m/P16_2023_UAV_4ha_buffer_intensity1m_crop.vox"
)
```


# Fill empty voxels
*voir Fill_empty_voxels.Rmd*

Certains voxels (en bas de canopée) ne sont pas échantillonnés du fait de l’occlusion des tirs LiDAR. Ces données manquantes ont été comblées en appliquant la **moyenne des valeurs de transmittance des 27 voisins les plus proches**.

# For UAV, merge UAV and ALS for a complete buffer
```{r}
library(AMAPVox); library(sf)
VX <- readVoxelSpace(
  "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/AMAPVox/Intensity_2m/P16_2023_UAV_4ha_buffer_PadHLE_intensity2m.vox"
  # "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/AMAPVox/Intensity_1m/P16_2023_UAV_4ha_buffer_PadHLE_intensity1m.vox"
)
prod(VX@header$dim) == nrow(VX@data) # doit eter cohérent

# View(VX@data)
```

## Crop vox to 4ha
```{r}
zone <- terra::vect("D:/Mes Donnees/PhD/SIG_data/Understory-ALT/Parcelles_Understory.shp")
zone <- st_as_sf(zone) # as sf object
zone <- st_set_crs(zone, 2972)
zone <- st_union(zone)
zone_m <- as.matrix(zone[[1]])

# Lecture matrice de transformation
VOP <- as.matrix(read.table("//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/VOP_P16_9ha.txt"))

matrix <- cbind(zone_m, c = 0, d = 1)
local <- matrix %*% t(VOP) # same dimensions
local <- local[, -c(3,4)]

X <- range(local[,1]) ; Y <- range(local[,2])

# i, j, k = index not coordinates
# VX@data[, c("x", "y", "z") := getPosition(VX)[, .(x, y, z)]]

# range(VX@data$x); range(VX@data$y)
I <- range(VX@data[x>X[1] & x<X[2] & y>Y[1] & y<Y[2], i]) # 20 119
J <- range(VX@data[x>X[1] & x<X[2] & y>Y[1] & y<Y[2], j])  # 51 150
K <- range(VX@data[x>X[1] & x<X[2] & y>Y[1] & y<Y[2], k]) # 0 33

VXUTM_crop <- AMAPVox::crop(VX, imin = I[1], imax = I[2], jmin = J[1], jmax = J[2], kmin = K[1], kmax = K[2])

prod(VXUTM_crop@header$dim) == nrow(VXUTM_crop@data) # doit etre cohérent

Relativ2UTM <- function(data, VOP){
  # Apply inverse of VOP matrix to convert back to UTM
  xyz <- tcrossprod(as.matrix(data@data[, .(x, y, z, c=1)]), solve(VOP))
  data@data[, `:=`(Xutm = xyz[, 1], Yutm = xyz[, 2], Zutm = xyz[, 3])]

  data@data <- unique(data@data)
  return(data)
}
VXUTM_crop <- Relativ2UTM(VXUTM_crop, VOP)
datasf <- st_as_sf(VXUTM_crop@data, coords = c('Xutm','Yutm'))
datasf <- st_set_crs(datasf, terra::crs(zone))


ggplot() + 
  geom_sf(data = datasf, col="blue") +
  theme_classic() +
  geom_sf(data = sf::st_cast(zone, "LINESTRING"), col ="green")
```

## Merge UAV and ALS buffer
```{r}
VXals <- readVoxelSpace(
  "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/HighAltitudeFlight/Intensity_2m/P16_2023_4ha_buffer_HighAlt_PadHLE_intensity2m.vox"
  # "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/HighAltitudeFlight/Intensity_1m/P16_2023_4ha_buffer_HighAlt_PadHLE_intensity1m.vox"
)

prod(VXals@header$dim) == nrow(VXals@data) # doit etre cohérent

nrow(VXals_0@data) - nrow(VXals@data) 
nrow(VX@data)
```


```{r}
VXUTM_crop@header$mincorner;
getPosition(VXals)[x>(-49)& x<(-48) & y>(-49)& y<(-48) & z<1][, .(i,j,k)]

VXals@data[, c("x", "y", "z") := getPosition(VXals)[, .(x, y, z)]]

VXals@data[x>(-49)& x<(-48) & y>(-49)& y<(-48) & z<1, .(i,j,k)]

VXUTM_crop@data[, `:=`(i = i+51, j = j+51)]
VXUTM_crop@header <- VXals@header

plot(VXUTM_crop)
VXUTM_crop@data[, .(x,y,z,i,j,k)]
```


```{r}
VXals@data[, c("x", "y", "z") := getPosition(VXals)[, .(x, y, z)]]

VXalsUTM <- Relativ2UTM(VXals, VOP)

vxalsUTMsf <- st_as_sf(VXalsUTM@data, coords = c('Xutm','Yutm'))
vxalsUTMsf <- st_set_crs(vxalsUTMsf, terra::crs(zone))
vxals_cut <- st_difference(vxalsUTMsf, zone) # enlever les 4ha

VXUTM_crop
setDT(VXals@data)[setDT(VXUTM_crop@data), PadBVTotal := NA, on=list(i,j,k)]


rm(VX, datasf, VXalsUTM, vxalsUTMsf, vxals,vxUTM, vxUTM_crop, Relativ2UTM, VOP, local, matrix, I,J,K,X,Y,Z, zone_m); gc()

ggplot() + 
  geom_sf(data = vxals_cut, col="blue") +
  theme_classic() +
  geom_sf(data = sf::st_cast(zone, "LINESTRING"), col ="green")

st_geometry(vxals_cut) <- NULL

VXals@data <- setDT(vxals_cut)
prod(VXals@header$dim) == nrow(VXals@data) # FALSE

rm(vxals_cut,zone); gc()

# VX_merge_a <- merge(setDT(VX_merge@data), setDT(VX_merge@data), all.x = TRUE, by= c("i","j","k"))

VXUTM_crop@data[,x := NULL][,y := NULL][,z := NULL][, Xutm := NULL][,Yutm := NULL][,Zutm := NULL]

names(VXUTM_crop@data) ; names(VXals@data)

VXals@data[,attenuation_PPL_MLE := NULL][,x := NULL][,y := NULL][,z := NULL][, Xutm := NULL][,Yutm := NULL][,Zutm := NULL] 

VXUTM_crop@header <- VXals@header
VXUTM_crop@header ; VXals@header

VX_PAD <- VXUTM_crop@data[,.(i,j,k,HLE, PadBVTotal)]
VXals_PAD <- VXals@data[,.(i,j,k,HLE, PadBVTotal)] ; gc()

# VX_merge@data <- rbind(VXUTM_crop@data,VXals@data)

VX_merge <- merge(VXUTM_crop,VXals)
VX_merge@header <- VXals@header

#  Discarded from merging.Avis : Variable `HLE`, `PadBVTotal`, `X`, `Y`, `Z`, `Zutm`, does not have predefined merging mode.

VX_merge_a <- merge(setDT(VX_merge@data), setDT(VX_PAD), all.x = TRUE, by= c("i","j","k"))
VX_merge_b <- merge(VX_merge_a, setDT(VXals_PAD), all.x = TRUE, by= c("i","j","k"))

VX_merge_b[, HLE := ifelse(!is.na(HLE.x), HLE.x, HLE.y)]
VX_merge_b[, PadBVTotal := ifelse(!is.na(PadBVTotal.x), PadBVTotal.x, PadBVTotal.y)]
VX_merge_b[, HLE.x := NULL][, HLE.y := NULL][, PadBVTotal.x := NULL][, PadBVTotal.y := NULL] 

VX_merge@data <- setDT(VX_merge_b)
prod(VX_merge@header$dim) == nrow(VX_merge@data) # doit etre cohérent

VX_merge@header ; VXals@header

rm(VX,VXals, VX_merge_a, VX_merge_b); gc()

AMAPVox::plot(VX_merge) ; gc()

```

```{r}
writeVoxelSpace(VX_merge, 
                # "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/AMAPVox/Intensity_2m/P16_2023_UAV_4ha_bufferALS_PadHLE_intensity2m.vox"
  "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/AMAPVox/Intensity_1m/P16_2023_UAV_4ha_bufferALS_PadHLE_intensity1m.vox"
)
```

# Generate light maps from a voxel space
*voir LightMaps.Rmd*

On simule ensuite à l’aide d’AMAPVox des cartes de transmittance à différentes altitudes au-dessus du sol à l’aide du module transmittance light maps. 

A cette étape la **transmittance est hémisphérique** et intégrée dans le temps de la course du soleil.

Lisa :
script de traitement : lightMap_1m.xml
input : test1m_PadHLE.vox
output : lightMap_1m.txt
each = 2 m
height = 1, 10 m
direction number : 136 (pas calculé uniquement selon la verticale mais sur un hémisphère)
Plot rotation : pour prendre en compte la course du soleil : 17° à la louche mais à remesurer sur qgis
"Repetitve scene" si il n'y a pas de buffer mais pas ouf

Latitude de Paracou : 5°
Calendrier : sur une année et pour chaque saison de l’année d’acquisition des données LiDAR

Clearness index : voir section "Compute the clearness index from the tower data"

Amapvox peut générer des photos hémisphériques, des données LAI2200, et des cartes 3D de lumière.

# Positionner capteurs LAI2200 sur la carte de lumière dans AMAPvox

Voir CompareLiDARwithFieldSensors.Rmd


# Test decim dans amapvox (80%) pour savoir à combien de pulse on fait confiance

fichier CheckEffectDecimation.R

full - decim = écart systématique ou non selon le numbre de pulse
