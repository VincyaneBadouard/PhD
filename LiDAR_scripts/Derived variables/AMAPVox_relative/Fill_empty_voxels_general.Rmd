---
title: "Fill empty voxels"
author: "Vincyane Badouard"
date: '`r Sys.Date()`'
output:
  html_document: default
editor_options: 
  markdown: 
    wrap: 72
---

Source: Adapted to the script of Grégoire Vincent.

Certains voxels (en bas de canopée) ne sont pas ou mal échantillonnés
(seuil) du fait de l’occlusion des tirs LiDAR. Ces données manquantes
ont été comblées en appliquant la **moyenne des valeurs de transmittance
des 26 voisins les plus proches**.

Ce ne sont pas des trouées, mais des voxels perdus dans le nuage végétal

Estimer selon le plus probable et selon les besoins  
Prendre en compte le voisinage en excluant les trouées  

3 possibilités si pas de voisins :
- une valeur fallback (fait actuellement)  
- augmenter le voisinage  
- tourner le script plusieurs de fois et faire donc du proche en proche  

1)  get the vegetation voxels only (z > 0.5 m)

2)  Choose a threshold (pulse.min) to consider an poorly sampled voxel:
-   nbSampling <20
-   median : median(fullcanopy@data$nbSampling)
-   test for low altitude lidar: 4,12,20,28,44

Compute a reasonnable fallback value (the median of attenuation) if
local re-estimation fails

3)  Re-estimation of poorly sampled voxels

-   subset of voxels below sampling threshold level (=*nbsampling
median* of the data)
-   but all voxels can contribute to local estimate
-   Get neighbors in immediate neighborhood (27 nearest voxels including
target = 3 neighbors)
-   Recompute attenuation from local neighbourhood :
sum(bsIntercepted)/sum(weightedFreepathLength) (Pimont et al., 2019)

bsIntercepted: nbr de pulses interceptés par l'empreinte du faisceau = surface occluse dans le faisceau
weightedFreepathLength: longueur des trajets optiques pondérée par l'empreinte du faisceau

-   When no value was found, take the fallback value

4)  Create PadBVTotal

# Packages

```{r Setup, include = F}
library(AMAPVox)
library(rgl)
library(lattice)
library(data.table)
library(MASS)
library(ggplot2)
library(tidyverse)
rm(list=ls())
```

# Function

```{r}
##### New function defined here #####
##### just a poor hack of fillNA #####
# HLE : hierarchical local estimation
# HLE = bsIntercepted/weightedFreepathLength (default attenuation) (?)
# HLE max quand rencontre un tronc sur tout un voxel 
# fullcanopy -> vxsp

HLE <- function (
    vxsp, # espace voxel
    variable.name1 = "bsIntercepted", # nbr de pulses interceptés par l'empreinte du faisceau = surface occluse dans le faisceau
    variable.name2 = "weightedFreepathLength", # longueur des trajets optiques pondérée par l'empreinte du faisceau
    variable.min = -Inf, variable.max = Inf, # bornes pas forcément utiles
    variable.fallback, #  valeur d'atténuation si l'algorithme n'en a pas trouvée
    radius = 2, # rayon de voisinage en mètre
    pulse.min = 25 # nbr de pulses satisfaisant pour faire une estimation locale (threshold)
    
){
  # Checks
  stopifnot(is.VoxelSpace(vxsp))
  stopifnot(variable.name1 %in% colnames(vxsp@data),
            length(variable.name1) == 1)
  stopifnot(variable.name2 %in% colnames(vxsp@data),
            length(variable.name2) == 1)
  stopifnot(is.numeric(variable.min), length(variable.min) == 
              1, is.numeric(variable.max), length(variable.max) == 
              1, !is.na(variable.min))
  
  if(!missing(variable.fallback)) 
    stopifnot(is.numeric(variable.fallback), length(variable.fallback) == 1,
              !is.na(variable.fallback))
  
  if(missing(radius)) 
    radius <- max(getVoxelSize(vxsp)) # if no radius take the max voxelsize
  stopifnot(is.numeric(radius), length(radius) == 1, !is.na(radius))
  
  stopifnot(is.numeric(pulse.min), pulse.min >= 0, !is.na(pulse.min))
  
  # fct
  vxsp@data <- setDT(vxsp@data)
  vx <- vxsp@data
  
  # Put an NA if the pulse number is too low
  vx.na <- vx[nbSampling < pulse.min] # subset of voxels below sampling threshold level
  vx.pool <- vx # all voxels can contribute to local estimate!
  # nrow(vx.na)/nrow(vx)*100 # 77% voxels with no suffisent sampling
  
  radius <- max(getVoxelSize(vxsp), radius) # radius would be at less the voxel size 
  
  # Get neighbors in immediate neighborhood (27 nearest voxels including target)
  # This k value could be set as a parameter of the HLE function (for ex. could be 125, i.e.a full step larger)
  
  neighbors <- RANN::nn2(data = getPosition(vxsp, vx.pool), # Pool to search
                         query = getPosition(vxsp, vx.na), # voxes of interest
                         # The maximum number of nearest neighbours to compute
                         k = 27, # k = 27 : 3 voisins # including target
                         searchtype = "radius", radius = radius)
  # -> une matrice où chaque ligne correspond à un point et contient les indices de ses voisins les plus proches
  neighbors <- neighbors$nn.idx # the near neighbour indices
  # sum(neighbors==0)/length(neighbors)*100 # 0.6% missing neighbors

  
  # Recompute attenuation from local neighborhood : sum(bsIntercepted)/sum(weightedFreepathLength)
  # each row of index is a point of interest
  fill.value <- apply( # long
    neighbors, 1, # for a matrix 1 indicates rows
    function(nghb) vx.pool[as.vector(nghb), 
                           sum(get(variable.name1), na.rm = T)/sum(get(variable.name2), na.rm=T)]
  )
  
  any(fill.value==0 | is.na(fill.value))
  fill.value[which(is.nan(fill.value))] <- NA # NaN -> NA. why would this ever happen?
  
  # When no value was found, take the fallback value
  if (!missing(variable.fallback)) 
    fill.value[which(is.na(fill.value))] <- variable.fallback
  na.count <- length(which(is.na(fill.value))) # how many NA are left?
  
  if (na.count > 0) # if any NAs remain
    warning(paste(na.count, " NA left", "\nSomething went wrong somewhere..."))
  
  # Apply the thresholds
  fill.value[which(fill.value > variable.max)] <- variable.max
  fill.value[which(fill.value < variable.min)] <- variable.min
  
  # HLE = bsIntercepted/weightedFreepathLength
  vxsp@data[, HLE := .(get(variable.name1)/get(variable.name2))] # default attenuation
  vxsp@data[neighbors[,1], HLE := fill.value] # modified attenuation
  na.count <- length(which(is.nan(vxsp@data$HLE)))
  
  if (na.count > 0) # if any NAs remain
    warning(paste(na.count, " NA left", "\nSomething went wrong somewhere..."))
  
  return(vxsp)
}
```

# Read voxelSpace

```{r}
vxsp <- readVoxelSpace(
  # ALS intensity 2m res
  # "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/HighAltitudeFlight/Intensity_2m/P16_2023_HighAlt_4ha_buffer_intensity2m.vox"
  # "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/LowAltitudeFlight/Intensity_2m/P16_2023_LowAlt_4ha_buffer_intensity2m.vox"
  
  # ALS intensity 1m res (intensity cor)
  # "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/HighAltitudeFlight/Intensity_1m/P16_2023_HighAlt_4ha_buffer_intensity1m.vox"
  # "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/LowAltitudeFlight/Intensity_1m/P16_2023_LowAlt_4ha_buffer_intensity1m.vox"
  # "//amap-data.cirad.fr/work/users/VincyaneBadouard/DZ_test/AMAPVox/Paracou_HighAlt_DZ_buffer_intensity1m.vox"
  
  # UAV intensity 1m & 2m res
  #  "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/AMAPVox/Intensity_2m/P16_2023_UAV_4ha_buffer_intensity2m_crop.vox"
  #   "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/AMAPVox/Intensity_1m/P16_2023_UAV_4ha_buffer_intensity1m_crop.vox"
  
  # laz pour 25 ha high alt intensity
  "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/HighAltitudeFlight/ForTrees/Vox/P16_2023_HighAlt_4ha_buffer_intensity1m_testnewEB.vox"
  # "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/HighAltitudeFlight/ForTrees/Vox/P16_2023_HighAlt_25ha_buffer_intensity1m_testnewEB.vox"

)



median(vxsp@data$nbSampling) # High Alt : 193 # Low alt1m : 17 # UAV2m : 1264, UAV1m : 275 ; DZ : 1
hist(vxsp@data$nbSampling, breaks=100)
sum(vxsp@data$nbSampling)
range(vxsp@data$weightedFreepathLength)
range(vxsp@data$bsIntercepted)

# vxsp
# summary(vxsp@data)
# Pour ALS2023 low altitude le nbsampling est faible "Il n'y a pas d'incohérence dans les données: si tu travailles avec le fichier alt500m tu ne peux guère espérer mieux! Il faut en effet réduire le seuil pour le post-traitement (nbre minimum de tirs)"
```

# Plot extinction profiles
nbr de pulses qui traversent (1- ce qui est revenu)
```{r, eval=F}
Compute_nbSampling_mean <- function(vxsp){
  data <- setDF(vxsp@data) %>% 
    # filter(nbSampling>0) %>%
    mutate(ground_distance_disc = as.integer(ground_distance)) %>% 
    group_by(ground_distance_disc) %>% 
    mutate(MeanNbsampling = mean(nbSampling)) %>% 
    mutate(SdNbsampling = sd(nbSampling)) %>% 
    mutate(MinNbsampling = min(nbSampling)) %>% 
    mutate(MaxNbsampling = max(nbSampling)) %>%
    ungroup() %>% 
    dplyr::select(ground_distance_disc, MeanNbsampling, SdNbsampling) %>% 
    filter(ground_distance_disc>=0 & ground_distance_disc<=60) %>% 
    # filter(ground_distance_disc %% 2 == F) %>% # de 2 en 2 m d'altitude if res = 2m
    unique()
  return(data)
}

data <- Compute_nbSampling_mean(vxsp)
col <- "Low alt - 1m"
data %>% 
  filter(ground_distance_disc < 20) %>%
  ggplot(aes(x= ground_distance_disc, y= MeanNbsampling)) +
  # xlim(0,55) +
  geom_point(aes(x = ground_distance_disc, y = MeanNbsampling, colour = col)) +
  geom_line(aes(x = ground_distance_disc, y = MeanNbsampling, colour = col)) +
  
  # scale_colour_manual(values = c(col = "#E69F00")) + # "#F0E442" "#E69F00"
  theme_minimal() +
  ggtitle("P16 - 2023 - 4ha + buffer - extinction profile") +
  labs(y="Average number of through pulses", x="Absolute Tree Height", color = "LiDAR acquisition") +
  # scale_y_continuous(breaks = seq(0, max(data$MeanNbsampling), by=200))+
  scale_x_continuous(breaks = seq(0, max(20), by=1)) + # 2 or 1
  coord_flip() #+
# geom_errorbar(aes(ymin=MeanNbsampling-SdNbsampling, ymax=MeanNbsampling+SdNbsampling), width=.2)
#   geom_errorbar(aes(ymin=MinNbsampling, ymax=MaxNbsampling), width=.2)

# ggsave("UAV2023_P16_4ha_nbSampling_mean_intensity_2m_inf10m.png",
#        path = "D:/Mes Donnees/PhD/Figures/lidar/Voxélisation/nbSampling_profil/Intensity_2m",
#        width = 18, height = 20, units = "cm", dpi=800, bg="white")
```

# First get vegetation voxels only

```{r}
OnlyVegetation <- function(vxsp){
  vxsp@data <- setDT(vxsp@data)
  bcnp <- belowCanopy(vxsp) # enlève tous les voxels au dessus de la canopée
  # summary(bcnp)
  
  dz = getVoxelSize(vxsp)["z"] # Gets the elemental size of a voxel (dx, dy, dz) in meter.
  
  # Considérer tout ce qui est à + de 0.5 m du z=0 comme de la végétation
  veg <- vxsp@data[bcnp, list(i,j,k,ground_distance), # combine data.tables on i,j,k columns
                   on = list(i, j, k)][ground_distance >= (0.5 * dz),
                                       list(i,j,k)] # keep only i,j,k columns
  fullcanopy <- vxsp
  fullcanopy@data <- vxsp@data[veg,,on = list(i,j,k)] # only veg part
  
  return(fullcanopy)
  
}

fullcanopy <- OnlyVegetation(vxsp)

# AMAPVox::plot(fullcanopy)
```

# Compute a reasonnable fallback value if local re-estimation fails

fallback value = the median of attenuation

nbSampling : nombre d'échantillonage. Prendre les plus fiables (>=25)

On utilise l'atténuation biaisée pcq la débiaisée ne peut pas être
utilisée à multiple échelle.

Biais d'échantillonage : quand peu échantilloné a tendence à renvoyer
une grande densité

```{r}
# hist(fullcanopy@data$nbSampling, breaks=100)

pulsemin_fbv <- function(fullcanopy, thres = 20){
  # pulse.min <- median(fullcanopy@data$nbSampling) # Low : 8 ; High : 44
  # pulse.min
  pulse.min = thres # seq(4,28, by=8) =  4 12 20 28 44
  fbv <- median(fullcanopy@data[nbSampling>=pulse.min, na.omit(attenuation_FPL_biasedMLE)]) # 0.0257098
  # fbv
  return(list(pulse.min = pulse.min, fbv=fbv))
}

pulsemin_fbv <- pulsemin_fbv(fullcanopy)
pulsemin <- pulsemin_fbv$pulse.min
fbv <-  pulsemin_fbv$fbv # 0.0832371

# UAV 2m : pulse min 20 -> fbv 0.0999208
# UAV 1m : pulse min 20 -> fbv  0.0323688
# High : pulse min 25 -> fbv 0.01451735
# High 1m : pulse min 20 ->
# Low :
# pulse min 4 -> 0
# pulse min 12 -> fbv 0.021692
# pulse min 20 -> 0.0548681
# pulse min 28 ->  0.1011642
# pulse min 28 ->  0.0258637
```

# Poorly sampled voxels

```{r, eval=F}
VX <- vxsp
VX@data <- VX@data[nbSampling<20]
AMAPVox::plot(VX, variable.name = "nbSampling")

Poorly_smpld_vxl <- function(fullcanopy, path, thres =20){
  na <- nrow(fullcanopy@data[nbSampling<thres])/nrow(fullcanopy@data) # proportion of voxels below sampling threshold level (à garder pour comparer entre les différentes méthodes d'acquisition lidar)
  write.csv(na, path)
}
# Poorly_smpld_vxl(fullcanopy_High, "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/HighAltitudeFlight/Intensity_2m/Poorly20_smpld_vxl_Proportion2023HighAlt.csv")
# Poorly_smpld_vxl(fullcanopy_Low, "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/LowAltitudeFlight/Intensity_2m/Poorly20_smpld_vxl_Proportion2023LowAlt.csv")

path <- 
  # DZ
  "//amap-data.cirad.fr/work/users/VincyaneBadouard/DZ_test/AMAPVox/Poorly20_smpld_vxl_DZbuffer_Proportion2023HighAlt1m.csv"

  # UAV ----
  # "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/AMAPVox/Intensity_2m/Poorly20_smpld_vxl_Proportion2023UAV2m.csv"
 # "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/AMAPVox/Intensity_1m/Poorly20_smpld_vxl_Proportion2023UAV1m.csv"
 
# ALS ----
# "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/HighAltitudeFlight/Intensity_1m/Poorly25_smpld_vxl_Proportion2023HighAlt1m.csv"
# "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/lowAltitudeFlight/Intensity_1m/Poorly20_smpld_vxl_Proportion2023LowAlt1m.csv"
# "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/lowAltitudeFlight/Intensity_1m/Poorly8_smpld_vxl_Proportion2023LowAlt1m.csv"


# "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/lowAltitudeFlight/EmptyVoxelsProportion2023LowAlt.csv"
# "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/HighAltitudeFlight/EmptyVoxelsProportion2023HighAlt.csv" # 0.37
# "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2022/EmptyVoxelsProportion2022.csv"

Poorly_smpld_vxl(fullcanopy, path)
```

## Poorly sampled voxels per altitude (plot)
```{r, eval=F}
Poorly_sampled_voxels_per_altitude <- function(fullcanopy, nbSampling_threshold=20){
  data <- setDF(fullcanopy@data) 
  data <- data %>% 
    mutate(ground_distance_disc = as.integer(ground_distance)) %>% 
    group_by(ground_distance_disc) %>% 
    mutate(Poor = ifelse(nbSampling < nbSampling_threshold, 1, 0)) %>%
    mutate(N_empty_voxels = sum(Poor)) %>% # nbr
    group_by(ground_distance_disc,Poor) %>% 
    mutate(`%_empty_voxels` = n()/nrow(.)*100) %>% # %
    ungroup() %>% 
    filter(Poor==1) %>% 
    # mutate(`%_empty_voxels` = ifelse(Poor==0, 0, `%_empty_voxels`)) %>% 
    dplyr::select(c(ground_distance_disc, N_empty_voxels,`%_empty_voxels`)) %>% 
    filter(ground_distance_disc>=0 & ground_distance_disc<=45) %>% 
    # filter(ground_distance_disc %% 2 == F) %>% # de 2 en 2 m d'altitude if res = 2m
    unique()
  
}

# dataHigh <- Poorly_sampled_voxels_per_altitude(fullcanopy_High)
# dataLow <- Poorly_sampled_voxels_per_altitude(fullcanopy_Low)

data <- Poorly_sampled_voxels_per_altitude(fullcanopy)
# dataUAV2m <- Poorly_sampled_voxels_per_altitude(fullcanopy_UAV2m)

gc()

# data1 <- dataUAV1m ; acq1 <- "UAV1m" # "High altitude"
# data2 <- dataUAV2m ; acq2 <- "UAV2m" # "Low altitude"

data %>% 
  ggplot(aes(x= ground_distance_disc, y= `%_empty_voxels`)) +
  geom_point(aes(colour = col)) +
  geom_line(aes(colour = col)) +
  # geom_point(data = data2, aes(colour = acq2)) +
  # geom_line(data = data2, aes(colour = acq2)) +
  # scale_colour_manual(values = c(col = "#56B4E9" #,
  # # acq2 = "#56B4E9"
  # )) +
  theme_minimal() +
  ggtitle("P16-2023-4ha+buffer - Proportion of poorly sampled voxels per altitude") +
  labs(y="% of poorly sampled voxels (<10 pulses)", x="Ground distance", color = "LiDAR acquisition") +
  # xlim(0,45) +
  scale_x_continuous(breaks = seq(0, max(data$ground_distance_disc), by=1))+ # 2 or 1
  # scale_x_continuous(breaks = seq(0,160615, by= 25000))
  coord_flip()

# ggsave("P16_2023_4ha_buffer_Low_1m_res_Poorly_sampled_voxels_20sampling_per_altitude_intensity.png",
#        path = "D:/Mes Donnees/PhD/Figures/lidar/Voxélisation/Empty_voxels_profil",
#        width = 20, height = 20, units = "cm", dpi=800, bg="white")
# "P16_2023_4ha_buffer_HighvsLow_Poorly_sampled_voxels_20sampling_per_altitude_intensity1m.png"
```

# Re-estimation of poorly sampled voxels
un peu long

```{r}
# names(vxsp@data)
gc()
fullcanopy <- HLE(fullcanopy, # voxel space (only vegetation)
                  variable.name1 = "bsIntercepted",
                  variable.name2 = "weightedFreepathLength",
                  variable.min = -Inf, variable.max = Inf, 
                  variable.fallback = fbv, radius = 2, pulse.min = pulsemin)

gc()

"HLE" %in% names(fullcanopy@data)
range(fullcanopy$HLE) #UAV2m :  0.00000 18.93058 ; UAV1m :  0.00000 211.9542

sum(is.na(fullcanopy@data$HLE)) # 0
sum(is.nan(fullcanopy@data$HLE)) # 0
sum(!is.na(fullcanopy@data$HLE))  # UAV2m: 388218 ; ; UAV1m: 2960969
all(is.na(fullcanopy@data[is.na(HLE)]$bsIntercepted)|is.na(fullcanopy@data[is.na(HLE)]$weightedFreepathLength)|fullcanopy@data[is.na(HLE)]$bsIntercepted==0) # missing HLE is when bsIntercepted or weightedFreepathLength are missing or equal to 0

hist(fullcanopy$HLE)
```

# Visualisation

```{r, eval=F}
VX <- fullcanopy
VX@data <- fullcanopy@data[!is.na(HLE) & HLE<2.5]
AMAPVox::plot(VX, variable.name = "HLE")

plot(HLE~attenuation_FPL_biasedMLE, data=fullcanopy@data[1:1000])
plot(HLE~attenuation_FPL_unbiasedMLE, data=fullcanopy@data[1:10000])
plot(attenuation_FPL_biasedMLE~attenuation_FPL_unbiasedMLE, data=fullcanopy@data[1:1000])

fullcanopy@data[HLE>40,]

hist(fullcanopy@data$attenuation_FPL_unbiasedMLE)

quantile(x=fullcanopy@data$attenuation_FPL_unbiasedMLE, prob=c(0.5,0.9,0.95,0.99), na.rm = T)
range(fullcanopy@data$attenuation_FPL_unbiasedMLE, na.rm = T)
range(na.omit(fullcanopy@data$HLE))

# Replace extreme low and high values
# fullcanopy@data$attenuation_FPL_unbiasedMLE <- pmax(fullcanopy@data$attenuation_FPL_unbiasedMLE,0)
# fullcanopy@data$attenuation_FPL_unbiasedMLE <- pmin(fullcanopy@data$attenuation_FPL_unbiasedMLE, quantile(fullcanopy@data$attenuation_FPL_unbiasedMLE, prob=c(0.99), na.rm = T))
```

# Create PadBVTotal

ref : VINCENT, Gregoire; PIMONT, François; VERLEY, Philippe, 2021, "A
note on PAD/LAD estimators implemented in AMAPVox 1.7",
<doi:10.23708/1AJNMP> , DataSuds, V1

Computes Plant Area Density either from (transmittance or) attenuation
coefficient estimates. PAD is defind as the plant area per unit volume
(PAD plant area / voxel volume = m^2 / m^3). Plant area density (PAD
in m2·m−3)

PadBVTotal = 2* attenuation (soit 2*-log(transmittance)

PadBVTotal = 2 * HLE

*AMAPVox::plantAreaDensity utilise une des variables disponibles
"transmittance", "attenuation_FPL_unbiasedMLE" ou "attenuation_PPL_MLE"
et génère une variable du même nom précédé du préfixe "pad\_"*

```{r}
Compute_PAD <- function(fullcanopy, vxsp, fbv){
  fullcanopy@data$HLE[which(is.na(fullcanopy@data$HLE))] <- fbv  # to allow later transmittance computations using AMAPVox
  
  fullcanopy@data$PadBVTotal <- 2*fullcanopy@data$HLE # *2 car hp d'orientation sphérique des feuilles
  
  # Import updated fields
  vxsp@data <- merge(vxsp@data,fullcanopy@data[,.(i,j,k,HLE,PadBVTotal)], by=c("i","j","k"), all.x=T) # veg and ground data
  
  # Fill-in above canopy and below ground voxels with 0 PadBVTotal value
  vxsp@data$PadBVTotal[which(is.na(vxsp@data$PadBVTotal))] <- 0  # to allow later transmittance computations using AMAPVox
  
  return(vxsp)
}

vxsp <- Compute_PAD(fullcanopy, vxsp, fbv)

gc()
range(vxsp@data$PadBVTotal) # UAV2m : 0.00000 37.86115 ; UAV1m : 0.00000 423.9084
any(is.na(vxsp@data$PadBVTotal))
sum(is.na(vxsp@data$HLE))
```

# Compute Transmittance from attenuation (pas besoin, ampavox le calcule)

T = I/Io, where I = transmitted light (“output”) and Io = incident light
(“input”) Transmission=exp\^(-HLE) ?

(l'attenuation n'est pas censé être \>0, elle l'est dues aux
statistiques, mais on ne l'ajuste pas à 0 car en moyenne elle est
débiaisée)

```{r}
any(is.na(vxsp@data$HLE))

Compute_Transmittance <- function(vxsp){
  vxsp@data$Transmittance <- exp(-(vxsp@data$HLE))
  # range(na.omit(vxsp@data$Transmittance))
  return(vxsp)
}
vxsp <- Compute_Transmittance(vxsp)

range(vxsp@data$Transmittance)
```

```{r}
path <- 
  # "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/AMAPVox/Intensity_2m/P16_2023_UAV_4ha_buffer_PadHLE_intensity2m.vox"
  # "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/AMAPVox/Intensity_1m/P16_2023_UAV_4ha_buffer_PadHLE_intensity1m.vox"
# "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/HighAltitudeFlight/Intensity_1m/P16_2023_4ha_buffer_HighAlt_PadHLE_intensity1m.vox"
# "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/HighAltitudeFlight/Intensity_2m/P16_2023_4ha_buffer_HighAlt_PadHLE_intensity2m.vox"
# "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/lowAltitudeFlight/P16_2023_4ha_buffer_LowAlt_PadHLE_pulseMin44.vox"
# "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/LowAltitudeFlight/Intensity_2m/P16_2023_4ha_buffer_LowAlt_PadHLE_intensity2m.vox"
  # "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/LowAltitudeFlight/Intensity_1m/P16_2023_4ha_buffer_LowAlt_PadHLE_intensity1m.vox"
 # "//amap-data.cirad.fr/work/users/VincyaneBadouard/DZ_test/AMAPVox/Paracou_HighAlt_DZ_buffer_PadHLE_intensity1m.vox"
  
  # laz pour 25 ha high alt intensity
  "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/HighAltitudeFlight/ForTrees/Vox/P16_2023_HighAlt_25ha_buffer_PadHLE_intensity1m_testnewEB.vox"

writeVoxelSpace(vxsp, path)

# "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/lowAltitudeFlight/P16_2023_4ha_buffer_LowAlt_PadHLE.vox"
# "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/HighAltitudeFlight/P16_2023_4ha_buffer_HighAlt_PadHLE.vox"
# "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2022/P16_2022_4ha_buffer__PadHLE.vox"
```

# Plot PAD vertical profile (plot)

```{r}
vxsp <- readVoxelSpace(
  "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/AMAPVox/Intensity_2m/P16_2023_UAV_4ha_buffer_PadHLE_intensity2m.vox"
  # "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/AMAPVox/Intensity_1m/P16_2023_UAV_4ha_buffer_PadHLE_intensity1m.vox"
)
# "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/HighAltitudeFlight/P16_2023_4ha_buffer_HighAlt_PadHLE.vox"
# "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/lowAltitudeFlight/P16_2023_4ha_buffer_LowAlt_PadHLE.vox"

# Crop voxel to test
# subvox <- crop(vxsp, -50, 50, -50, 50)
# AMAPVox::plot(subvox)
# writeVoxelSpace(subvox,"//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2022/subvox.vox")

data <- vxsp@data %>% 
  filter(nbSampling>0) %>%
  mutate(ground_distance_disc = as.integer(ground_distance)) %>% 
  group_by(ground_distance_disc) %>% 
  mutate(MeanPAD = mean(PadBVTotal)) %>% 
  mutate(MinPAD = min(PadBVTotal)) %>% 
  mutate(MaxPAD = max(PadBVTotal)) %>%
  mutate(MeanNbsampling = mean(nbSampling)) %>% 
  mutate(SdNbsampling = sd(nbSampling)) %>% 
  mutate(MinNbsampling = min(nbSampling)) %>% 
  mutate(MaxNbsampling = max(nbSampling)) %>%
  ungroup()

data %>% 
  select(ground_distance_disc, MeanPAD, MinPAD, MaxPAD) %>% 
  filter(ground_distance_disc>=0 & ground_distance_disc<=60) %>% 
  unique() %>% 
  ggplot(aes(x= ground_distance_disc, y= MeanPAD)) +
  geom_point() + 
  geom_line() +
  #scale_color_viridis_d() +
  # xlim(0,1) +
  # ylim(0,60) +
  ggtitle("P16 - 2023 - 4ha + buffer -  PAD profile") +
  # theme(plot.title = element_text(hjust=0.5)) + 
  labs(y="PAD", x="Absolute Tree Height") +
  coord_flip() #+ # coordonnées inversées au départ pour que la ligne suive la hauteur au sol et non le PAD
# geom_errorbar(aes(ymin=MinPAD, ymax=MaxPAD), width=.2)#+ 
# options(repr.plot.width=8, repr.plot.height=15) # higher height
```
