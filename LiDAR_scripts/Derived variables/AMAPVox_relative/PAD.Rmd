---
title: "PAD"
author: "Vincyane"
date: "`r Sys.Date()`"
output: html_document
---

# Create PadBVTotal

ref : VINCENT, Gregoire; PIMONT, François; VERLEY, Philippe, 2021, "A
note on PAD/LAD estimators implemented in AMAPVox 1.7",
<doi:10.23708/1AJNMP> , DataSuds, V1

Computes Plant Area Density either from (transmittance or) attenuation
coefficient estimates. PAD is defind as the plant area per unit volume
(PAD plant area / voxel volume = m\^2 / m\^3). Plant area density (PAD
in m2·m−3)

PadBVTotal = 2\* attenuation (soit 2\*-log(transmittance)

PadBVTotal = 2 \* HLE

*AMAPVox::plantAreaDensity utilise une des variables disponibles
"transmittance", "attenuation_FPL_unbiasedMLE" ou "attenuation_PPL_MLE"
et génère une variable du même nom précédé du préfixe "pad\_"*

# Packages

```{r Setup, include = F}
library(AMAPVox)
library(rgl)
library(lattice)
library(data.table)
library(MASS)
library(tidyverse)
# rm(list=ls())
```

# Read voxelSpace
```{r}
vxsp_High <- readVoxelSpace("//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/HighAltitudeFlight/Intensity_2m/P16_2023_HighAlt_4ha_buffer_intensity2m.vox")
vxsp_Low <- readVoxelSpace("//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/LowAltitudeFlight/Intensity_2m/P16_2023_LowAlt_4ha_buffer_intensity2m.vox")

vxsp_UAV2m <- readVoxelSpace(
  "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/AMAPVox/Intensity_2m/P16_2023_UAV_4ha_buffer_intensity2m_crop.vox")
vxsp_UAV1m <- readVoxelSpace("//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/AMAPVox/Intensity_1m/P16_2023_UAV_4ha_buffer_intensity1m_crop.vox")

# "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2022/P16_2022_4ha_buffer.vox"

# vxsp
# summary(vxsp@data)
# Pour ALS2023 low altitude le nbsampling est faible "Il n'y a pas d'incohérence dans les données: si tu travailles avec le fichier alt500m tu ne peux guère espérer mieux! Il faut en effet réduire le seuil pour le post-traitement (nbre minimum de tirs)"
```

# First get vegetation voxels only
```{r}
OnlyVegetation <- function(vxsp){
  bcnp <- belowCanopy(vxsp) # enlève tous les voxels au dessus de la canopée
  # summary(bcnp)
  
  dz = getVoxelSize(vxsp)["z"] # Gets the elemental size of a voxel (dx, dy, dz) in meter.
  
  # Considérer tout ce qui est à + de 0.5 m du z=0 comme de la végétation
  veg <- vxsp@data[bcnp, list(i,j,k,ground_distance), # combine data.tables on i,j,k columns
                   on = list(i, j, k)][ground_distance >= (0.5 * dz),
                                       list(i,j,k)] # keep only i,j,k columns
  fullcanopy <- vxsp
  fullcanopy@data <- vxsp@data[veg,,on = list(i,j,k)] # only veg part
  
  return(fullcanopy)
  
}

fullcanopy_High <- OnlyVegetation(vxsp_High)
fullcanopy_Low <- OnlyVegetation(vxsp_Low)
fullcanopy_UAV2m <- OnlyVegetation(vxsp_UAV2m)
fullcanopy_UAV1m <- OnlyVegetation(vxsp_UAV1m)


# summary(fullcanopy@data)
```

# Compute PAD
(HLE ou attenuation_FPL_biasedMLE)
```{r}
Compute_PAD <- function(fullcanopy, vxsp){
  fullcanopy@data$PadBVTotal <- 2*fullcanopy@data$attenuation_FPL_biasedMLE # *2 car hp d'orientation sphérique des feuilles
  
  # Import updated fields
  vxsp@data <- merge(vxsp@data,fullcanopy@data[,.(i,j,k,attenuation_FPL_biasedMLE,PadBVTotal)], by=c("i","j","k"), all.x=T) # veg and ground data
  
  # Fill-in above canopy and below ground voxels with 0 PadBVTotal value
  vxsp@data$PadBVTotal[which(is.na(vxsp@data$PadBVTotal))] <- 0  # to allow later transmittance computations using AMAPVox
  return(vxsp)
}

vxsp_High <- Compute_PAD(fullcanopy_High, vxsp_High)
vxsp_Low <- Compute_PAD(fullcanopy_Low, vxsp_Low)
vxsp_UAV2m <- Compute_PAD(fullcanopy_UAV2m, vxsp_UAV2m)
vxsp_UAV1m <- Compute_PAD(fullcanopy_UAV1m, vxsp_UAV1m)


rm(fullcanopy_High, fullcanopy_Low, fullcanopy_UAV2m, fullcanopy_UAV1m)
gc()
```

# Filter at >4, 12 nbSampling for both
```{r}
Filter_nbSampling <- function(vxsp_High, vxsp_Low, nbSampling_threshold =20){
  # data1 <- vxsp_High@data %>%
  #   mutate(ground_distance_disc = as.integer(ground_distance)) %>%
  #   select(ground_distance_disc, nbSampling, PadBVTotal)
  # 
  # data2 <- vxsp_Low@data %>%
  #   mutate(ground_distance_disc = as.integer(ground_distance)) %>%
  #   select(ground_distance_disc, nbSampling, PadBVTotal)
  # 
  # gc()
  # 
  # data <- data1 %>% 
  #   left_join(data2, by= "ground_distance_disc", suffix = c("_High", "_Low")) %>% 
  #   filter(nbSampling_High > nbSampling_threshold & nbSampling_Low > nbSampling_threshold)
  
  data1 <- unique(setDT(vxsp_High@data)[,ground_distance_disc := as.integer(ground_distance)][,.(ground_distance_disc, nbSampling, PadBVTotal)])
  data1 <- setkey(data1, ground_distance_disc)
  data2 <- unique(setDT(vxsp_Low@data)[,ground_distance_disc := as.integer(ground_distance)][,.(ground_distance_disc, nbSampling, PadBVTotal)])
  data2 <- setkey(data2, ground_distance_disc)
  
  gc()
  
  # all=TRUE, allow.cartesian=TRUE,
  data <- merge(data1, data2, suffixes = c("_High", "_Low"), allow.cartesian=TRUE)
  
  data1[data2, on= .(ground_distance_disc=ground_distance_disc), by=.EACHI]
  
  data1[data2, allow.cartesian = TRUE, nomatch = 0, by = .EACHI]
  
  return(data)
}

data <- Filter_nbSampling(vxsp_High, vxsp_Low, 20)

```

# Compute MeanPAD
```{r}
Compute_PAD_mean <- function(vxsp, nbSampling_threshold=0){
  data <- vxsp@data %>% 
    filter(nbSampling>nbSampling_threshold) %>%
    mutate(ground_distance_disc = as.integer(ground_distance)) %>% 
    group_by(ground_distance_disc) %>% 
    mutate(MeanPAD = mean(PadBVTotal)) %>% # mean
    mutate(MinPAD = min(PadBVTotal)) %>% 
    mutate(MaxPAD = max(PadBVTotal)) %>%
    ungroup() %>% 
    select(ground_distance_disc, MeanPAD, MinPAD, MaxPAD) %>% 
    filter(ground_distance_disc>=0 & ground_distance_disc<=60) %>% 
    filter(ground_distance_disc %% 2 == F) %>% # de 2 en 2 m d'altitude if res = 2m
    unique() 
  return(data)
}

dataHigh <- Compute_PAD_mean(vxsp_High, nbSampling_threshold =0)
rm(vxsp_High)
dataLow <- Compute_PAD_mean(vxsp_Low, nbSampling_threshold =0)
rm(vxsp_Low)
dataUAV2m <- Compute_PAD_mean(vxsp_UAV2m, nbSampling_threshold =0)
rm(vxsp_UAV2m)
dataUAV1m <- Compute_PAD_mean(vxsp_UAV1m, nbSampling_threshold =0)
rm(vxsp_UAV1m)
```


# Plot PAD vertical profile before estimation
```{r}
dataLow %>% 
  ggplot(aes(x= ground_distance_disc, y= MeanPAD )) +
  geom_point(data = dataHigh, aes(x = ground_distance_disc, y = MeanPAD, colour = "High altitude - 2m")) +
  geom_line(data = dataHigh, aes(x = ground_distance_disc, y = MeanPAD, colour = "High altitude - 2m")) +
  
  geom_point(data = dataLow, aes(x = ground_distance_disc, y = MeanPAD, colour = "Low altitude - 2m")) +
  geom_line(data = dataLow, aes(x = ground_distance_disc, y = MeanPAD, colour = "Low altitude - 2m")) +
  
  geom_point(data = dataUAV2m, aes(x = ground_distance_disc, y = MeanPAD, colour = "UAV - 2m")) +
  geom_line(data = dataUAV2m, aes(x = ground_distance_disc, y = MeanPAD, colour = "UAV - 2m")) +
  
  geom_point(data = dataUAV1m, aes(x = ground_distance_disc, y = MeanPAD, colour = "UAV - 1m")) +
  geom_line(data = dataUAV1m, aes(x = ground_distance_disc, y = MeanPAD, colour = "UAV - 1m")) +
  
  scale_colour_manual(values = c("High altitude - 2m" = "blue",
                                 "Low altitude - 2m" = "#56B4E9",
                                 "UAV - 2m" = "#E69F00",
                                 "UAV - 1m" = "#F0E442")) +
  theme_minimal() +
  ggtitle("P16-2023-4ha+buffer - PAD profile before estimation (intensity)") +
  labs(y="PAD", x="Absolute Tree Height", color = "LiDAR acquisition") +
  coord_flip() #+ # coordonnées inversées au départ pour que la ligne suive la hauteur au sol et non le PAD
# geom_errorbar(aes(ymin=MinPAD, ymax=MaxPAD), width=.2)#+ 
# options(repr.plot.width=8, repr.plot.height=15) # higher height

ggsave("ALS2023_P16_4ha_ALSvsUAV_PAD_before_fillEmptyVxl_intensity.png",
       path = "D:/Mes Donnees/PhD/Figures/lidar/Voxélisation/PAD_profil/Intensity_2m",
       width = 18, height = 20, units = "cm", dpi=800, bg="white")
```

```{r}
rm(dataLow, dataHigh, dataUAV2m, dataUAV1m)
```

# Plot PAD vertical profile after estimation
```{r}
# vxsp_High <- readVoxelSpace("//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/HighAltitudeFlight/P16_2023_4ha_buffer_HighAlt_PadHLE.vox")
# 
# vxsp_low_pulseMin4 <- readVoxelSpace("//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/lowAltitudeFlight/P16_2023_4ha_buffer_LowAlt_PadHLE.vox")
# vxsp_low_pulseMin12 <- readVoxelSpace("//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/lowAltitudeFlight/P16_2023_4ha_buffer_LowAlt_PadHLE_pulseMin12.vox")
# vxsp_low_pulseMin20 <- readVoxelSpace("//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/lowAltitudeFlight/P16_2023_4ha_buffer_LowAlt_PadHLE_pulseMin20.vox")
# vxsp_low_pulseMin28 <- readVoxelSpace("//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/lowAltitudeFlight/P16_2023_4ha_buffer_LowAlt_PadHLE_pulseMin28.vox")
# vxsp_low_pulseMin44 <- readVoxelSpace("//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/lowAltitudeFlight/P16_2023_4ha_buffer_LowAlt_PadHLE_pulseMin44.vox")

vxsp_High <- readVoxelSpace("//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/HighAltitudeFlight/Intensity_2m/P16_2023_4ha_buffer_HighAlt_PadHLE_intensity2m.vox")
vxsp_Low <- readVoxelSpace("//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/LowAltitudeFlight/Intensity_2m/P16_2023_4ha_buffer_LowAlt_PadHLE_intensity2m.vox")

vxsp_UAV2m <- readVoxelSpace(
  "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/AMAPVox/Intensity_2m/P16_2023_UAV_4ha_buffer_PadHLE_intensity2m.vox")
vxsp_UAV1m <- readVoxelSpace("//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/AMAPVox/Intensity_1m/P16_2023_UAV_4ha_buffer_PadHLE_intensity1m.vox")

vxsp_UAVbuf <- readVoxelSpace("//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/AMAPVox/Intensity_2m/P16_2023_UAV_4ha_bufferALS_PadHLE_intensity2m.vox")

# 25 ha
vxsp <- readVoxelSpace("//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2019/Vox/P16_2019_25ha_buffer_PadHLE_intensity2m.vox") # 2019 intensity2m 

vxsp_High@header
# $mincorner
#         x         y         z 
# -150.1270 -150.4118    0.0000 
# 
# $maxcorner
#        x        y        z 
# 250.3382 250.2349 103.6500 

vxsp_UAV2m@header
# $mincorner
#         x         y         z 
# -150.1270 -150.4118    0.0000 
# 
# $maxcorner
#        x        y        z 
# 250.3382 250.2349 103.6500 

vxsp_UAVbuf@header
# $mincorner
#         x         y         z 
# -150.1270 -150.4118    0.0000 
# 
# $maxcorner
#        x        y        z 
# 250.3382 250.2349 103.6500 

vxsp_UAV2m <- vxsp_UAV2m@data
vxsp_UAVbuf <- vxsp_UAVbuf@data
vxsp_High <- vxsp_High@data

# vxsp_High <- vxsp@data


names(vxsp_High) %in% names(vxsp_UAVbuf)
```

```{r}
Compute_PAD_nbSampling_mean <- function(vxsp){
  data <- setDF(vxsp@data) %>% 
    filter(nbSampling>0) %>%
    mutate(ground_distance_disc = as.integer(ground_distance)) %>% 
    group_by(ground_distance_disc) %>% 
    mutate(MeanPAD = mean(PadBVTotal)) %>% 
    mutate(MinPAD = min(PadBVTotal)) %>% 
    mutate(MaxPAD = max(PadBVTotal)) %>%
    mutate(MeanNbsampling = mean(nbSampling)) %>% 
    mutate(SdNbsampling = sd(nbSampling)) %>% 
    mutate(MinNbsampling = min(nbSampling)) %>% 
    mutate(MaxNbsampling = max(nbSampling)) %>%
    ungroup() %>% 
    dplyr::select(ground_distance_disc, MeanPAD, MinPAD, MaxPAD, MeanNbsampling, SdNbsampling) %>% 
    filter(ground_distance_disc>=0 & ground_distance_disc<=60) %>% 
    filter(ground_distance_disc %% 2 == F) %>% # de 2 en 2 m d'altitude if res = 2m
    unique()
  return(data)
}

dataHigh <- Compute_PAD_nbSampling_mean(vxsp_High)
rm(vxsp_High)

dataLow <- Compute_PAD_nbSampling_mean(vxsp_Low)
rm(vxsp_Low)

dataUAV2m <- Compute_PAD_nbSampling_mean(vxsp_UAV2m)
rm(vxsp_UAV2m)

dataUAV1m <- Compute_PAD_nbSampling_mean(vxsp_UAV1m)
rm(vxsp_UAV1m)

dataHigh <- Compute_PAD_nbSampling_mean(vxsp)
rm(vxsp)


gc()

# dataLow_pulseMin4 <- Compute_PAD_nbSampling_mean(vxsp_low_pulseMin4)
# rm(vxsp_low_pulseMin4)
# 
# dataLow_pulseMin12 <- Compute_PAD_nbSampling_mean(vxsp_low_pulseMin12)
# rm(vxsp_low_pulseMin12)
# 
# dataLow_pulseMin20 <- Compute_PAD_nbSampling_mean(vxsp_low_pulseMin20)
# rm(vxsp_low_pulseMin20)
# 
# dataLow_pulseMin28 <- Compute_PAD_nbSampling_mean(vxsp_low_pulseMin28)
# rm(vxsp_low_pulseMin28)
# 
# dataLow_pulseMin44 <- Compute_PAD_nbSampling_mean(vxsp_low_pulseMin44)
# rm(vxsp_low_pulseMin44)
```


```{r}
Title <- "P16-2019-25ha+buffer - PAD profile after estimation (intensity2m)"
  # "P16-2023-4ha+buffer - PAD profile after estimation (intensity) - pulse min=20"
dataHigh %>% 
  ggplot(aes(x= ground_distance_disc, y= MeanPAD )) +
  geom_point(data = dataHigh, aes(y = MeanPAD, colour = "High altitude - 2m")) +
  geom_line(data = dataHigh, aes(y = MeanPAD, colour = "High altitude - 2m")) +
  
  # geom_point(data = dataLow, aes(y = MeanPAD, colour = "Low altitude - 2m")) +
  # geom_line(data = dataLow, aes(y = MeanPAD, colour = "Low altitude - 2m")) +
  # 
  # geom_point(data = dataUAV2m, aes(x = ground_distance_disc, y = MeanPAD, colour = "UAV - 2m")) +
  # geom_line(data = dataUAV2m, aes(x = ground_distance_disc, y = MeanPAD, colour = "UAV - 2m")) +
  # 
  # geom_point(data = dataUAV1m, aes(x = ground_distance_disc, y = MeanPAD, colour = "UAV - 1m")) +
  # geom_line(data = dataUAV1m, aes(x = ground_distance_disc, y = MeanPAD, colour = "UAV - 1m")) +
  
  # geom_point(data = dataLow_pulseMin4, aes(y = MeanPAD, colour = "Low altitude (pulse min=4)")) +
  # geom_line(data = dataLow_pulseMin4, aes(y = MeanPAD, colour = "Low altitude (pulse min=4)")) +
  # 
  # geom_point(data = dataLow_pulseMin12, aes(y = MeanPAD, colour = "Low altitude (pulse min=12)")) +
  # geom_line(data = dataLow_pulseMin12, aes(y = MeanPAD, colour = "Low altitude (pulse min=12)")) +
  # 
  # geom_point(data = dataLow_pulseMin20, aes(y = MeanPAD, colour = "Low altitude (pulse min=20)")) +
  # geom_line(data = dataLow_pulseMin20, aes(y = MeanPAD, colour = "Low altitude (pulse min=20)")) +
  # 
  # geom_point(data = dataLow_pulseMin28, aes(y = MeanPAD, colour = "Low altitude (pulse min=28)")) +
  # geom_line(data = dataLow_pulseMin28, aes(y = MeanPAD, colour = "Low altitude (pulse min=28)")) +
# 
# geom_point(data = dataLow_pulseMin44, aes(y = MeanPAD, colour = "Low altitude (pulse min=44)")) +
# geom_line(data = dataLow_pulseMin44, aes(y = MeanPAD, colour = "Low altitude (pulse min=44)")) +

scale_colour_manual(values = c("High altitude - 2m" = "blue",
                                 "Low altitude - 2m" = "#56B4E9",
                                 "UAV - 2m" = "#E69F00",
                                 "UAV - 1m" = "#F0E442"
                               # "Low altitude (pulse min=4)" = "green",
                               # "Low altitude (pulse min=12)" = "yellow",
                               # "Low altitude (pulse min=20)" = "orange",
                               # "Low altitude (pulse min=28)" = "darkred",
                               # "Low altitude (pulse min=44)" = "black"
                               )) +

  ggtitle(Title) +
  labs(y="Average PAD", x="Absolute Tree Height (m)", color = "LiDAR acquisition") +
  theme_minimal() +
  coord_flip() #+ # coordonnées inversées au départ pour que la ligne suive la hauteur au sol et non le PAD
# geom_errorbar(aes(ymin=MinPAD, ymax=MaxPAD), width=.2)#+ 
# options(repr.plot.width=8, repr.plot.height=15) # higher height

ggsave(paste(Title,".png", sep=''),
       path = "D:/Mes Donnees/PhD/Figures/lidar/Voxélisation/PAD_profil/Intensity_2m",
       width = 18, height = 20, units = "cm", dpi=800, bg="white")
```

# Plot extinction profiles
nbr de pulses qui traversent (1- ce qui est revenu)
```{r}
dataLow %>% 
  ggplot(aes(x= ground_distance_disc, y= MeanNbsampling)) +
  xlim(0,55) +
  geom_point(data = dataHigh, aes(x = ground_distance_disc, y = MeanNbsampling, colour = "High altitude - 2m")) +
  geom_line(data = dataHigh, aes(x = ground_distance_disc, y = MeanNbsampling, colour = "High altitude - 2m")) +
  
  geom_point(data = dataLow, aes(x = ground_distance_disc, y = MeanNbsampling, colour = "Low altitude - 2m")) +
  geom_line(data = dataLow, aes(x = ground_distance_disc, y = MeanNbsampling, colour = "Low altitude - 2m")) +
  
  geom_point(data = dataUAV2m, aes(x = ground_distance_disc, y = MeanNbsampling, colour = "UAV - 2m")) +
  geom_line(data = dataUAV2m, aes(x = ground_distance_disc, y = MeanNbsampling, colour = "UAV - 2m")) +
  
  # geom_point(data = dataUAV1m, aes(x = ground_distance_disc, y = MeanNbsampling, colour = "UAV - 1m")) +
  # geom_line(data = dataUAV1m, aes(x = ground_distance_disc, y = MeanNbsampling, colour = "UAV - 1m")) +
  
  scale_colour_manual(values = c("High altitude - 2m" = "blue",
                                 "Low altitude - 2m" = "#56B4E9",
                                 # "UAV - 1m" = "#F0E442"
                                 "UAV - 2m" = "#E69F00")) +
  theme_minimal() +
  ggtitle("P16 - 2023 - 4ha + buffer - extinction profile (intensity)") +
  labs(y="Number of through pulses", x="Absolute Tree Height", color = "LiDAR acquisition") +
  # scale_y_continuous(breaks = seq(0, max(dataUAV2m$MeanNbsampling), by=200))+
  # scale_x_continuous(breaks = seq(0, max(50), by=2))+
  coord_flip() #+
# geom_errorbar(aes(ymin=MeanNbsampling-SdNbsampling, ymax=MeanNbsampling+SdNbsampling), width=.2)
#   geom_errorbar(aes(ymin=MinNbsampling, ymax=MaxNbsampling), width=.2)

ggsave("ALS2023_P16_4ha_ALSvsUAV_nbSampling_mean_intensity.png",
       path = "D:/Mes Donnees/PhD/Figures/lidar/Voxélisation/nbSampling_profil/Intensity_2m",
       width = 18, height = 20, units = "cm", dpi=800, bg="white")
```
