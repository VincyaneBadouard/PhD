---
title: "Previousversion"
author: "Vincyane"
date: "`r Sys.Date()`"
output: html_document
---

# Pour UAV, crop vox and remove drone path
```{r}
VX <- readVoxelSpace(
  # "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/AMAPVox/Intensity_2m/P16_2023_UAV_4ha_buffer_intensity2m.vox"
  "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/AMAPVox/Intensity_1m/P16_2023_UAV_4ha_buffer_intensity1m.vox"
)
# View(VX@data)
# AMAPVox::plot(VX, variable.name = "ground_distance") 
```

```{r}
# i, j, k = index not coordinates
VX@data[, c("x", "y", "z") := getPosition(VX)[, .(x, y, z)]]
# range(VX@data$x) ; range(VX@data$y)

VX@data <- VX@data[x>=(-90) & x<=190 & y<=190,][z<66,]

# I <- range(VX@data[x>=(-90) & x<=190 & y<=190,][z<66,i]) # 1m: 61 340 ; 2m: 31 170
# J <- range(VX@data[x>=(-90) & x<=190 & y<=190,][z<66,j]) # 1m:  0 340 ; 2m: 0 170
# K <- range(VX@data[x>=(-90) & x<=190 & y<=190,][z<66,k]) # 1m:  0 66 ; 2m: 0 33

# VX <- crop(VX, imin = I[1], imax = I[2], jmin = J[1], jmax = J[2], kmin = K[1], kmax = K[2]) 

range(VX@data$z)

# prod(VX@header$dim) == nrow(VX@data) # doit etre cohérent

AMAPVox::plot(VX, variable.name = "ground_distance") 
AMAPVox::plot(VX, variable.name = "nbSampling") 

VX20 <- VX
VX20@data <- VX20@data[nbSampling < 20,]
AMAPVox::plot(VX20, variable.name = "nbSampling")
```

```{r}
writeVoxelSpace(VX, 
                # "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/AMAPVox/Intensity_2m/P16_2023_UAV_4ha_buffer_intensity2m_crop.vox"
                "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/AMAPVox/Intensity_1m/P16_2023_UAV_4ha_buffer_intensity1m_crop.vox"
)
```

# For UAV, merge UAV and ALS for a complete buffer
```{r}
library(AMAPVox); library(sf) ; library(tidyverse) ; library(data.table)
VX <- readVoxelSpace(
  # "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/AMAPVox/Intensity_2m/P16_2023_UAV_4ha_buffer_PadHLE_intensity2m.vox"
  "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/AMAPVox/Intensity_1m/P16_2023_UAV_4ha_buffer_PadHLE_intensity1m.vox"
)
# View(VX@data)
```

## Crop vox to 4ha
```{r}
vx <- VX@data

vx[, c("X", "Y", "Z") := getPosition(VX)[, .(x, y, z)]]

# Lecture matrice de transformation
VOP <- as.matrix(read.table("//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/VOP_P16_9ha.txt"))

Relativ2UTM <- function(data, VOP){
  # Apply inverse of VOP matrix to convert back to UTM
  xyz <- tcrossprod(as.matrix(data[, .(X, Y, Z, c=1)]), solve(VOP))
  data[, `:=`(Xutm = xyz[, 1], Yutm = xyz[, 2], Zutm = xyz[, 3])]
  
  data <- unique(data)
  return(data)
}

vxUTM <- Relativ2UTM(vx, VOP)

zone <- terra::vect("D:/Mes Donnees/PhD/SIG_data/Understory-ALT/Parcelles_Understory.shp") # buffer plus grand pour éviter les effets de bords lors de la voxélisation
zone <- st_as_sf(zone) # as sf object
zone <- st_set_crs(zone, 2972)

Crop <- function(data, zone){
  datasf <- st_as_sf(data, coords = c('Xutm','Yutm'))
  datasf <- st_set_crs(datasf, terra::crs(zone))
  datacrop <- st_intersection(datasf, zone)
  # XY <- st_coordinates(datacrop) # stock coordinates
  # colnames(XY) <- c("Xutm", "Yutm") 
  # st_geometry(datacrop) <- NULL # no more sf object
  # datacrop <- cbind(datacrop, XY) # bind XY coord
  return(datacrop)
}

vxUTM_crop <- Crop(vxUTM, zone)

ggplot() +
  geom_sf(data = vxUTM_crop, col="blue") +
  theme_classic() +
  geom_sf(data = sf::st_cast(zone, "LINESTRING"), col ="green")

st_geometry(vxUTM_crop) <- NULL

VX@data <- setDT(vxUTM_crop)
```

## Merge UAV and ALS buffer
```{r}
VXals_0 <- readVoxelSpace(
  # "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/HighAltitudeFlight/Intensity_2m/P16_2023_4ha_buffer_HighAlt_PadHLE_intensity2m.vox"
  "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/HighAltitudeFlight/Intensity_1m/P16_2023_4ha_buffer_HighAlt_PadHLE_intensity1m.vox"
)
```

# Replace i,j,k of UAV (plus besoin)
```{r}
# VX@header$mincorner;
# getPosition(VXals_0)[x>(-49)& x<(-48) & y>(-49)& y<(-48) & z<1][, .(i,j,k)]
# 
# VXals_0@data[, c("x", "y", "z") := getPosition(VXals_0)[, .(x, y, z)]]
# 
# VXals_0@data[x>(-49)& x<(-48) & y>(-49)& y<(-48) & z<1, .(i,j,k)]
# 
# VX@data[, `:=`(i = i+51, j = j+51)]
# # VX@header <- VXals@header
# 
# plot(VX)
# VX@data[, .(x,y,z,i,j,k)]
```

# Crop ALS (plus besoin)
```{r}
# rm(vx, vxalsUTM, vxUTM, vxUTM_crop, Crop); gc()
# 
# VXals <- VXals_0
# 
# vxals <- VXals@data
# 
# vxals[, c("X", "Y", "Z") := getPosition(VXals)[, .(x, y, z)]]
# 
# vxalsUTM <- Relativ2UTM(vxals, VOP)
# 
# vxalsUTMsf <- st_as_sf(vxalsUTM, coords = c('Xutm','Yutm'))
# vxalsUTMsf <- st_set_crs(vxalsUTMsf, terra::crs(zone))
# vxals_cut <- st_difference(vxalsUTMsf, st_union(zone)) # enlever les 4ha
# 
# rm(vx, vxals,vxalsUTM, vxalsUTMsf, vxUTM, vxUTM_crop, Crop, Relativ2UTM, VOP); gc()
# 
# # ggplot() + 
# #   geom_sf(data = vxals_cut, col="blue") +
# #   theme_classic() +
# #   geom_sf(data = sf::st_cast(zone, "LINESTRING"), col ="green")
# 
# st_geometry(vxals_cut) <- NULL
# 
# VXals@data <- setDT(vxals_cut)
# 
# rm(vxals_cut,zone); gc()
```


# Merge ALS and UAV 
```{r}
VXals <- VXals_0

VXals@data <- anti_join(VXals_0@data, VX@data, by = c("i", "j", "k")) # x, y, z ça ne marche pas
plot(VXals)

VX_merge <- VXals_0
VX_merge@data <- rbind(VXals@data, VX@data, fill=T)

plot(VX_merge)

prod(VX_merge@header$dim) == nrow(VX_merge@data) # doit etre cohérent 
# nrow(VXals_0@data) # 2100852
# nrow(VXals@data) # 1760852
# nrow(VX@data) # 340000
#  # 1580852
# nrow(VXals@data) + nrow(VX@data)
```


```{r}
writeVoxelSpace(VX_merge, 
                # "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/AMAPVox/Intensity_2m/P16_2023_UAV_4ha_bufferALS_PadHLE_intensity2m.vox"
  "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/AMAPVox/Intensity_1m/P16_2023_UAV_4ha_bufferALS_PadHLE_intensity1m.vox"
)
```

