---
title: "Correct Hovermap Laz files - Recode echoes and gpstime"
author: "Vincyane Badouard"
date: "`r Sys.Date()`"
output: pdf_document
---
Source : à partir du script de Grégoire Vincent.

To solve:
- NumberOfReturns are not populated (all = 0)!!
- ReturnNumber not coded by increasing distance!!
- gpstime are not unique


```{r, include = F, packages}
library(lidR)
library(data.table)
library(parallel)
library(foreach)
```

Raw UAV LiDAR data : 
//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/P16_C19C20/Output_laz1_4.laz
//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/P16_C14C15/Output_laz1_4.laz

# Need to split for instance by gpstime (per mn) to reduce size of file
data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/P16_C14C15/Output_laz1_4.laz -cores 4 -by_gps_time_interval 60 -odir //amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/P16_C14C15/Split -odix _split -o FullDensity.laz

## LAStool function
```{r}
rm(list=ls())
gc()  # Remove Garbage collection

# Define the path for lastools executables
LAStoolsDir =  "D:/Program/LAStools/bin/" # "C:/Users/SPARE-N219/Desktop/PhD/"

# Define the R function that calls lastools executables
LAStool <- function(tool, inputFile, ...){
  cmd = paste(paste(LAStoolsDir, tool, sep=''), '-i', inputFile , ...)
  cat(cmd)
  system(cmd)
  return(cmd)
}
```

## In & output
```{r}
# Define the directory
cloudPath <- 
  "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/P16_C14C15/"
  # "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/P16_C19C20/"
  # "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/AMAPVox/LAZ/"

# Define las/laz files to be processed
inFiles = paste(cloudPath, 'Output_Aura_Raw_laz1_4.laz', sep ='') # "P16_2023_UAV_4ha_buffer_intensitycor_lastools.laz"
outFile = "UAV.laz" # "FullDensity.laz"

# Define output directory (and creates it ... if doesn't exist)
outDir = paste(cloudPath, 'Split2', sep ='')
dir.create(outDir) # , showWarnings = F (pas le droit de le faire dans le serveur safe)
```

## Split files
```{r}
# Call the lastools function
cores <- detectCores()

LASrun <- LAStool('lassplit64', inFiles, # input
                  '-cores', cores,
                  '-by_gps_time_interval 60', # split points into intervals of 60 seconds
                  '-odir', outDir, # output folder
                  '-odix _split',
                  '-unique', # il y a des dupliqués
                  '-o', outFile # output
)

lof <- dir(outDir, full.names=T) # list files in the named directory
```

# For each file correct the NumberOfReturns and the ReturnNumber (12 min)
```{r}
gc(reset = TRUE)  # Remove Garbage collection

# lof <- dir(outDir, full.names=T) # list files in the named directory Z:/users/VincyaneBadouard

cores <- 2

## Parallelisation by file

# Create clusters
cl <- parallel::makeCluster(cores)
doSNOW::registerDoSNOW(cl)

# Progressbar
if(interactive()) pb <- txtProgressBar(max = length(lof), style = 3) # if(interactive()) pour qu’elles n’apparaissent pas dans les documents markdown 
progress <- function(n) if(interactive()) setTxtProgressBar(pb, n)
opts <- list(progress = progress)

# The loop
foreach::foreach(
  f=1:length(lof), 
  .packages = c("data.table","lidR"), .options.snow = opts
) %dopar% {
  # f=13 # to debug
  # print(f) # to debug
  
  options(digits = 22)
  
  # range(lasf@data$gpstime) ; lasf@data$gpstime[1:10] ; View(lasf@data)
  lasf <- readLAS(lof[f]) # lof[f] Laz # paste(cloudPath, 'Output_subsampled_laz1_4.laz', sep ='') # decimé
  
  lasf@data <- setorder(lasf@data, gpstime,Ring,ReturnNumber) 
  
  lasf@data[,`:=`(X = round(X,digits = 3), Y = round(Y,digits = 3), Z = round(Z,digits = 3))] # if not there are duplicated and so more than 3 echoes
  
  lasf@data <- lasf@data[!duplicated(lasf@data[,c('X','Y','Z')]),]
  
  # Get NumberOfReturns ---------------------------------------------------------
  # Number of pulses of the same ring and gpstime
  NoR <- lasf@data[,.N, by = c("gpstime","Ring")] # number of rows of the same ring and gpstime
  lasf@data <- merge(lasf@data, NoR, by = c("gpstime","Ring"))
  lasf@data$NumberOfReturns <- NULL # remove the initial column
  names(lasf@data)[which(names(lasf@data) == "N")] <- "NumberOfReturns" # rename the new column
  lasf@data[, NumberOfReturns := as.integer(NumberOfReturns)]
  # View(lasf@data)
  
  # Get ReturnNumber ------------------------------------------------------------
  # Returns coded by increasing distance
  lasf@data$ReturnNumber <- NULL # remove the initial column
  # lasf@data[, ReturnNumber := as.integer(frank(Range)), by = .(gpstime, Ring)] # ranking
  lasf@data[order(Range), ReturnNumber := 1L:.N, by = .(gpstime, Ring)]
  lasf@data[, ReturnNumber := as.integer(ReturnNumber)]
  # View(lasf@data)
  
  # Write the modified dataset
  writeLAS(lasf,lof[f]) # replace by the corrected file in the folder
  
  gc()  # Remove Garbage collection
  
} # loop end for each file

# close the progressbar
close(pb)
# close the cluster
stopCluster(cl)

```

# Checks
```{r}
lof <- dir(outDir, full.names=T) # list files in the named directory

# Loop for each file
for (f in 1:length(lof))
{
  print(f)
  lasf <- readLAS(lof[f]) # Laz
  # lasf@data <- setDT(lasf@data) #[1:1000]
  # options(digits = 22) ; View(lasf@data)
  
  
  # 
  # i= 1
  # lasf@data[Ring==i,.(ReturnNumber, NumberOfReturns, Range), by = .(gpstime, Ring)][order(gpstime, Ring)]
  
  # != 0
  print(paste("ReturnNumber != 0:", all(lasf@data[,ReturnNumber] != 0)))
  print(paste("NumberOfReturns != 0:", all(lasf@data[,NumberOfReturns] != 0)))
  print(paste("Maximum NumberOfReturns:", max(lasf@data$NumberOfReturns))) # 3 echoes max in Hovermap
  print(paste("ReturnNumber <= NumberOfReturns:", all(lasf@data[,ReturnNumber <= NumberOfReturns])))
  
  # by ring-gpstime, ReturnNumber = c(1:NumberOfReturns)
  # lasf@data <- unique(setorder(lasf@data, gpstime,Ring,ReturnNumber))
  
  # lasf@data[, .(test = all(ReturnNumber == c(1L:NumberOfReturns))), by = .(gpstime, Ring)][test!=TRUE]
  # lasf@data[gpstime== 1697736323.571918487549 & Ring ==26]
  
  # their range are in the increasing order
  # lasf@data[,.(!is.unsorted(Range)), by = .(gpstime, Ring)][V1!=TRUE]
  # lasf@data[gpstime== 1697733194.045943498611 & Ring ==26]
  
}
```

# Correct time stamp (5 min)
temps gps + 1 microseconde * n° du ring
**!si à refaire tourner, repartir des données brutes sinon le gpstime est modifié plusieurs fois!**
```{r}
gc(reset = TRUE)  # Remove Garbage collection

lof <- dir(outDir, full.names=T) # list files in the named directory 

cores <- 2 # more is to much for my RAM

## Parallelisation by file

# Create clusters
cl <- parallel::makeCluster(cores)
doSNOW::registerDoSNOW(cl)

# Progressbar
if(interactive()) pb <- txtProgressBar(max = length(lof), style = 3) # if(interactive()) pour qu’elles n’apparaissent pas dans les documents markdown 
progress <- function(n) if(interactive()) setTxtProgressBar(pb, n)
opts <- list(progress = progress)

# The loop
foreach::foreach(
  f=1:length(lof), 
  .packages = c("data.table","lidR"), .options.snow = opts
) %dopar% {
  
  lasf <- readLAS(lof[f]) # Laz
  
  lasf@data$gpstime <- lasf@data$gpstime +(10^-6) * lasf@data$Ring

  # Write the modified dataset
  writeLAS(lasf,lof[f]) # replace by the corrected file in the folder
  
  gc()  # Remove Garbage collection
  
} # loop end for each file

# close the progressbar
close(pb)
# close the cluster
stopCluster(cl)
```

# Re-check
```{r}
lof <- dir(outDir, full.names=T) # list files in the named directory

# Loop for each file
for (f in 1:length(lof))
{
  print(f)
  lasf <- readLAS(lof[f]) # Laz
  # lasf@data <- setDT(lasf@data) #[1:1000]
  # options(digits = 22) ; View(lasf@data)
  
  
  # 
  # i= 1
  # lasf@data[Ring==i,.(ReturnNumber, NumberOfReturns, Range), by = .(gpstime, Ring)][order(gpstime, Ring)]
  
  # != 0
  print(paste("ReturnNumber != 0:", all(lasf@data[,ReturnNumber] != 0)))
  print(paste("NumberOfReturns != 0:", all(lasf@data[,NumberOfReturns] != 0)))
  print(paste("Maximum NumberOfReturns:", max(lasf@data$NumberOfReturns))) # 3 echoes max in Hovermap
  print(paste("ReturnNumber <= NumberOfReturns:", all(lasf@data[,ReturnNumber <= NumberOfReturns])))
  
  # by ring-gpstime, ReturnNumber = c(1:NumberOfReturns)
  # lasf@data <- unique(setorder(lasf@data, gpstime,Ring,ReturnNumber))
  
  # lasf@data[, .(test = all(ReturnNumber == c(1L:NumberOfReturns))), by = .(gpstime, Ring)][test!=TRUE]
  # lasf@data[gpstime== 1697736323.571918487549 & Ring ==26]
  
  # their range are in the increasing order
  # lasf@data[,.(!is.unsorted(Range)), by = .(gpstime, Ring)][V1!=TRUE]
  # lasf@data[gpstime== 1697733194.045943498611 & Ring ==26]
  
}
```

# Merge files once corrected
```{r}
# table(lasf@data$NumberOfReturns, lasf@data$ReturnNumber)
# hist(lasf@data$Intensity, breaks=1000)
# hist(lasf@data$Range, breaks=1000)
# plot(lasf)

# Define the directory for the ALS project
gc()  # Remove Garbage collection

inFiles <- paste(outDir, '/*.laz', sep='') # files corrected
outFile <- "Returns_and_gpstime_corrected.laz"

LASrun <- LAStool('lasmerge64', inFiles,
                  '-odir', cloudPath,
                  # '-odix _cor',
                  '-o', outFile
)
```
