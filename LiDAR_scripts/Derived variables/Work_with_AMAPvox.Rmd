---
title: "Work_with_AMAPvox"
author: "Vincyane Badouard"
date: "`r Sys.Date()`"
output: pdf_document
---

https://amapvox.org/

Le principe est d’utiliser le LiDAR pour reconstruire en 3D la canopée forestière en représentant au mieux les caractéristiques de transmittance locale de la végétation puis de simuler à partir de cette maquette et d’un modèle d’ensoleillement la quantité relative de lumière disponible en tout point de la canopée.


# Install AMAPVox
V2.2 : //amap-data.cirad.fr/work\users\PhilippeVerley\amapvox\nightly-build\AMAPVox-2.2.0-windows
```{r}
# install "remotes" package if not already installed
if (!any(grepl("remotes", rownames(installed.packages())))) install.packages("remotes")
# install latest stable version from source
remotes::install_github('umr-amap/AMAPVox')
```

# Packages
```{r, include = F}
library(tidyverse)
library(lidR)
library(data.table)
library(rgl) # visulaisation 3D
library(terra)
library(raster)
library(lidR)
library(tidyterra)
library(sf)
```

# Load points cloud
ctg : catalog of laz files
```{r}
# Si en dalles :
ST <- readLAScatalog(folder = "D:/Mes Donnees/PhD/Lidar", filter = "keep") # las catalog. filter only 1st returns

# Si 1 fichier
ST <- readLAS("//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/HighAltitudeFlight/HighFlight_alt4ha_buff100m_2023_RefAsInt.laz")
# "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/lowAltitudeFlight/LowFlight_alt4ha_buff100m_2023_RefAsInt.laz"
# LowFlight_alt4ha_buff100m_2023.laz
ST <- readLAS("//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/HighAltitudeFlight/P16_2023_4ha_HighAlt_buffer.laz")


crs(ST) # no crs
ST <- st_set_crs(ST, 2972) # attribuer le dernier crs
lidR::crs(ST)

plot(ST)
```

# Extraire la zone d'intéret dont buffer (données classifiées dallées)
Ne garder que la zone d'intéret dans le nuage de point, en le clipant sur un fichier vecteur (polygone) de la zone d'intéret (ROI), si possible sous forme rectangulaire stricte.

ROI : Region of Interest
```{r, create ROI}
# Region of Interest (ROI)
ROI <- vect("//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2022/Plot16_4ha_buffer100m.shp") # interest zone + 100m buffer
plot(ROI)
class(ROI) # SpatVector (terra)

ROI <- st_as_sf(ROI) # as sf object
ROI <- st_set_crs(ROI, 2972) # attribuer le dernier crs

# plot(PC@data, )
# plot(ROI, add=T)
```

# Clip the point cloud in region of interest
```{r, crop laz}
PC <- lidR::clip_roi(las = ST, geometry = ROI) # très long
PC 
plot(PC)

## For 1 file
str(PC) # List of 4 las

# Join the 4 las if there are different of each others
rm(buffer, ST)
gc()
# usethis::edit_r_environ()
PCall <- rbind(PC[[1]], PC[[2]], PC[[3]], PC[[4]])

# or if only the first is not empty
PC <- PC[[1]]
# lidR::plot(PC) 

# Enlever le bruit (sous sol et au dessus canopée)
table(PC@data$Classification) # 7 = bruit, 2 = sol, veg = 3,4,5
PC@data <- PC@data[Classification != 7,]
lidR::plot(PC) 
```

# Crop the DEM in region of interest
```{r, crop DEM}
ROI <- vect("//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2022/Plot16_4ha_buffer101m.shp") # buffer plus grand pour éviter les effets de bords lors de la voxélisation
ROI <- st_as_sf(ROI) # as sf object
ROI <- st_set_crs(ROI, 2972) # crs

# Modèle numérique de terrain
# //amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2022/mnt_roi36ha_1m.asc""
mnt <- rast("//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/HighAltitudeFlight/PARACOU2023_DTM_1m.tif")
# "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/lowAltitudeFlight/dtm2023.asc"
ggplot() + 
  geom_spatraster(data = mnt, aes(fill = MNT_0.5m_IRD_500m_Paracou_284000_579500)) + # mnt_roi36ha_1m # dtm2023
  scale_fill_gradientn(name = "Elevation (m)",
                       colors = terrain.colors(30, rev=T),
                       na.value="white") +
  geom_sf(data = sf::st_cast(ROI, "LINESTRING"))

crs(mnt) <- crs(ROI) 
mntROI <- raster::mask(mnt,ROI)
mntROI <- raster::crop(mntROI,ROI)
mntROI;ROI;ST
plot(mntROI)
ggplot() + 
  geom_spatraster(data = mntROI, aes(fill = MNT_0.5m_IRD_500m_Paracou_284000_579500)) + # mnt_roi36ha_1m # dtm2023
  scale_fill_gradientn(name = "Elevation (m)",
                       colors = terrain.colors(30, rev=T),
                       na.value="white") +
  geom_sf(data = sf::st_cast(ROI, "LINESTRING"))

writeRaster(raster(mntROI),"//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/HighAltitudeFlight/dtm2023_4ha_HighAlt_buffer.asc", format="ascii", overwrite=T)
# "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/lowAltitudeFlight/dtm2023_4ha_buffer.asc"
# "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2022/dtm2022_4ha_buffer.asc"
```

# Read, bind and rewrite the trajectory files in the folder
```{r , include = F}
# if multiple files :
trajfilenames <- list.files("//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2022/trajecto", pattern="*.txt", full.names=TRUE) # catch the name of all the files of the folder
df_list <- lapply(trajfilenames, fread) # read all the folder files
traj <- bind_rows(df_list)

# if one file :
path <- "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/trajecto/trajecto1000m.txt"
# "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2022/trajectory.txt"
  # "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/trajecto/trajecto500m.txt"
traj <- fread(path)
traj
plot3d(traj[,2:4], aspect=F) # plot the trajectory (x,y,z)
range(traj$x) # 283900.7434999999823049 317113.9602999999769963
range(traj$y) #  560039.9923999999882653 588274.3286999999545515

traj <- traj %>% 
  select(V1,V2,V3,V4) %>% 
  rename(time = V1) %>% 
  rename(X = V2) %>% 
  rename(Y = V3) %>% 
  rename(Z = V4) 
view(traj)

# Crop trajectory
options(digits=22)
range(traj$t) # 382365103.0212569832802 382378020.8453729748726
range(PC@data$gpstime) # 382366761.4412953257561 382376006.5801081061363
traj <- traj[t<=max(PC@data$gpstime) & t>=min(PC@data$gpstime),]

# Keep only points inside the polygon (faut pas faire ça)
# traj_sf <- st_as_sf(traj, coords = c("X","Y"))
# traj_sf <- st_set_crs(traj_sf, 2972)
# traj_crop <- sf::st_intersection(traj_sf, ROI)
# XY <- st_coordinates(traj_crop)
# st_geometry(traj_crop) <- NULL # no more sf object
# traj_crop <- cbind(traj_crop, XY) # bind XY coord
# setDT(setcolorder(traj_crop, c("time","X", "Y", "Z"))) # order col places
# traj_crop <- traj_crop[, c(1:7), with = FALSE]

# fwrite(traj_crop, "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2022/traj_crop.txt")

fwrite(traj, "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/HighAltitudeFlight/ALS_P16_2023_4ha_HighAlt_buffer_traj.txt")
# "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2022/ALS_P16_2022_4ha_buffer_traj.txt"
# "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/trajecto/ALS_P16_2023_traj.txt"
```

# Check points cloud data
```{r}

table(PC@data$NumberOfReturns) # 14 echos ALS 2023 LowAlt; 12 HighAlt
PC@data
range(PC$Z) # min et max de l'altitude: 4.19 65.74 m

plot(PC) 
```


# Classifier les points sol
```{r}
# Normaliser la hauteur du sol
PC_norm <- lidR::normalize_height(PC, mntROI) # applati le relief
plot(PC_norm) # sol plat
hist(PC_norm@data$Z)

# Classifier les points sol
PC_norm@data[(Z>(-0.2) & Z< 0.5), Classification := 2] 

table(PC_norm@data$Classification) # 7 = bruit, 2 = sol, vegetation = 0,3,4,5
# plot(PC_norm, color = "Classification") # trop long

# Dénormaliser la hauteur du sol
PC <- lidR::unnormalize_height(PC_norm) 
```

# Garder uniquement les points de végétation (pas nécessaire avant amapvox)
On enlève tout le sol, on garde que les tirs qui atteignent la végétation
```{r}
GP <- PC@data[(Classification==2 | Classification==7),] # Ground Points
GS <- PC@data[gpstime %in% GP$gpstime,] # temps gps des tirs dont l'echo est au sol
VP <- PC@data[!(gpstime %in% GP$gpstime),] # données aux temps gps uniquement des tirs qui n'ont pas touché le sol
# question : pq enlever tous les tirs pris en meme temps que les tirs ayant touché le sol, et pas juste enlever les données sol ?
rm(GP)
rm(GS)
```

# Calculer la moyenne de réflectance (appelée intensité) par écho (pas fait pour 2023)

On utilise la réflectance pour calculer l'intensité
en calculant la réflectance apparente en ratio (albedo)
= intensité qu'on va utiliser par la suite.

Réflectance (ou Albedo) = énergie lumineuse réfléchie/énergie lumineuse incidente

```{r}
anyNA(PC@data$Intensity) # 10748 62215
names(PC@data)

# Compute Intensity
PC@data$initial_intensity <- PC@data$Intensity


# Intensité = réflectance apparente en ratio (albedo)
PC@data[, Intensity := as.integer((10^(Reflectance/10))*100)] # Réflectance initialement en decibel (et selon une référence connue)
range(PC@data$Intensity) # 0.9817479 2228435149

PC_samp <- sample(1:dim(PC@data)[1], 2000) # just a sample to plot

# initial_intensity vs Intensity
plot(initial_intensity~Intensity, data = PC@data[PC_samp,])

PC@data$initial_intensity <- NULL

writeLAS(PC, "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/HighAltitudeFlight/P16_2023_4ha_HighAlt_buffer.laz")
# //amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/lowAltitudeFlight/P16_2023_4ha_buffer.laz
# "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2022/P16_2022_4ha_buffer.laz"
```

# Calculer la matrice de pondération des échos (matrice de poids) (pas la meilleur méthode)
```{r}
# Compute average intensity per Number Of Returns x Return Number (rang de l'écho)
# get max return number (variable!)

mx_rn=max(VP[,ReturnNumber]) # nbr max de retours

# VP$ReturnNumber=as.factor(VP$ReturnNumber)
# VP$NumberOfReturns=as.factor(VP$NumberOfReturns)
#mod1=lm(Intensity~NumberOfReturns:ReturnNumber, data=VP)
#mean1=allEffects(mod1)
#mat1=matrix((mean1[[1]]$fit),nrow=mx_rn, ncol=mx_rn)

mat1 <- matrix(data=NA, nrow=mx_rn, ncol=mx_rn) # matrice vide

#fill in mean intensities
for (i in 1:mx_rn){
  for (j in 1:i)
  {
    mat1[i,j] <- (mean(VP[NumberOfReturns==i & ReturnNumber==j,Intensity],
                       na.rm=T)) # moy des intensités retours par rang d'écho
  }
}

mat_rel1 <- mat1/rowSums(mat1, na.rm = T, dims = 1) # poids relatifs à chacun des échos tous tirs confondus     
# il faut une matrice carrée (même nbr de lignes et de colonnes) !!

# single=list(name=m, matrix=mat_rel1)
# len <- length(mat_list)
# mat_list[[len+1]] <- single


# Enregistrer cette matrice dans le dossier de travail
fwrite(mat_rel1, "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/WeightingMatrix.txt",
       sep= " ", na="NaN", row.names = F, col.names = F)
```

# Calcul de matrice de rotation (alignement N-S d’un bord de ROI)

Créer une matrice 'VOP'(Voxels Oriented Patches) (.txt).
Rotationer le nuage de points pour etre aligné avec la grille

script : **Create_VOP.Rmd**

# Compute the clearness index from the tower data

"clearness" est bien le clearness de la "littérature" scientifique et est utilisé dans la routine d'AMAPVox pour calculer : 

1/ l'éclairement total (le RG extraterrestre est recalculé à partir de la date, de l'heure et de la geolocalisation)
2/ la répartition rayonnement direct/diffus.

Il te faut donc bien reprendre les données  de rayonnement incident mesuré à la tour à Flux pour calculer l'évolution saisonnière de clearness index.

Clearness index = rapport entre l'irradiation solaire globale mesurée au niveau du sol G et sa contrepartie estimée au sommet de l'atmosphère Gext : k=G/Gext (Liu and Jordan, 1960).

Clearness index = global solar irradiance (données de la tour)/top of atmosphere (extraterrestrial radiation) (données de ref des satellites (site soda)

all on the same periode, and in the same unit

Method: https://www.fao.org/3/x0490e/x0490e07.htm#solar%20radiation
```{r}
# Load tower data
# Rg in MJ m^-2 day^-1 (megajoules per square metre and per day)
FluxTowerData2022 <- readr::read_delim("~/PhD/Lidar/GX-METEO+EDDY-2004-2022E - JOUR - NEW2023 - GV.csv", 
                                       delim = ";", escape_double = FALSE, trim_ws = TRUE)

FluxTowerData2022[FluxTowerData2022$Rg < (-999),]

FluxTowerData2022 <- FluxTowerData2022 %>% 
  filter(Year == 2022) %>% 
  filter(Rg > 0) %>%
  select(Year, 'Julian Day', Month, Rain, Rg) %>% # 365 days, 12 months
  mutate(Season = ifelse(Month  %in% c(7:11), # juill-nov = dry season
                         "Dry", "Wet"))

ggplot(FluxTowerData2022, aes(x = as.character(Month),y = Rain)) +
  geom_boxplot(aes(color = Season)) +
  labs(title="Rainfall over the seasons",
       x ="Month", y = "Rainfall (mm)")


# Compute extraterrestrial radiation per day (because unit it's per day)
G <- 0.0820 # solar constant (MJ m-2 min-1)
phi <- 5*(pi/180) # latitude (rad) 5° à Paracou
# J <- # Julian day


FluxTowerData2022 <- FluxTowerData2022 %>%
  mutate(d = 1+0.033*cos(((2*pi)/365)*`Julian Day`),#inverse relative distance Earth-Sun
         delta = 0.409*sin(((2*pi)/365)*`Julian Day`-1.39),  # solar decimation (rad)
         omega = acos(-tan(phi)*tan(delta)),         # sunset hour angle (rad) 1.527) 
         Re = ((24*60)/pi)*G*d*(omega*sin(phi)*sin(delta)+cos(phi)*cos(delta)*sin(omega))) # in MJ m^-2 day^-1

# Compute clearness for each day (because unit it's per day)
FluxTowerData2022 <- FluxTowerData2022 %>% 
  mutate(Clearness = Rg/Re)

# Compute clearness index for 1 year (2022)
Clearness_2022 <- mean(FluxTowerData2022$Clearness) # 0.46

# Compute clearness index for wet and dry season (2022)
ClearnessWet <- mean(FluxTowerData2022[FluxTowerData2022$Season=="Wet",]$Clearness) # 0.39
ClearnessDry <- mean(FluxTowerData2022[FluxTowerData2022$Season=="Dry",]$Clearness) # 0.55

ClearnessIndex <- data.frame(Clearness_2022 = Clearness_2022,
                             ClearnessWet = ClearnessWet,
                             ClearnessDry = ClearnessDry)

write.csv(ClearnessIndex, "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/ClearnessIndex.csv")
```



# AMAPVox
```{r}
library(AMAPVox)

# For the 1st time
AMAPVox::run(jvm.option = "-Xms16g") # pour allouer 16Go de RAM # 

AMAPVox::run(jvm.option = "-Xms16g", version = "1.10.4") # pour allouer 16Go de RAM # 

# Get the configuration file
xmlfile <- "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2022/P16_2022_4ha_buffer.xml"
# Run with the previous configuration file
AMAPVox::run(xml = xmlfile, jvm.option = "-Xms16g")

```

PAD = 2*attenuation

fct d'atténuation selon un modèle sphérique (orientation aléatoire des feuilles)

pad calculé dans le script de remplissage des voxels vides donc pas besoin de celui-ci

```{r}
VX <- readVoxelSpace("//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/HighAltitudeFlight/P16_2023_HighAlt_4ha_buffer.vox")
# "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/lowAltitudeFlight/P16_2023_LowAlt_4ha_buffer.vox"
AMAPVox::plot(VX, variable.name = "nbSampling") # fermer la fenetre de plot entre 2 plots
AMAPVox::plot(VX, variable.name = "ground_distance") # ground distance bizarre sur les cotes
VX1 <- VX
VX <- VX1
VX@data <- VX@data[!is.na(distLaser)]
AMAPVox::plot(VX, variable.name = "distLaser")

# 2.5 est la densité max de feuillage qui ait un sens biologique 
VX <- VX1
VX@data <- VX@data[!is.na(attenuation_FPL_biasedMLE) & attenuation_FPL_biasedMLE<2.5]
AMAPVox::plot(VX, variable.name = "attenuation_FPL_biasedMLE")  

VX <- VX1
VX@data <- VX@data[!is.na(attenuation_FPL_unbiasedMLE) & attenuation_FPL_unbiasedMLE<2.5 & attenuation_FPL_unbiasedMLE>0]
AMAPVox::plot(VX, variable.name = "attenuation_FPL_unbiasedMLE")
# FPL : une grande partie des valeurs aberrantes devrait disparaître après recalcul des zones faiblement échantillonnées à l'aide des voisins.

VX <- VX1
VX@data <- VX@data[!is.na(attenuation_PPL_MLE) & attenuation_PPL_MLE<2.5]
AMAPVox::plot(VX, variable.name = "attenuation_PPL_MLE") # ça a l'air mieux il y a une plus forte atténuation proche du sol, mais ça n'a pas l'air très graduel
# PPL : il faudrait préférablement  réduire les PPL de plus de 2.5 - qui correspondent à des valeurs aberrantes) à 2.5 - qui correspond à la densité max de feuillage qui ait un sens biologique et non 20 comme dans le cas présent 

# VX <- VX1
# VXdata <- VX@data
# 
# VX@data$PadBVtotal <- VX@data$attenuation_FPL_biasedMLE # pas corrigé le sous-échantillonage (pour bosser sur les voxels vides)
# 
# writeVoxelSpace(VX, "//amap-data.cirad.fr/work/users/VincyaneBadouard/ALS2023/AMAVox_output_PAD")

```

## Fill empty voxels
voir Fill_empty_voxels.Rmd

Certains voxels (en bas de canopée) ne sont pas échantillonnés du fait de l’occlusion des tirs LiDAR. Ces données manquantes ont été comblées en appliquant la **moyenne des valeurs de transmittance des 27 voisins les plus proches**.

## Generate light maps from a voxel space
On simule ensuite à l’aide d’AMAPVox des cartes de transmittance à différentes altitudes au-dessus du sol à l’aide du module transmittance light maps. 

script de traitement : lightMap_1m.xml
input : test1m_PadHLE.vox
output : lightMap_1m.txt

each = 2 m
height = 1, 10 m
direction number : 136 (pas calculé uniquement selon la verticale mais sur un hémisphère)
Plot rotation : pour prendre en compte la course du soleil : 17° à la louche mais à remesurer sur qgis
"Repetitve scene" si il n'y a pas de buffer mais pas ouf
Latitude de Paracou : 5°
Calendrier : sur une année et pour chaque saison de l’année d’acquisition des données LiDAR
 
Clearness index : voir section "Compute the clearness index from the tower data"

```{r}

AMAPVox::run()

path <- "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2022/AMAPvox/lightMap_1mAGL_2by2.txt"
# "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2022/P16_2022_4ha_buffer_Light_annual.txt"

Light <- fread(path, skip=10) # skip the 10 1st lines of header
Light <- Light[Y != "MEAN"] # enlever les 2 lignes mean
Light <- Light[, !c("V5"), with = FALSE] 
Light[, `:=`(X = as.numeric(X) , Y = as.numeric(Y))]

# Remove edges
Light <- Light[X<90 & X> -90 & Y<90 & Y> -90]

# Plot
lattice::levelplot(`Period 1` ~ X*Y, data = Light) # Transmittance
lattice::levelplot(Z~X*Y, data = Light) # Z = Altitude

ggplot() + 
  geom_raster(data = Light, aes(X, Y, fill = `Period 1`)) + 
  scale_fill_gradientn(name = "Light intensity (Transmittance)",
                       colors = terrain.colors(30, rev=T),
                       na.value="white") +
  ggtitle("Paracou P16 4ha - Light map 1m") +  
  coord_sf()
```

# Transformation des coordonnées relatives en UTM
On peut retrouver les cooordonnées UTM avec la VOP
```{r}
# Lecture matrice de transformation
path <- "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2022/AMAPvox/VOPPlotP16_4ha.txt"
  # "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2022/VOP_P16_9ha.txt"
VOP <- as.matrix(read.table(path))

# Apply inverse of VOP matrix to convert back to UTM
xyz <- tcrossprod(as.matrix(Light[, .(X, Y, Z, c=1)]), solve(VOP))
Light[, `:=`(Xutm = xyz[, 1], Yutm = xyz[, 2], Zalt = xyz[, 3])]

Light <- unique(Light)

buffer <- st_as_sf(vect("//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/Plot16_4ha_buffer.shp")) # interest zone with buffer
zone <- st_as_sf(vect("//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2022/Parcelles_Understory.shp")) # 4 carrés

ggplot() + 
  geom_point(data = Light, size = 1.28,
             aes(Xutm, Yutm, color = `Period 1`)) + 
  scale_color_gradientn(name = "Light intensity (Transmittance)",
                        colors = terrain.colors(30, rev=T),
                        na.value="white") +
 geom_sf(data = sf::st_cast(buffer, "LINESTRING")) + # buffer (to remove after)
 geom_sf(data = sf::st_cast(zone, "LINESTRING")) + # zone of interest
  ggtitle("Paracou P16 4ha - Light map 1m") +  
  coord_sf()

fwrite(Light, "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/P16_2022_4ha_buffer_Lightmap_annual_1m_UTM.txt",
       row.names = F, col.names = T)

write.csv(Light, "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/P16_2022_4ha_buffer_Lightmap_annual_1m_UTM.csv")
```

Amapvox peut générer des photos hémisphériques, des données LAI2200, et des cartes 3D de lumière.

# Positionner capteurs LAI2200 sur la carte de lumière dans AMAPvox

Tester différentes hauteurs permettra aussi de tester la disponibilité en lumière à l'endroit
où se trouve la couronne des arbres considérés.

```{r}
# LAI2200 <- read_csv("~/PhD/Light/LAI-2200/LAI2200_data_spatialised.csv") # spatialised LAI2200 sensors


```

