---
title: "Work_with_AMAPvox"
author: "Vincyane Badouard"
date: "`r Sys.Date()`"
output: pdf_document
---

https://amapvox.org/

# Install AMAPVox
```{r}
# install "remotes" package if not already installed
if (!any(grepl("remotes", rownames(installed.packages())))) install.packages("remotes")
# install latest stable version from source
remotes::install_github('umr-amap/AMAPVox')
```

# Packages
```{r, include = F}
library(tidyverse)
library(zoo) # permet de synchroniser temps gps et tirs
library(lidR)
library(data.table)
library(rgl) # visulaisation 3D
library(terra)
library(raster)
library(AMAPVox)
library(sf)
```

# Extraire la zone d'intéret (données classifiées dallées)
Ne garder que la zone d'intéret dans le nuage de point, en le clipant sur un fichier vecteur (polygone) de la zone d'intéret (ROI), si possible sous forme rectangulaire stricte.

ctg : catalog of laz files
ROI : Region of Interest
```{r}
ctg <- readLAScatalog(folder = "D:/Mes Donnees/PhD/Lidar", filter = "keep") # las catalog
# 4 carrés
crs(ctg) # no crs
plot(ctg)

ctg <- st_set_crs(ctg, 2972) # attribuer le dernier crs
crs(ctg)

# Region of Interest (ROI)
ROI <- vect("Z:/users/VincyaneBadouard/Lidar/ALS2022/Parcelles_Understory.shp") # 4 carrés
plot(ROI)
class(ROI) # SpatVector (terra)

ROI <- st_as_sf(ROI) # as sf object
ROI <- st_set_crs(ROI, 2972) # attribuer le dernier crs
crs(ROI)
plot(ROI)
# Clip the point cloud in region of interest
PC <- clip_roi(las = ctg, geometry = ROI) # très long
str(PC) # List of 4 las

# Join the 4 las
PC <- rbind(PC[[1]], PC[[2]], PC[[3]], PC[[4]])
lidR::plot(PC) 

# Enlever le bruit (sous sol et au dessus canopée)
table(PC@data$Classification) # 7 = bruit, 2 = sol, veg = 3,4,5
PC@data <- PC@data[Classification != 7,]
lidR::plot(PC) 

writeLAS(PC, "Z:/users/VincyaneBadouard/ALS2022/P16_2022_v2_4ha.laz")
```

# The point cloud path
```{r}
ALS_P16_2022_path <- "Z:/users/VincyaneBadouard/Lidar/ALS2022/P16_2022_dnz_4ha.laz"
```

# Import the points cloud
```{r}
ST <- readLAS(ALS_P16_2022_path)
table(ST@data$NumberOfReturns)
ST@data
range(ST$Z) # min et max de l'altitude: 8.82 - 67.13 m

plot(ST) # ya du bruit
```


# Read, bind and rewrite the trajectory files in the folder
```{r , include = F}
trajfilenames <- list.files("Z:/users/VincyaneBadouard/Lidar/ALS2022/trajecto", pattern="*.txt", full.names=TRUE) # catch the name of all the files of the folder

df_list <- lapply(trajfilenames, fread) # read all the folder files
ALS_P16_2022_traj <- bind_rows(df_list)

ALS_P16_2022_traj <- ALS_P16_2022_traj %>% 
  select(V1,V2,V3,V4) %>% 
  rename(time = V1) %>% 
  rename(X = V2) %>% 
  rename(Y = V3) %>% 
  rename(Z = V4) 
view(ALS_P16_2022_traj)

fwrite(ALS_P16_2022_traj, "Z:/users/VincyaneBadouard/Lidar/ALS2022/trajecto/ALS_P16_2022_traj.txt")
```

# Import the trajectory
```{r}
traj <- ALS_P16_2022_traj
traj 

plot3d(traj[,2:4]) # plot the trajectory (x,y,z)

options(digits=12)
```


# Nettoyer les points isolés avant AMAPVox
- statistical points removal (enlève les points isolés)
- autre méthode : dans un espace voxel selon densité de points
```{r}
table(ST@data$Classification)
ST@data <- ST@data[Classification != 7,] # enlever le bruit
plot(ST) # quasi plus de bruit
# Question : ça suffit ?
```

# Classifier les points sol
```{r}
ST <- PC
# Modèle numérique de terrain
mnt <- rast("Z:/users/VincyaneBadouard/Lidar/ALS2022/mnt_roi36ha_1m.asc")
plot(mnt)

# Normaliser la hauteur du sol
ST_norm <- lidR::normalize_height(ST, mnt) # applati le relief
plot(ST_norm)# sol plat
hist(ST_norm@data$Z)

# Classifier les points sol
ST_norm@data[(Z>(-0.2) & Z< 0.5), Classification := 2] 

table(ST_norm@data$Classification) # 7 = bruit, 2 = sol, vegetation = 0,3,4,5
# plot(ST_norm, color = "Classification") # trop long

# Dénormaliser la hauteur du sol
ST <- lidR::unnormalize_height(ST_norm) 
```

# Garder uniquement les points de végétation
On enlève tout le sol, on garde que les tirs qui atteignent la végétation
```{r}
GP <- ST@data[(Classification==2 | Classification==7),] # Ground Points
GS <- ST@data[gpstime %in% GP$gpstime,] # temps gps des tirs dont l'echo est au sol
VP <- ST@data[!(gpstime %in% GP$gpstime),] # données aux temps gps uniquement des tirs qui n'ont pas touché le sol
# question : pq enlever tous les tirs pris en meme temps que les tirs ayant touché le sol, et pas juste enlever les données sol ?
rm(GP)
rm(GS)
```

# Calculer la moyenne de réflectance (appelée intensité) par écho

On utilise la réflectance pour calculer l'intensité
en calculant la réflectance apparente en ratio (albedo)
= intensité qu'on va utiliser par la suite.

Réflectance (ou Albedo) = énergie lumineuse réfléchie/énergie lumineuse incidente

```{r}
# Compute Intensity
VP$initial_intensity <- VP$Intensity 

# Intensité = réflectance apparente en ratio (albedo)
VP$Intensity = 10^(VP$Reflectance/10) # Réflectance initialement en decibel (et selon une référence connue)


VP_samp <- sample(1:dim(VP)[1], 2000) # just a sample to plot

# initial_intensity vs Intensity
plot(initial_intensity~Intensity, data = VP[VP_samp,])

```

ARRETE LA
# Calculer la matrice de pondération des échos (matrice de poids)
finalement on ne considèrera que l’écho d’intensité max (MIR) ?
car cas d’interception partielle non détectée à courte distance
```{r}
# Compute average intensity per Number Of Returns x Return Number (rang de l'écho)
# get max return number (variable!)

mx_rn=max(VP[,ReturnNumber]) # nbr max de retours

# VP$ReturnNumber=as.factor(VP$ReturnNumber)
# VP$NumberOfReturns=as.factor(VP$NumberOfReturns)
#mod1=lm(Intensity~NumberOfReturns:ReturnNumber, data=VP)
#mean1=allEffects(mod1)
#mat1=matrix((mean1[[1]]$fit),nrow=mx_rn, ncol=mx_rn)

mat1 <- matrix(data=NA, nrow=mx_rn, ncol=mx_rn) # matrice vide

#fill in mean intensities
for (i in 1:mx_rn){
  for (j in 1:i)
  {
    mat1[i,j] <- (mean(VP[NumberOfReturns==i & ReturnNumber==j,Intensity],
                       na.rm=T)) # moy des intensités retours par rang d'écho
  }
}

mat_rel1 <- mat1/rowSums(mat1, na.rm = T, dims = 1) # poids relatifs à chacun des échos tous tirs confondus     
# il faut une matrice carrée (même nbr de lignes et de colonnes) !!

# single=list(name=m, matrix=mat_rel1)
# len <- length(mat_list)
# mat_list[[len+1]] <- single


# Enregistrer cette matrice dans le dossier de travail
fwrite(mat_rel1, "Z:/users/VincyaneBadouard/ALS2022/WeightingMatrix.txt",
       sep= " ", na="NaN", row.names = F, col.names = F)
```

# Calcul de matrice de rotation (alignement N-S d’un bord de ROI)
script : **Create_VOP.Rmd**
Utilise le fichier vecteur précédent (ROI),
créer une matrice 'VOP'(Voxels Oriented Patches) (.txt).

rotationer le nuage de points pour etre aligné avec la grille

pour calculer la matrice VOP on enlève les points sol

# AMAPVox
```{r}
# For the 1st time
AMAPVox::run()

# Get the configuration file
xmlfile <- "Z:/users/VincyaneBadouard/Lidar/ALS2022/AMAPvox/AMAPvox_config.xml"
# Run with the previous configuration file
AMAPVox::run(xml = xmlfile)

# run multiple configurations
AMAPVox::run(xml=c("cfg1.xml", "cfg2.xml"), nt=2)
```

PAD = 2*attenuation

fct d'atténuation selon un modèle sphérique (orientation aléatoire des feuilles)

pad calculé dans le script de remplissage des voxels vides donc pas besoin de celui-ci

```{r}
VX <- readVoxelSpace("Z:/users/VincyaneBadouard/Lidar/ALS2022/AMAPvox/AMAVox_output_test")
AMAPVox::plot(VX)
VX@data$PadBVtotal <- VX@data$attenuation_FPL_biasedMLE # pas corrigé le sous-échantillonage (pour bosser sur les voxels vides)

writeVoxelSpace(VX, "Z:/users/VincyaneBadouard/ALS2022/AMAVox_output_PAD")

```

## Fill empty voxels
voir Fill_empty_voxels.Rmd

voxel pas vu pas échantilloné (occlusion), pas de données, ou mal échantilloné (selon un seuil)
estimer selon le plus probable selon les besoins
qui ne sont pas des trouées, mais des voxels perdus dans le nuage végétal
(long)
Prendre en compte le voisinage en excluant les trouées

## Generate light maps from a voxel space
On simule ensuite à l’aide d’AMAPVox des cartes de transmittance à différentes altitudes au-dessus du sol à l’aide du module transmittance light maps. 

script de traitement : lightMap_1m.xml
input : test1m_PadHLE.vox

output : lightMap_1m.txt

each = 2 m
height = 1, 10 m
direction number : 136 (pas calculé uniquement selon la verticale mais sur un hémisphère)
plot rotation : pour prendre en compte la course du soleil : 17° à la louche mais à remesurer sur qgis
Repetitve scene si tu n'as pas de buffer mais pas ouf
latitude de Paracou 5°
calendrier : sur une année 
clearness coefficient : 0.5 rapport direct-diffus en gros à l'équateur (change au cours des saisons)
```{r}
# enlever les 2 lignes mean
# Light <- Light[Y != "MEAN"]
Light <- fread("Z:/users/VincyaneBadouard/Lidar/ALS2022/AMAPvox/lightMap_1mAGL_2by2.txt", skip=10, nrows = 20403)
Light <- Light[, !c("V5"), with = FALSE] 

# Remove edges
Light <- Light[X<90 & X> -90 & Y<90 & Y> -90]
# Plot
lattice::levelplot(`Period 1`~X*Y, data = Light) # Transmittance
lattice::levelplot(Z~X*Y, data = Light) # Z = Altitude

ggplot() + 
  geom_raster(data = Light, aes(X, Y, fill = `Period 1`)) + 
  scale_fill_gradientn(name = "Light intensity (Transmittance)",
                       colors = terrain.colors(30, rev=T),
                       na.value="white") +
  ggtitle("Paracou P16 4ha - Light map 1m") +  
  coord_sf()
```
# Transformation des coordonnées relatives en UTM
On peut retrouver les cooordonnées UTM avec la VOP

```{r}
# Lecture matrice de transformation
VOP <- as.matrix(read.table("Z:/users/VincyaneBadouard/Lidar/ALS2022/AMAPvox/VOPPlotP16_4ha.txt"))

# Apply inverse of VOP matrix to convert back to UTM
xyz <- tcrossprod(as.matrix(Light[, .(X, Y, Z, c=1)]), solve(VOP))
Light[, `:=`(Xutm = xyz[, 1], Yutm = xyz[, 2], Zalt = xyz[, 3])]

Light <- unique(Light)

ggplot() + 
  geom_point(data = Light, size = 1.28,
             aes(Xutm, Yutm, color = `Period 1`)) + 
   scale_color_gradientn(name = "Light intensity (Transmittance)",
                       colors = terrain.colors(30, rev=T),
                       na.value="white") +
  ggtitle("Paracou P16 4ha - Light map 1m") +  
  coord_sf()

fwrite(Light, "Z:/users/VincyaneBadouard/Lidar/ALS2022/AMAPvox/Paracou_P16 4ha_lightMap_1m_UTM.txt", 
            row.names = F, col.names = T)

write.csv(Light, "Z:/users/VincyaneBadouard/Lidar/ALS2022/AMAPvox/Paracou_P16 4ha_lightMap_1m_UTM.csv")
```

Amapvox peut générer des photos hémisphériques, des données LAI2200, et des cartes 3D de lumière ()

# Positionner capteurs LAI2200 sur la carte de lumière dans AMAPvox

```{r}

```

