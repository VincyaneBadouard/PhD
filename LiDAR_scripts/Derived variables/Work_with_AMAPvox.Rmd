---
title: "Work_with_AMAPvox"
author: "Vincyane Badouard"
date: "`r Sys.Date()`"
output: pdf_document
---

https://amapvox.org/

Le principe est d’utiliser le LiDAR pour reconstruire en 3D la canopée forestière en représentant au mieux les caractéristiques de transmittance locale de la végétation puis de simuler à partir de cette maquette et d’un modèle d’ensoleillement la quantité relative de lumière disponible en tout point de la canopée.


# Install AMAPVox
V2.2 : Z:\users\PhilippeVerley\amapvox\nightly-build\AMAPVox-2.2.0-windows
```{r}
# install "remotes" package if not already installed
if (!any(grepl("remotes", rownames(installed.packages())))) install.packages("remotes")
# install latest stable version from source
remotes::install_github('umr-amap/AMAPVox')
```

# Packages
```{r, include = F}
library(tidyverse)
library(lidR)
library(data.table)
library(rgl) # visulaisation 3D
library(terra)
library(raster)
library(lidR)
library(tidyterra)
library(AMAPVox)
library(sf)
```

# Load points cloud
ctg : catalog of laz files
```{r}
# Si en dalles :
ST <- readLAScatalog(folder = "D:/Mes Donnees/PhD/Lidar", filter = "keep") # las catalog

# Si 1 fichier
ST <- readLAS("Z:/users/VincyaneBadouard/Lidar/ALS2023/P16_bbx_buf100m.laz")

plot(ST)
crs(ST) # no crs
ST <- st_set_crs(ST, 2972) # attribuer le dernier crs
crs(ST)
```

# Extraire la zone d'intéret (données classifiées dallées)
Ne garder que la zone d'intéret dans le nuage de point, en le clipant sur un fichier vecteur (polygone) de la zone d'intéret (ROI), si possible sous forme rectangulaire stricte.

ROI : Region of Interest
```{r}
# Region of Interest (ROI)
ROI <- vect("Z:/users/VincyaneBadouard/Lidar/ALS2022/Parcelles_Understory.shp") # 4 carrés
plot(ROI)
class(ROI) # SpatVector (terra)
ROI <- st_as_sf(ROI) # as sf object
ROI <- st_set_crs(ROI, 2972) # attribuer le dernier crs
crs(ROI)
plot(ROI)

# Create a 100 m buffer around
st_crs(ROI)$units # in meter
buffer <- st_buffer(ROI, dist=100, endCapStyle = "SQUARE") %>% st_union() # the square doesn't works
plot(buffer)
plot(ROI, add=T)
ROI <- st_union(ROI, buffer)
plot(ROI)

st_write(ROI, "Z:/users/VincyaneBadouard/Lidar/ALS2023/Plot16_4ha_buffer.shp", driver = "ESRI Shapefile")  # create to a shapefile


# Clip the point cloud in region of interest
PC <- clip_roi(las = ST, geometry = ROI) # très long
str(PC) # List of 4 las

# Join the 4 las
PC <- rbind(PC[[1]], PC[[2]], PC[[3]], PC[[4]])
# or if only the first not empty
PC <- PC[[1]]
lidR::plot(PC) 

# Enlever le bruit (sous sol et au dessus canopée)
table(PC@data$Classification) # 7 = bruit, 2 = sol, veg = 3,4,5
PC@data <- PC@data[Classification != 7,]
lidR::plot(PC) 

writeLAS(PC, "Z:/users/VincyaneBadouard/Lidar/ALS2023/P16_2023_4ha_buffer.laz")

# Crop the DEM in region of interest
# Modèle numérique de terrain
mnt <- rast("Z:/users/VincyaneBadouard/Lidar/ALS2023/dtm2023.asc")
plot(mnt)
mntROI <- raster::crop(mnt,extent(ROI))
plot(mntROI)
ggplot() + 
  geom_spatraster(data = mntROI, aes(fill = dtm2023)) +
  scale_fill_gradientn(name = "Elevation (m)",
                       colors = terrain.colors(30, rev=T),
                       na.value="white") +
  geom_sf(data = sf::st_cast(ROI, "LINESTRING"))

writeRaster(raster(mntROI),"Z:/users/VincyaneBadouard/Lidar/ALS2023/dtm2023_4ha_buffer.asc", format="ascii")
```

# Read, bind and rewrite the trajectory files in the folder
```{r , include = F}
# if multiple files :
trajfilenames <- list.files("Z:/users/VincyaneBadouard/Lidar/ALS2022/trajecto", pattern="*.txt", full.names=TRUE) # catch the name of all the files of the folder
df_list <- lapply(trajfilenames, fread) # read all the folder files
ALS_P16_2023_traj <- bind_rows(df_list)

# if one file :
traj <- fread("Z:/users/VincyaneBadouard/Lidar/ALS2023/trajecto/trajecto500m.txt")
traj
plot3d(traj[,2:4], aspect=F) # plot the trajectory (x,y,z)
range(traj$x) # 283770.8 285719.1
range(traj$y) # 578263.8 586617.6

ALS_P16_2023_traj <- ALS_P16_2023_traj %>% 
  select(V1,V2,V3,V4) %>% 
  rename(time = V1) %>% 
  rename(X = V2) %>% 
  rename(Y = V3) %>% 
  rename(Z = V4) 
view(ALS_P16_2023_traj)

fwrite(ALS_P16_2023_traj, "Z:/users/VincyaneBadouard/Lidar/ALS2023/trajecto/ALS_P16_2023_traj.txt")
```

# Check points cloud data
```{r}
table(PC@data$NumberOfReturns) # 14 echos
PC@data
range(PC$Z) # min et max de l'altitude: 4.19 65.74 m

plot(PC) 
```


# Classifier les points sol
```{r}
# Normaliser la hauteur du sol
PC_norm <- lidR::normalize_height(PC, mntROI) # applati le relief
plot(PC_norm) # sol plat
hist(PC_norm@data$Z)

# Classifier les points sol
PC_norm@data[(Z>(-0.2) & Z< 0.5), Classification := 2] 

table(PC_norm@data$Classification) # 7 = bruit, 2 = sol, vegetation = 0,3,4,5
# plot(PC_norm, color = "Classification") # trop long

# Dénormaliser la hauteur du sol
PC <- lidR::unnormalize_height(PC_norm) 
```

# Garder uniquement les points de végétation
On enlève tout le sol, on garde que les tirs qui atteignent la végétation
```{r}
GP <- PC@data[(Classification==2 | Classification==7),] # Ground Points
GS <- PC@data[gpstime %in% GP$gpstime,] # temps gps des tirs dont l'echo est au sol
VP <- PC@data[!(gpstime %in% GP$gpstime),] # données aux temps gps uniquement des tirs qui n'ont pas touché le sol
# question : pq enlever tous les tirs pris en meme temps que les tirs ayant touché le sol, et pas juste enlever les données sol ?
rm(GP)
rm(GS)
```

# Calculer la moyenne de réflectance (appelée intensité) par écho (pas fait pour 2023)

On utilise la réflectance pour calculer l'intensité
en calculant la réflectance apparente en ratio (albedo)
= intensité qu'on va utiliser par la suite.

Réflectance (ou Albedo) = énergie lumineuse réfléchie/énergie lumineuse incidente

```{r}
# Compute Intensity
VP$initial_intensity <- VP$Intensity 

# Intensité = réflectance apparente en ratio (albedo)
VP$Intensity = 10^(VP$Reflectance/10) # Réflectance initialement en decibel (et selon une référence connue)


VP_samp <- sample(1:dim(VP)[1], 2000) # just a sample to plot

# initial_intensity vs Intensity
plot(initial_intensity~Intensity, data = VP[VP_samp,])

```

ARRETE LA
# Calculer la matrice de pondération des échos (matrice de poids) (pas fait pour 2023)
finalement on ne considèrera que l’écho d’intensité max (MIR) ?
car cas d’interception partielle non détectée à courte distance
```{r}
# Compute average intensity per Number Of Returns x Return Number (rang de l'écho)
# get max return number (variable!)

mx_rn=max(VP[,ReturnNumber]) # nbr max de retours

# VP$ReturnNumber=as.factor(VP$ReturnNumber)
# VP$NumberOfReturns=as.factor(VP$NumberOfReturns)
#mod1=lm(Intensity~NumberOfReturns:ReturnNumber, data=VP)
#mean1=allEffects(mod1)
#mat1=matrix((mean1[[1]]$fit),nrow=mx_rn, ncol=mx_rn)

mat1 <- matrix(data=NA, nrow=mx_rn, ncol=mx_rn) # matrice vide

#fill in mean intensities
for (i in 1:mx_rn){
  for (j in 1:i)
  {
    mat1[i,j] <- (mean(VP[NumberOfReturns==i & ReturnNumber==j,Intensity],
                       na.rm=T)) # moy des intensités retours par rang d'écho
  }
}

mat_rel1 <- mat1/rowSums(mat1, na.rm = T, dims = 1) # poids relatifs à chacun des échos tous tirs confondus     
# il faut une matrice carrée (même nbr de lignes et de colonnes) !!

# single=list(name=m, matrix=mat_rel1)
# len <- length(mat_list)
# mat_list[[len+1]] <- single


# Enregistrer cette matrice dans le dossier de travail
fwrite(mat_rel1, "Z:/users/VincyaneBadouard/Lidar/ALS2023/WeightingMatrix.txt",
       sep= " ", na="NaN", row.names = F, col.names = F)
```

# Calcul de matrice de rotation (alignement N-S d’un bord de ROI)

Créer une matrice 'VOP'(Voxels Oriented Patches) (.txt).
Rotationer le nuage de points pour etre aligné avec la grille

script : **Create_VOP.Rmd**

# Compute the clearness index from the tower data

"clearness" est bien le clearness de la "littérature" scientifique et est utilisé dans la routine d'AMAPVox pour calculer : 

1/ l'éclairement total (le RG extraterrestre est recalculé à partir de la date, de l'heure et de la geolocalisation)
2/ la répartition rayonnement direct/diffus.

Il te faut donc bien reprendre les données  de rayonnement incident mesuré à la tour à Flux pour calculer l'évolution saisonnière de clearness index.

Clearness index = rapport entre l'irradiation solaire globale mesurée au niveau du sol G et sa contrepartie estimée au sommet de l'atmosphère Gext : k=G/Gext (Liu and Jordan, 1960).

Clearness index = global solar irradiance (données de la tour)/top of atmosphere (extraterrestrial radiation) (données de ref des satellites (site soda)

all on the same periode, and in the same unit
```{r}
# Load tower data
# Rg in MJ m^-2 day^-1
FluxTowerData2022 <- readr::read_delim("~/PhD/Lidar/GX-METEO+EDDY-2004-2022E - JOUR - NEW2023 - GV.csv", 
                                delim = ";", escape_double = FALSE, trim_ws = TRUE)

FluxTowerData2022[FluxTowerData2022$Rg < (-999),]

FluxTowerData2022 <- FluxTowerData2022 %>% 
  filter(Year == 2022) %>% 
  filter(Rg > 0) %>%
  select(Year, 'Julian Day', Month, Rain, Rg) %>% # 365 days, 12 months
  mutate(Season = ifelse(Month  %in% c(7:11), # juill-nov = dry season
                         "Dry", "Wet"))

ggplot(FluxTowerData2022, aes(x = as.character(Month),y = Rain)) +
  geom_boxplot(aes(color = Season)) +
  labs(title="Rainfall over the seasons",
       x ="Month", y = "Rainfall (mm)")

GlobalRad <- sum(FluxTowerData2022$Rg) # 5402.89 MJ m^-2 day^-1
GlobalRadWet <- sum(FluxTowerData2022[FluxTowerData2022$Season=="Wet",]$Rg) # 2598.80
GlobalRadDry <- sum(FluxTowerData2022[FluxTowerData2022$Season=="Dry",]$Rg) # 2804.07


# Compute extraterrestrial radiation
G <- 0.0820 # solar constant (MJ m-2 min-1)
phi <- 5*(pi/180) # latitude (rad) 5° à Paracou
# J <- # Julian day
d <- 1+0.033*cos(((2*pi)/365)*J) #  inverse relative distance Earth-Sun
delta <- 0.409*sin(((2*pi)/365)*J-1.39)  # solar decimation (rad)
omega <- acos[-tan(phi)*tan(delta)] # sunset hour angle (rad) 1.527

ExtraRad <- ((24*60)/pi)*G*d[omega*sin(phi)*sin(delta)+cos(phi)*cos(delta)*sin(omega)]

rm(c(J,d,delta,omega))
# WET
# J <- # Julian day
d <- 1+0.033*cos(((2*pi)/365)*J) #  inverse relative distance Earth-Sun
delta <- 0.409*sin(((2*pi)/365)*J-1.39)  # solar decimation (rad)
omega <- acos[-tan(phi)*tan(delta)] # sunset hour angle (rad) 1.527
# ExtraRadWet <- ((24*60)/pi)*G*d[omega*sin(phi)*sin(delta)+cos(phi)*cos(delta)*sin(omega)]

rm(c(J,d,delta,omega))
# DRY
# J <- # Julian day
d <- 1+0.033*cos(((2*pi)/365)*J) #  inverse relative distance Earth-Sun
delta <- 0.409*sin(((2*pi)/365)*J-1.39)  # solar decimation (rad)
omega <- acos[-tan(phi)*tan(delta)] # sunset hour angle (rad) 1.527
# ExtraRadDry <- ((24*60)/pi)*G*d[omega*sin(phi)*sin(delta)+cos(phi)*cos(delta)*sin(omega)]


# Compute clearness index for 1 year (2022)
Clearness_2022 <- GlobalRad/ExtraRad

# Compute clearness index for wet and dry season (2022)
ClearnessWet <- GlobalRadWet/ExtraRadWet
ClearnessDry <- GlobalRadDry/ExtraRadDry
```




# AMAPVox
```{r}
# For the 1st time
AMAPVox::run()

# Get the configuration file
xmlfile <- "Z:/users/VincyaneBadouard/Lidar/ALS2023/AMAPvox/AMAPvox_config.xml"
# Run with the previous configuration file
AMAPVox::run(xml = xmlfile)

# run multiple configurations
AMAPVox::run(xml=c("cfg1.xml", "cfg2.xml"), nt=2)
```

PAD = 2*attenuation

fct d'atténuation selon un modèle sphérique (orientation aléatoire des feuilles)

pad calculé dans le script de remplissage des voxels vides donc pas besoin de celui-ci

```{r}
VX <- readVoxelSpace("Z:/users/VincyaneBadouard/Lidar/ALS2023/AMAPvox/AMAVox_output_test")
AMAPVox::plot(VX)
VX@data$PadBVtotal <- VX@data$attenuation_FPL_biasedMLE # pas corrigé le sous-échantillonage (pour bosser sur les voxels vides)

writeVoxelSpace(VX, "Z:/users/VincyaneBadouard/ALS2023/AMAVox_output_PAD")

```

## Fill empty voxels
voir Fill_empty_voxels.Rmd

Certains voxels (en bas de canopée) ne sont pas échantillonnés du fait de l’occlusion des tirs LiDAR. Ces données manquantes ont été comblées en appliquant la **moyenne des valeurs de transmittance des 26 voisins les plus proches**.

Voxel pas vu pas échantilloné (occlusion), pas de données, ou mal échantilloné (selon un seuil)
estimer selon le plus probable selon les besoins
qui ne sont pas des trouées, mais des voxels perdus dans le nuage végétal
(long)
Prendre en compte le voisinage en excluant les trouées

## Generate light maps from a voxel space
On simule ensuite à l’aide d’AMAPVox des cartes de transmittance à différentes altitudes au-dessus du sol à l’aide du module transmittance light maps. 

script de traitement : lightMap_1m.xml
input : test1m_PadHLE.vox

output : lightMap_1m.txt

each = 2 m
height = 1, 10 m
direction number : 136 (pas calculé uniquement selon la verticale mais sur un hémisphère)
plot rotation : pour prendre en compte la course du soleil : 17° à la louche mais à remesurer sur qgis
Repetitve scene si tu n'as pas de buffer mais pas ouf
latitude de Paracou 5°
calendrier : sur une année 
clearness coefficient : 0.5 rapport direct-diffus en gros à l'équateur (change au cours des saisons)
```{r}
# enlever les 2 lignes mean
# Light <- Light[Y != "MEAN"]
Light <- fread("Z:/users/VincyaneBadouard/Lidar/ALS2023/AMAPvox/lightMap_1mAGL_2by2.txt", skip=10, nrows = 20403)
Light <- Light[, !c("V5"), with = FALSE] 

# Remove edges
Light <- Light[X<90 & X> -90 & Y<90 & Y> -90]
# Plot
lattice::levelplot(`Period 1`~X*Y, data = Light) # Transmittance
lattice::levelplot(Z~X*Y, data = Light) # Z = Altitude

ggplot() + 
  geom_raster(data = Light, aes(X, Y, fill = `Period 1`)) + 
  scale_fill_gradientn(name = "Light intensity (Transmittance)",
                       colors = terrain.colors(30, rev=T),
                       na.value="white") +
  ggtitle("Paracou P16 4ha - Light map 1m") +  
  coord_sf()
```
# Transformation des coordonnées relatives en UTM
On peut retrouver les cooordonnées UTM avec la VOP

```{r}
# Lecture matrice de transformation
VOP <- as.matrix(read.table("Z:/users/VincyaneBadouard/Lidar/ALS2023/AMAPvox/VOPPlotP16_4ha.txt"))

# Apply inverse of VOP matrix to convert back to UTM
xyz <- tcrossprod(as.matrix(Light[, .(X, Y, Z, c=1)]), solve(VOP))
Light[, `:=`(Xutm = xyz[, 1], Yutm = xyz[, 2], Zalt = xyz[, 3])]

Light <- unique(Light)

ggplot() + 
  geom_point(data = Light, size = 1.28,
             aes(Xutm, Yutm, color = `Period 1`)) + 
  scale_color_gradientn(name = "Light intensity (Transmittance)",
                        colors = terrain.colors(30, rev=T),
                        na.value="white") +
  ggtitle("Paracou P16 4ha - Light map 1m") +  
  coord_sf()

fwrite(Light, "Z:/users/VincyaneBadouard/Lidar/ALS2023/AMAPvox/Paracou_P16 4ha_lightMap_1m_UTM.txt", 
       row.names = F, col.names = T)

write.csv(Light, "Z:/users/VincyaneBadouard/Lidar/ALS2023/AMAPvox/Paracou_P16 4ha_lightMap_1m_UTM.csv")
```

Amapvox peut générer des photos hémisphériques, des données LAI2200, et des cartes 3D de lumière ()

# Positionner capteurs LAI2200 sur la carte de lumière dans AMAPvox

Tester différentes hauteurs permettra aussi de tester la disponibilité en lumière à l'endroit
où se trouve la couronne des arbres considérés.

```{r}

```

