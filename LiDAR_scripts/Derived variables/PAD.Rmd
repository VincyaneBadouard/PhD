---
title: "PAD"
author: "Vincyane"
date: "`r Sys.Date()`"
output: html_document
---

# Create PadBVTotal

ref : VINCENT, Gregoire; PIMONT, François; VERLEY, Philippe, 2021, "A
note on PAD/LAD estimators implemented in AMAPVox 1.7",
<doi:10.23708/1AJNMP> , DataSuds, V1

Computes Plant Area Density either from (transmittance or) attenuation
coefficient estimates. PAD is defind as the plant area per unit volume
(PAD plant area / voxel volume = m\^2 / m\^3). Plant area density (PAD
in m2·m−3)

PadBVTotal = 2\* attenuation (soit 2\*-log(transmittance)

PadBVTotal = 2 \* HLE

*AMAPVox::plantAreaDensity utilise une des variables disponibles
"transmittance", "attenuation_FPL_unbiasedMLE" ou "attenuation_PPL_MLE"
et génère une variable du même nom précédé du préfixe "pad\_"*

# Packages

```{r, include = F}
library(AMAPVox)
library(rgl)
library(lattice)
library(data.table)
library(MASS)
library(tidyverse)
# rm(list=ls())
```

# Read voxelSpace
```{r}
vxsp_High <- readVoxelSpace("//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/HighAltitudeFlight/P16_2023_HighAlt_4ha_buffer_equalecho2m.vox")
vxsp_Low <- readVoxelSpace("//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/lowAltitudeFlight/P16_2023_LowAlt_4ha_buffer_equalecho2m.vox")
# "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2022/P16_2022_4ha_buffer.vox"

# vxsp
# summary(vxsp@data)
# Pour ALS2023 low altitude le nbsampling est faible "Il n'y a pas d'incohérence dans les données: si tu travailles avec le fichier alt500m tu ne peux guère espérer mieux! Il faut en effet réduire le seuil pour le post-traitement (nbre minimum de tirs)"
```

# First get vegetation voxels only
```{r}
OnlyVegetation <- function(vxsp){
  bcnp <- belowCanopy(vxsp) # enlève tous les voxels au dessus de la canopée
  # summary(bcnp)
  
  dz = getVoxelSize(vxsp)["z"] # Gets the elemental size of a voxel (dx, dy, dz) in meter.
  
  # Considérer tout ce qui est à + de 0.5 m du z=0 comme de la végétation
  veg <- vxsp@data[bcnp, list(i,j,k,ground_distance), # combine data.tables on i,j,k columns
                   on = list(i, j, k)][ground_distance >= (0.5 * dz),
                                       list(i,j,k)] # keep only i,j,k columns
  fullcanopy <- vxsp
  fullcanopy@data <- vxsp@data[veg,,on = list(i,j,k)] # only veg part
  
  return(fullcanopy)
  
}

fullcanopy_High <- OnlyVegetation(vxsp_High)
fullcanopy_Low <- OnlyVegetation(vxsp_Low)

# summary(fullcanopy@data)
```

# Compute PAD
(HLE ou attenuation_FPL_biasedMLE)
```{r}
Compute_PAD <- function(fullcanopy, vxsp){
  fullcanopy@data$PadBVTotal <- 2*fullcanopy@data$attenuation_FPL_biasedMLE # *2 car hp d'orientation sphérique des feuilles
  
  # Import updated fields
  vxsp@data <- merge(vxsp@data,fullcanopy@data[,.(i,j,k,attenuation_FPL_biasedMLE,PadBVTotal)], by=c("i","j","k"), all.x=T) # veg and ground data
  
  # Fill-in above canopy and below ground voxels with 0 PadBVTotal value
  vxsp@data$PadBVTotal[which(is.na(vxsp@data$PadBVTotal))] <- 0  # to allow later transmittance computations using AMAPVox
  return(vxsp)
}

vxsp_High <- Compute_PAD(fullcanopy_High, vxsp_High)
vxsp_Low <- Compute_PAD(fullcanopy_Low, vxsp_Low)

rm(fullcanopy_High, fullcanopy_Low)
gc()
```

# Filter at >4, 12 nbSampling for both
```{r}
Filter_nbSampling <- function(vxsp_High, vxsp_Low, nbSampling_threshold =4){
  # data1 <- vxsp_High@data %>%
  #   mutate(ground_distance_disc = as.integer(ground_distance)) %>%
  #   select(ground_distance_disc, nbSampling, PadBVTotal)
  # 
  # data2 <- vxsp_Low@data %>%
  #   mutate(ground_distance_disc = as.integer(ground_distance)) %>%
  #   select(ground_distance_disc, nbSampling, PadBVTotal)
  # 
  # gc()
  # 
  # data <- data1 %>% 
  #   left_join(data2, by= "ground_distance_disc", suffix = c("_High", "_Low")) %>% 
  #   filter(nbSampling_High > nbSampling_threshold & nbSampling_Low > nbSampling_threshold)
  
  data1 <- unique(setDT(vxsp_High@data)[,ground_distance_disc := as.integer(ground_distance)][,.(ground_distance_disc, nbSampling, PadBVTotal)])
  data1 <- setkey(data1, ground_distance_disc)
  data2 <- unique(setDT(vxsp_Low@data)[,ground_distance_disc := as.integer(ground_distance)][,.(ground_distance_disc, nbSampling, PadBVTotal)])
  data2 <- setkey(data2, ground_distance_disc)
  
  gc()
  
  # all=TRUE, allow.cartesian=TRUE,
  data <- merge(data1, data2, suffixes = c("_High", "_Low"), allow.cartesian=TRUE)
  
  data1[data2, on= .(ground_distance_disc=ground_distance_disc), by=.EACHI]
  
  data1[data2, allow.cartesian = TRUE, nomatch = 0, by = .EACHI]
  
  return(data)
}

data <- Filter_nbSampling(vxsp_High, vxsp_Low, 4)

```

# Compute MeanPAD
```{r}
Compute_PAD_mean <- function(vxsp, nbSampling_threshold=0){
  data <- vxsp@data %>% 
    filter(nbSampling>nbSampling_threshold) %>%
    mutate(ground_distance_disc = as.integer(ground_distance)) %>% 
    group_by(ground_distance_disc) %>% 
    mutate(MeanPAD = mean(PadBVTotal)) %>% # mean
    mutate(MinPAD = min(PadBVTotal)) %>% 
    mutate(MaxPAD = max(PadBVTotal)) %>%
    ungroup() %>% 
    select(ground_distance_disc, MeanPAD, MinPAD, MaxPAD) %>% 
    filter(ground_distance_disc>=0 & ground_distance_disc<=60) %>% 
    unique() 
  return(data)
}

dataHigh <- Compute_PAD_mean(vxsp_High, nbSampling_threshold =0)
# rm(vxsp_High)
dataLow <- Compute_PAD_mean(vxsp_Low, nbSampling_threshold =0)
# rm(dataLow)
```


# Plot PAD vertical profile before estimation
```{r}
dataLow %>% 
  ggplot(aes(x= ground_distance_disc, y= MeanPAD )) +
  geom_point(data = dataHigh, aes(x = ground_distance_disc, y = MeanPAD, colour = "High altitude")) +
  geom_line(data = dataHigh, aes(x = ground_distance_disc, y = MeanPAD, colour = "High altitude")) +
  
  geom_point(data = dataLow, aes(x = ground_distance_disc, y = MeanPAD, colour = "Low altitude")) +
  geom_line(data = dataLow, aes(x = ground_distance_disc, y = MeanPAD, colour = "Low altitude")) +
  scale_colour_manual(values = c("High altitude" = "darkgreen",
                                 "Low altitude" = "green")) +
  
  ggtitle("P16-2023-4ha+buffer - HighAlt - PAD profile before estimation (equal echo)- res 2m") +
  labs(y="PAD", x="Absolute Tree Height", color = "LiDAR acquisition") +
  coord_flip() #+ # coordonnées inversées au départ pour que la ligne suive la hauteur au sol et non le PAD
# geom_errorbar(aes(ymin=MinPAD, ymax=MaxPAD), width=.2)#+ 
# options(repr.plot.width=8, repr.plot.height=15) # higher height
```

```{r}
rm(dataLow, dataHigh)
```

# Plot PAD vertical profile after estimation
```{r}
# vxsp_High <- readVoxelSpace("//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/HighAltitudeFlight/P16_2023_4ha_buffer_HighAlt_PadHLE.vox")
# 
# vxsp_low_pulseMin4 <- readVoxelSpace("//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/lowAltitudeFlight/P16_2023_4ha_buffer_LowAlt_PadHLE.vox")
# vxsp_low_pulseMin12 <- readVoxelSpace("//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/lowAltitudeFlight/P16_2023_4ha_buffer_LowAlt_PadHLE_pulseMin12.vox")
# vxsp_low_pulseMin20 <- readVoxelSpace("//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/lowAltitudeFlight/P16_2023_4ha_buffer_LowAlt_PadHLE_pulseMin20.vox")
# vxsp_low_pulseMin28 <- readVoxelSpace("//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/lowAltitudeFlight/P16_2023_4ha_buffer_LowAlt_PadHLE_pulseMin28.vox")
# vxsp_low_pulseMin44 <- readVoxelSpace("//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/lowAltitudeFlight/P16_2023_4ha_buffer_LowAlt_PadHLE_pulseMin44.vox")

vxsp_High <- readVoxelSpace("//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/HighAltitudeFlight/P16_2023_4ha_buffer_HighAlt_PadHLE_equalecho2m.vox")
vxsp_Low <- readVoxelSpace("//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/lowAltitudeFlight/P16_2023_4ha_buffer_LowAlt_PadHLE_equalecho2m.vox")

```

```{r}
Compute_PAD_nbSampling_mean <- function(vxsp){
  data <- vxsp@data %>% 
    filter(nbSampling>0) %>%
    mutate(ground_distance_disc = as.integer(ground_distance)) %>% 
    group_by(ground_distance_disc) %>% 
    mutate(MeanPAD = mean(PadBVTotal)) %>% 
    mutate(MinPAD = min(PadBVTotal)) %>% 
    mutate(MaxPAD = max(PadBVTotal)) %>%
    mutate(MeanNbsampling = mean(nbSampling)) %>% 
    mutate(SdNbsampling = sd(nbSampling)) %>% 
    mutate(MinNbsampling = min(nbSampling)) %>% 
    mutate(MaxNbsampling = max(nbSampling)) %>%
    ungroup() %>% 
    select(ground_distance_disc, MeanPAD, MinPAD, MaxPAD, MeanNbsampling, SdNbsampling) %>% 
    filter(ground_distance_disc>=0 & ground_distance_disc<=60) %>% 
    unique()
  return(data)
}

dataHigh <- Compute_PAD_nbSampling_mean(vxsp_High)
# rm(vxsp_High)

dataLow <- Compute_PAD_nbSampling_mean(vxsp_Low)
gc()

# dataLow_pulseMin4 <- Compute_PAD_nbSampling_mean(vxsp_low_pulseMin4)
# rm(vxsp_low_pulseMin4)
# 
# dataLow_pulseMin12 <- Compute_PAD_nbSampling_mean(vxsp_low_pulseMin12)
# rm(vxsp_low_pulseMin12)
# 
# dataLow_pulseMin20 <- Compute_PAD_nbSampling_mean(vxsp_low_pulseMin20)
# rm(vxsp_low_pulseMin20)
# 
# dataLow_pulseMin28 <- Compute_PAD_nbSampling_mean(vxsp_low_pulseMin28)
# rm(vxsp_low_pulseMin28)
# 
# dataLow_pulseMin44 <- Compute_PAD_nbSampling_mean(vxsp_low_pulseMin44)
# rm(vxsp_low_pulseMin44)
```


```{r}
dataHigh %>% 
  ggplot(aes(x= ground_distance_disc, y= MeanPAD )) +
  geom_point(data = dataHigh, aes(y = MeanPAD, colour = "High altitude (pulse min=20)")) +
  geom_line(data = dataHigh, aes(y = MeanPAD, colour = "High altitude (pulse min=20)")) +
  
  geom_point(data = dataLow, aes(y = MeanPAD, colour = "Low altitude (pulse min=20)")) +
  geom_line(data = dataLow, aes(y = MeanPAD, colour = "Low altitude (pulse min=20)")) +
  # geom_point(data = dataLow_pulseMin4, aes(y = MeanPAD, colour = "Low altitude (pulse min=4)")) +
  # geom_line(data = dataLow_pulseMin4, aes(y = MeanPAD, colour = "Low altitude (pulse min=4)")) +
  # 
  # geom_point(data = dataLow_pulseMin12, aes(y = MeanPAD, colour = "Low altitude (pulse min=12)")) +
  # geom_line(data = dataLow_pulseMin12, aes(y = MeanPAD, colour = "Low altitude (pulse min=12)")) +
  # 
  # geom_point(data = dataLow_pulseMin20, aes(y = MeanPAD, colour = "Low altitude (pulse min=20)")) +
  # geom_line(data = dataLow_pulseMin20, aes(y = MeanPAD, colour = "Low altitude (pulse min=20)")) +
  # 
  # geom_point(data = dataLow_pulseMin28, aes(y = MeanPAD, colour = "Low altitude (pulse min=28)")) +
  # geom_line(data = dataLow_pulseMin28, aes(y = MeanPAD, colour = "Low altitude (pulse min=28)")) +
# 
# geom_point(data = dataLow_pulseMin44, aes(y = MeanPAD, colour = "Low altitude (pulse min=44)")) +
# geom_line(data = dataLow_pulseMin44, aes(y = MeanPAD, colour = "Low altitude (pulse min=44)")) +

scale_colour_manual(values = c("High altitude (pulse min=20)" = "darkgreen",
                               "Low altitude (pulse min=20)" = "green"
                               # "Low altitude (pulse min=4)" = "green",
                               # "Low altitude (pulse min=12)" = "yellow",
                               # "Low altitude (pulse min=20)" = "orange",
                               # "Low altitude (pulse min=28)" = "darkred",
                               # "Low altitude (pulse min=44)" = "black"
),
breaks=c("High altitude (pulse min=44)",
         "Low altitude (pulse min=8)"
         # "Low altitude (pulse min=4)",
         # "Low altitude (pulse min=12)",
         # "Low altitude (pulse min=20)",
         # "Low altitude (pulse min=28)",
         # "Low altitude (pulse min=44)"
)) +
  ggtitle("P16-2023-4ha+buffer - PAD profile after estimation (equal echo) res 2m") +
  labs(y="Average PAD", x="Absolute Tree Height", color = "LiDAR acquisition") +
  coord_flip() #+ # coordonnées inversées au départ pour que la ligne suive la hauteur au sol et non le PAD
# geom_errorbar(aes(ymin=MinPAD, ymax=MaxPAD), width=.2)#+ 
# options(repr.plot.width=8, repr.plot.height=15) # higher height
```

# Plot extinction profiles
nbr de pulses qui traversent (1- ce qui est revenu)
```{r}
dataLow %>% 
  ggplot(aes(x= ground_distance_disc, y= MeanNbsampling)) +
  xlim(0,55) +
  geom_point(data = dataHigh, aes(x = ground_distance_disc, y = MeanNbsampling, colour = "High altitude")) +
  geom_line(data = dataHigh, aes(x = ground_distance_disc, y = MeanNbsampling, colour = "High altitude")) +
  
  geom_point(data = dataLow, aes(x = ground_distance_disc, y = MeanNbsampling, colour = "Low altitude")) +
  geom_line(data = dataLow, aes(x = ground_distance_disc, y = MeanNbsampling, colour = "Low altitude")) +
  scale_colour_manual(values = c("High altitude" = "darkgreen",
                                 "Low altitude" = "green")) +
  
  ggtitle("P16 - 2023 - 4ha + buffer - extinction profile after estimation") +
  labs(y="Sampling", x="Absolute Tree Height", color = "LiDAR acquisition") +
  coord_flip() #+
# geom_errorbar(aes(ymin=MeanNbsampling-SdNbsampling, ymax=MeanNbsampling+SdNbsampling), width=.2)
#   geom_errorbar(aes(ymin=MinNbsampling, ymax=MaxNbsampling), width=.2)
```
