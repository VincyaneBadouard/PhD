---
title: "UAV pre-treatment"
author: "Vincyane Badouard"
date: "`r Sys.Date()`"
output: pdf_document
---
For HovermapST-X data:
- Crop las (9ha)
- Compute scan angles
- Filter < 2m range
- Filter angles < 45°
- Remove outliers
- Ground point classification
- Create MNT

```{r, include = F}
library(lidR)
library(sf)
library(terra)
library(tidyverse)
library(raster)
library(data.table)
```

# Paths
```{r}
local <- "//amap-data.cirad.fr/work/"
# local <- "Y:/"

# folders <- "users/VincyaneBadouard/Lidar/HovermapUAV2023/Processed/"
folders <- "users/VincyaneBadouard/Lidar/HovermapUAV2023/Translation/LAZ/"
# file <- "UAV_sampletowork" # petit jeu de données
file <- "UAV_C19C20_translated"
trajectory <- "UAV_C19C20_traj_translated.xyz"
```


# Load LiDAR data
```{r}
las <- readLAS(paste(local,folders,file,".las", sep = "")) # 1 min (20.4 GB)
# las <- decimate_points(las, random(1)) # reduce point density (13 MB)
# writeLAS(las, paste(local,folders,file,".laz", sep = ""))

options(digits = 22)
traj <- fread(paste(local,"users/VincyaneBadouard/Lidar/HovermapUAV2023/Translation/Traj/",trajectory, sep = ""))[,1:5]
```

```{r}
folders <- "users/VincyaneBadouard/Lidar/HovermapUAV2023/Processed/"
```

# Crop UAV with the trajectory
```{r}
# rgl::plot3d(traj[,3:5], aspect=F) # plot the trajectory (x,y,z)
```

```{r}
options(digits=22)
range(traj$gpstime) # 1697733191.029119968414 1697734449.009840011597
# range(UAV_C14C15@data$gpstime) # 1697736245.296575307846 1697737554.548056840897
traj_crop <- traj[y<581700 & x<286000,] # 286321

# rgl::plot3d(traj_crop[,3:5], aspect=F) # plot the trajectory (x,y,z)
```

```{r}
las_crop <- las
las_crop@data <- las_crop@data[Y<581700 & X<286000,]
# plot(las_crop) # fait planter R

```

# Compute the scan angles
```{r}
# source("~/PhD/R_codes/PhD/LiDAR_scripts/Functions/ComputeScanAngle.R")
source("D:/UAV_Vincyane/ComputeScanAngle.R")
# rm(laz_scanAngles)
laz_scanAngles <- ComputeScanAngle(las_crop, traj)
view(laz_scanAngles@data)
range(laz_scanAngles@data$ScanAngle, na.rm =T) # 0 - 86

writeLAS(laz_scanAngles, paste(local,folders,file, "_scanAngles.laz", sep = ""))
```

# Filter < 2m range and angles < 45°
UAV altitude flight: 85m
```{r}
laz_angles_filtered <- readLAS(paste(local,folders,file, "_scanAngles.laz", sep = ""),
                               filter = "-drop_abs_scan_angle_above 45 -drop_z_above 83 (max_z)")

max(laz_angles_filtered@data$Z) # 65.9
range(laz_angles_filtered@data$ScanAngle) # 0-45
```

# Remove outliers 
Pour enlever le bruit (**à faire avant la recherche de points sol**) utiliser un algo dédié (c'est à peu près les mêmes dans lastools et LidR)

Procéder comme suit :
* normaliser par rapport à un dtm existant et enlever tous les points nettement sous le sol (e.g. z<-0.5)
* filtrer les point bruits en restreignant l'analyse au haut de canopée (pour éviter d'effacer des points bas localement rares au niveau du sol)
**checher une fct lidR ou lastools pour ça**
https://gis.stackexchange.com/questions/371774/way-to-filter-outliers-from-point-cloud-in-lidr

* dénormaliser

```{r}
mnt <- rast(paste(local,"users/VincyaneBadouard/Lidar/ALS2023/HighAltitudeFlight/MNT/dtm2023_4ha_HighAlt_buffer.asc", sep = "")) # de lALS ? croppé ?
plot(mnt)
```

```{r}
laz <- laz_angles_filtered
RemoveOutliers <- function(laz, mnt){
  laz_norm <- lidR::normalize_height(laz, mnt) # Normaliser la hauteur du sol # applati le relief
  # laz_norm@data[(Z>(-0.2) & Z< 0.5), Classification := 2] # Classifier les points sol
  laz_norm@data[Z<(-0.2), Classification := 7] # Classifier les points bruits en dessous du sol
  laz_norm@data[Z>60, Classification := 7] # Classifier les points bruits au dessus de la canopée
  # laz_norm@data[is.na(Classification), Classification := 1] # Classifier les points non-bruit
  
  # table(laz_norm@data$Classification) # 7 = bruit, 2 = sol, vegetation = 0,3,4,5
  # plot(laz_norm, color = "Classification") # trop long
  
  # laz_norm <- classify_noise(laz_norm, algorithm = ivf(res = 5, n = 6)) # !!-> 18!!
  # sor: Statistical Outliers Removal (SOR) (also implemented in CloudCompare). It computes the mean distance to all its k-nearest neighbours. sor(k,m)
  # ivf: isolated voxels filter (IVF) (similar to lasnoise from lastools). The algorithm finds points that have only a few other points in their surrounding 3 x 3 x 3 = 27 voxels. ivf(res = 5, n = 6)
  
  # * filtrer les point bruits en restreignant l'analyse au haut de canopée (pour éviter d'effacer des points bas localement rares au niveau du sol)
  # table(laz_norm@data$Classification)
  # # plot(laz_norm)
  # laz_norm@data[,Classification := ifelse(Classification==18, 7,Classification)] # recode 18->7
  laz_norm@data <- laz_norm@data[Classification!=7,]
  laz_norm@data[, Classification := as.integer(Classification)]
  # plot(laz_norm)
  # min(laz_norm@data$Z)
  
  # * dénormaliser
  laz <- lidR::unnormalize_height(laz_norm) # Dénormaliser la hauteur du sol
  return(laz)
}

laz_OutliersRemoved <- RemoveOutliers(laz_angles_filtered, mnt)
# plot(laz_OutliersRemoved)
```

```{r}
writeLAS(laz_OutliersRemoved, paste(local,folders,file, "_OutliersRemoved.laz", sep = ""))
```

# Classification des points sols avec lastools (Problème : points sols trop hauts -> fait sur CloudCompare)
https://www.sigterritoires.fr/index.php/qgis-pour-lidarmodele-numerique-de-terrain-mnt-avec-lastools/

- LASGround est un outil qui identifie et classe les points du sol dans un nuage de points LiDAR en se basant sur la densité des points voisins. 

- **LASGround_New** est une version améliorée de LASGround, introduite pour fournir de meilleures performances et une extraction plus précise des points du sol.LASGround_New utilise une approche basée sur l’apprentissage automatique (machine learning), en se basant sur des caractéristiques telles que la hauteur, la densité, etc. 
- option **« -nature »** (pas de 5 mètres) ou « -wilderness » (pas de 3 mètres)

## Define the path and the function for lastools executables
```{r}
LAStoolsDir =  "D:/Program/LAStools/bin/"
# LAStoolsDir = "D:/UAV_Vincyane/LAStools/LAStools/bin"

## Define the R function that calls lastools executables
LAStool <- function(tool, inputFile, ...){
  cmd = paste(paste(LAStoolsDir, tool, sep=''), '-i', inputFile , ...) # -i in.laz
  cat(cmd)
  system(cmd)
  return(cmd)
}
```

## In and output
```{r}
# //amap-data.cirad.fr\work\users\VincyaneBadouard\Lidar\HovermapUAV2023\P16_C19C20/Output_subsampled_laz1_4.laz
# Define las/laz files to be processed
# inFiles = "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/P16_C19C20/Output_subsampled_laz1_4.laz"
# subsample <- readLAS("//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/P16_C19C20/Output_subsampled_laz1_4.laz")
# unique(subsample@data$Classification)

# inFiles = paste(local,folders, file, "_OutliersRemoved.laz", sep = "" ) # _OutliersRemoved
# outFile = paste(file, "_GroundClassif_las.laz", sep = "" )

# after retranslation
file <- "UAV_C19C20"
inFiles = paste(local,folders, file, "_retranslated_declassif.laz", sep = "" )
outFile = paste(file, "_retranslated_lastoolsclassif.laz", sep = "" )
```

## Call the lastools lasground_new function to classify the ground points
```{r}
cores <- parallel::detectCores()

LASrun <- LAStool('lasground_new', inFiles,
                  '-cores', cores,
                  '-nature', # pas de 5 mètres ( -wilderness : 3 mètres)
                  '-odir', paste(local,folders,sep = ""), # output folder
                  '-o', outFile # -o out.laz
) # 412.865 sec.

# ou avec lidR
# classify_ground(laz_OutliersRemoved, algorithm, last_returns = TRUE) # pmf: , csf: , mcc:  
```
# After classification on CloudCompare, bind laz
```{r}
# subplot <- "UAV_C19C20"
# subplot <- "UAV_C14C15"
# veg <- readLAS(paste(local,folders, subplot, "_translated_VegPoints_CloudCompare.laz", sep = "")) 
# ground <- readLAS(paste(local,folders, subplot, "_translated_GroundPoints_CloudCompare.laz", sep = "")) 
# 
# unique(ground@data$Classification)
# 
# veg@data <- setDT(veg@data)
# ground@data <- setDT(ground@data)
# 
# veg@data[,Classification := 1L]
# ground@data[,Classification := 2L]
# 
# plot(ground)
# range(ground@data$Z) # Points sol : C1920: 6.3823 31.7885; C1415 : 4.6516 25.7552
# 
# # To merge on CloudCompare if not enough RAM
# writeLAS(veg, paste(local,folders, subplot, "_translated_VegPoints_CloudCompareClassif.laz", sep = ""))
# writeLAS(ground, paste(local,folders, subplot, "_translated_GroundPoints_CloudCompareClassif.laz", sep = ""))

# Merge in enough RAM...
# laz_GroundClassif@data <- merge(veg@data, ground@data, all.x = TRUE)
# laz_GroundClassif@data <- rbind(veg@data, ground@data, fill=TRUE)
# veg@data[ground@data, on=]
# writeLAS(laz_GroundClassif, paste(local,folders,file, "_GroundClassif.laz", sep = ""))

```

## Check
```{r}
file <- "UAV_C14C15" # "UAV_C19C20"

laz_GroundClassif <- readLAS(paste(local,folders, file, "_retranslated_lastoolsclassif.laz", sep = "" ))
# laz_GroundClassif <- readLAS(paste(local,folders,file, "_GroundClassif.laz", sep = "" ))
table(laz_GroundClassif@data$Classification) # 2 = sol
# plot(laz_GroundClassif, color = "Classification") # points sols trop hauts !

range(laz_GroundClassif$Z) # 6.3823 65.9298
range(laz_GroundClassif@data[Classification == 2L,]$Z) # Points sol: 6.3823 31.7885
range(laz_GroundClassif@data[Classification == 1L,]$Z) # Points vegetation: 6.6792 65.9298

# presque meme résultat entre lastools et cloudcompare
```

# Générer le MNT sur lastools ou lidR
Calcul du MNT avec LAS2dem :

Cet outil lit les points LIDAR, les triangule temporairement en un TIN, puis calque le TIN sur un raster MNT.
- Le filtre keep_class 2 fait qu’on ne traitera que les points classés « sol » (code 2).
résolution par défaut : 1 m ('-step 1')

## In and output
```{r}
# Define las/laz files to be processed
# inFiles = paste(local,folders,file, "_GroundClassif.laz", sep = "" )
# outFile = paste(file, "_DEM.asc", sep = "" )
```

```{r}
# LASrun <- LAStool('LAS2dem', inFiles,
#                   '-cores', cores,
#                   '-keep_class 2', # que les points sol
#                   '-elevation',
#                   '-o', outFile # -o out.laz
# ) # bloqué par withscecure

# ou avec lidR

# tin() Erreur : Internal error in C_interpolate_delaunay: xy coordinates were not converted to integer. Scale factors are likely to be invalid.
las_quantize(laz_GroundClassif)
laz_GroundClassif <- las_update(laz_GroundClassif) # Update the object to set up-to-date header data
laz_GroundClassif <- las_rescale(laz_GroundClassif, xscale = 0.01, yscale = 0.01)

UAV_DEM <- lidR::rasterize_terrain(laz_GroundClassif, res = 1, algorithm = lidR::tin(), use_class = 2L) # to mnt

# raster::writeRaster(UAV_DEM, file.path(paste(local, folders, file, "_DEM.asc", sep = "")), overwrite=T)
raster::writeRaster(UAV_DEM, file.path(paste(local, folders, file, "_DEM.tif", sep = "")), overwrite=T)

```

## Check
```{r}
UAV_DEM <- raster(paste(local, folders, file, "_DEM.tif", sep = ""))

# Region of Interest (ROI)
ROI <- terra::vect(paste(local,"users/VincyaneBadouard/Lidar/ALS2022/Plot16_4ha_buffer100m.shp", sep = "")) # interest zone + 100m buffer
ROI <- st_as_sf(ROI) # as sf object
ROI <- st_set_crs(ROI, 2972) # attribuer le dernier crs
crs(UAV_DEM) <- crs(ROI)

ggplot() + 
  tidyterra::geom_spatraster(data = UAV_DEM, aes(fill = Z)) +
  scale_fill_gradientn(name = "Elevation (m)",
                       colors = terrain.colors(30, rev=T), na.value="white") +
  geom_sf(data = sf::st_cast(ROI, "LINESTRING")) +
  ggtitle("Paracou P16: MNT - UAV 2023 (1m)") +
  theme_classic() +
  coord_sf()

ggsave(paste(file, "_DEM2_1m.png", sep = "" ), path = "D:/Mes Donnees/PhD/Figures/lidar/UAV", width = 25, height = 15, units = "cm", dpi=800, bg="white")
```

## Crop mnt (9ha)
```{r}
UAV_DEMROI <- raster::mask(UAV_DEM,ROI)
UAV_DEMROI <- raster::crop(UAV_DEMROI,ROI)

mntROI <- resample(mnt,UAV_DEMROI)

ggplot() + 
  tidyterra::geom_spatraster(data = mntROI, aes(fill = dtm2023_4ha_HighAlt_buffer)) + # mnt_roi36ha_1m # dtm2023
  scale_fill_gradientn(name = "Elevation (m)",
                       colors = terrain.colors(30, rev=T),
                       na.value="white") +
  theme_classic() +
  geom_sf(data = sf::st_cast(ROI, "LINESTRING"))

ggsave(paste(file, "_ALS_DEM2_1m_crop.png", sep = "" ), path = "D:/Mes Donnees/PhD/Figures/lidar/UAV", width = 25, height = 15, units = "cm", dpi=800, bg="white")
```

## Check ALS UAV match
```{r}
# 5-2 =3
diffmnt <- mntROI - UAV_DEMROI

ggplot() + 
  tidyterra::geom_spatraster(data = diffmnt, aes(fill = dtm2023_4ha_HighAlt_buffer)) + # mnt_roi36ha_1m # dtm2023
  scale_fill_gradientn(name = "Elevation difference (m)",
                       colors = terrain.colors(30, rev=T),
                       na.value="white") +
  theme_classic() +
  geom_sf(data = sf::st_cast(ROI, "LINESTRING")) +
  ggtitle("Paracou P16: MNT (1m) - ALS-UAV 2023 difference") +
  theme_classic() +
  coord_sf()

ggsave(paste("ALS-", file, "_2023_DEM_difference2.png", sep = ""), path = "D:/Mes Donnees/PhD/Figures/lidar/UAV", width = 25, height = 15, units = "cm", dpi=800, bg="white")
```
# Fusion

## Merge DEMs
```{r}
mnt_C14C15 <- rast("//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/AMAPVox/MNT/dtm2023_4ha_UAV_C14C15_buffer.asc")
mnt_C19C20 <- rast("//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/AMAPVox/MNT/dtm2023_4ha_UAV_C19C20_buffer.asc")

mnt_UAV <- raster::merge(mnt_C14C15, mnt_C19C20, first = T)
crs(mnt_UAV) <- crs(ROI)

ggplot() + 
  tidyterra::geom_spatraster(data = mnt_UAV, aes(fill = dtm2023_4ha_UAV_C14C15_buffer)) + 
  scale_fill_gradientn(name = "Elevation (m)",
                       colors = terrain.colors(30, rev=T),
                       na.value="white") +
  theme_classic() +
  geom_sf(data = sf::st_cast(ROI, "LINESTRING")) +
  ggtitle("Paracou P16: DEM (1m) - UAV 2023") +
  theme_classic() +
  coord_sf()

ggsave("P16_4ha_buffer_UAV_2023_DEM_1m.png", path = "D:/Mes Donnees/PhD/Figures/lidar/UAV", width = 25, height = 15, units = "cm", dpi=800, bg="white")

writeRaster(raster(mnt_UAV),
            "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/AMAPVox/MNT/dtm2023_4ha_UAV_buffer.asc",
            format="ascii", overwrite=T)
```
## Merge point clouds
```{r}
# Define the path for lastools executables
LAStoolsDir =  "D:/Program/LAStools/bin/"

# Define the R function that calls lastools executables
LAStool <- function(tool, inputFile, ...){
  cmd = paste(paste(LAStoolsDir, tool, sep=''), '-i', inputFile , ...)
  cat(cmd)
  system(cmd)
  return(cmd)
}

# Define las/laz files to be processed
inFiles <- paste("//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/AMAPVox/LAZ", '/*.laz', sep='') # files
outFile = "P16_2023_UAV_4ha_buffer_intensitycor_lastools.laz"
outDir <- "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/AMAPVox/LAZ"

# Merge files
LASrun <- LAStool('lasmerge64', inFiles,
                  '-odir', outDir,
                  # '-odix _cor',
                  '-unique',
                  '-o', outFile)
# WARNING: files have different attribute 0
```

## Merge trajectories
```{r}
traj_C14C15 <- fread("//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/AMAPVox/Traj/UAV_C14C15_traj_retranslated.xyz")
traj_C19C20 <- fread("//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/AMAPVox/Traj/UAV_C19C20_traj_retranslated.xyz")

traj_UAV <- rbind(traj_C14C15, traj_C19C20)

fwrite(traj_UAV, "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/AMAPVox/Traj/UAV_P16_4ha_traj.txt")
```


# Crop mnt (4ha)
```{r}
Understory <- vect("//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2022/Parcelles_Understory.shp") 
Understory <- st_as_sf(Understory) # as sf object
Understory <- st_set_crs(Understory, 2972) # attribuer le dernier crs

mnt_UAV <- raster::mask(mnt_UAV,Understory)
mnt_UAV <- raster::crop(mnt_UAV,Understory)

ggplot() + 
  tidyterra::geom_spatraster(data = mnt_UAV, aes(fill = dtm2023_4ha_UAV_C14C15_buffer)) +
  scale_fill_gradientn(name = "Elevation (m)",
                       colors = terrain.colors(30, rev=T),
                       na.value="white") +
  theme_classic() +
  geom_sf(data = sf::st_cast(Understory, "LINESTRING")) +
  ggtitle("Paracou P16 4ha: DEM (1m) - UAV 2023") +
  theme_classic() +
  coord_sf()

ggsave("P16_4ha_UAV_2023_DEM_1m.png", path = "D:/Mes Donnees/PhD/Figures/lidar/UAV", width = 25, height = 15, units = "cm", dpi=800, bg="white")

writeRaster(raster(mnt_UAV),
            "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/Processed/dtm2023_4ha_UAV.asc",
            format="ascii", overwrite=T)
```


# Buffer d’ALS
