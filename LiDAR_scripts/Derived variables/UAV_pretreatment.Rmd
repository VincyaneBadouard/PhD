---
title: "UAV pre-treatment"
author: "Vincyane Badouard"
date: "`r Sys.Date()`"
output: pdf_document
---
For HovermapST-X data:
- Crop las (9ha)
- Compute scan angles
- Filter < 2m range
- Filter angles < 45°
- Remove outliers
- Ground point classification
- Create MNT

```{r, include = F}
library(lidR)
library(sf)
library(terra)
library(tidyverse)
library(raster)
library(data.table)
```

# Paths
```{r}
local <- "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/"
# local <- "Y:/users/VincyaneBadouard/Lidar/HovermapUAV2023/"

folders <- "P16_C14C15/"
# "users/VincyaneBadouard/Lidar/HovermapUAV2023/Processed/"
# "users/VincyaneBadouard/Lidar/HovermapUAV2023/Translation/LAZ/"

file <- "Returns_and_gpstime_corrected"
# "UAV_sampletowork" # petit jeu de données
# "UAV_C19C20_translated"

matrix1 <- as.matrix(read.table(paste(local, folders, "Translation_matrix/Matrix_cor1.txt", sep = ""), header=F))
matrix2 <- as.matrix(read.table(paste(local, folders, "Translation_matrix/Matrix_Greg.txt", sep = ""), header=F))

trajectory <- "Output_traj.xyz"
```


# Load LiDAR data
```{r}
las <- readLAS(paste(local,folders,file,".laz", sep = "")) 
# las <- decimate_points(las, random(1)) # reduce point density (13 MB)
# writeLAS(las, paste(local,folders,file,".laz", sep = ""))

options(digits = 22)
traj <- fread(paste(local,folders,trajectory, sep = ""))[,1:5]
```

```{r}
folders <- paste(folders,"Processed/", sep = "")
```

# Translate the point cloud
```{r}
source("D:/UAV_Vincyane/TranslateLaz.R")
las1 <- TranslateLaz(las0, matrix1, suffix = "_local")
las1@data[, `:=`(X = X-285000.00 , Y = Y-581000.00)]

las2 <- TranslateLaz(las1, matrix2, suffix = "_prev")
# View(las2@data[1:10])
las2@data[, `:=`(X = X+285000.00 , Y = Y+581000.00)]

las2@data[, c("x_prev", "y_prev", "z_prev"):= NULL]  # remove interm columns
las2@data <- setnames(las@data, c("x_local", "y_local", "z_local"), c("x", "y", "z"))  # change names

writeLAS(las2, paste(local,folders,file, "_translated.laz", sep = ""))
```

```{r}
rm(las1,las)
```

# Trajectory translation on R
```{r}
source("D:/UAV_Vincyane/TranslateTraj.R")
# source("~/PhD/R_codes/PhD/LiDAR_scripts/Functions/TranslateTraj.R")

# Translate
Trans1 <- TranslateTraj(traj, matrix1)

# Greg translation :
range(Trans1$x) ; range(Trans1$y) 
Trans1[, `:=`(x = x-285000.00 , y = y-581000.00)]

Trans2 <- TranslateTraj(Trans1, matrix2)
Trans2[, `:=`(x = x+285000.00 , y = y+581000.00)]
range(Trans2$x) ; range(Trans2$y) 

# Write
fwrite(Trans2, paste(local,folders,"UAV_traj_retranslated.xyz", sep = ""))
```

```{r}
rm(Trans1,traj)
```

```{r}
las <- las2
traj <- Trans2

# rm(las2,Trans2)
```

# Crop UAV with the trajectory
```{r}
readLAS(paste(local,folders,file, "_OutliersRemoved.laz", sep = ""))
```

```{r}
# rgl::plot3d(traj[,3:5], aspect=F) # plot the trajectory (x,y,z)
```

```{r}
options(digits=22)
range(traj$gpstime) # 1697733191.029119968414 1697734449.009840011597
# range(UAV_C14C15@data$gpstime) # 1697736245.296575307846 1697737554.548056840897
traj_crop <- traj[y<581700 & x<286000,] # 286321

# rgl::plot3d(traj_crop[,3:5], aspect=F) # plot the trajectory (x,y,z)
```

```{r}
las_crop <- readLAS(paste(local,folders,file, "_OutliersRemoved.laz", sep = "")) # "_translated.laz"

las_crop <- las
las_crop@data <- las_crop@data[Y<581700 & X<286000,]
# plot(las_crop) # fait planter R

writeLAS(las_crop, paste(local,folders,file, "_cropedtraj.laz", sep = ""))
```

# Compute the scan angles
```{r}
# source("~/PhD/R_codes/PhD/LiDAR_scripts/Functions/ComputeScanAngle.R")
source("D:/UAV_Vincyane/ComputeScanAngle.R")
# rm(laz_scanAngles)
laz_scanAngles <- ComputeScanAngle(las_crop, traj)
# view(laz_scanAngles@data)
range(laz_scanAngles@data$ScanAngleRank, na.rm =T)
hist(laz_scanAngles@data$ScanAngleRank) # 0 - 180

writeLAS(laz_scanAngles, paste(local,folders,file, "_scanAngles.laz", sep = ""))
```

```{r}
rm(las, las2, las_crop)
```

# Filter < 2m range and angles < 45°
UAV altitude flight: 85m
```{r}
laz_scanAngles@data <- laz_scanAngles@data[ScanAngleRank<=45,]
laz_scanAngles@data <- laz_scanAngles@data[Z<=83,]


# laz_angles_filtered <- readLAS(paste(local,folders,file, "_scanAngles.laz", sep = ""),
#                                filter = "-drop_abs_scan_angle_above 45 -drop_z_above 83 (max_z)")

max(laz_scanAngles@data$Z) # 79.3
range(laz_scanAngles@data$ScanAngleRank) # 0-45

writeLAS(laz_scanAngles, paste(local,folders,file, "_AnglesandZ_filtered.laz", sep = ""))

las <- readLAS(paste(local,folders,file, "_AnglesandZ_filtered.laz", sep = ""))
# max(las@data$Z) # 79.3
# range(las@data$ScanAngleRank) # 0-45
laz_scanAngles <- las
```

```{r}
rm(laz_crop)
```

# Remove outliers 
Pour enlever le bruit (**à faire avant la recherche de points sol**) utiliser un algo dédié (c'est à peu près les mêmes dans lastools et LidR)

Procéder comme suit :
* normaliser par rapport à un dtm existant et enlever tous les points nettement sous le sol (e.g. z<-0.5)
* filtrer les point bruits en restreignant l'analyse au haut de canopée (pour éviter d'effacer des points bas localement rares au niveau du sol)
**checher une fct lidR ou lastools pour ça**
https://gis.stackexchange.com/questions/371774/way-to-filter-outliers-from-point-cloud-in-lidr

* dénormaliser

```{r}
root <- "Y:/"
mnt <- rast(paste(root,"users/VincyaneBadouard/Lidar/ALS2023/HighAltitudeFlight/MNT/dtm2023_4ha_HighAlt_buffer.asc", sep = "")) # de lALS ? croppé ?
plot(mnt)
```

```{r}
# laz <- laz_scanAngles
RemoveOutliers <- function(laz, mnt){
  laz_norm <- lidR::normalize_height(laz, mnt) # Normaliser la hauteur du sol # applati le relief
  # laz_norm@data[(Z>(-0.2) & Z< 0.5), Classification := 2] # Classifier les points sol
  laz_norm@data[Z<(-0.2), Classification := 7] # Classifier les points bruits en dessous du sol
  laz_norm@data[Z>60, Classification := 7] # Classifier les points bruits au dessus de la canopée
  # laz_norm@data[is.na(Classification), Classification := 1] # Classifier les points non-bruit
  
  # table(laz_norm@data$Classification) # 7 = bruit, 2 = sol, vegetation = 0,3,4,5
  # plot(laz_norm, color = "Classification") # trop long
  
  # laz_norm <- classify_noise(laz_norm, algorithm = ivf(res = 5, n = 6)) # !!-> 18!!
  # sor: Statistical Outliers Removal (SOR) (also implemented in CloudCompare). It computes the mean distance to all its k-nearest neighbours. sor(k,m)
  # ivf: isolated voxels filter (IVF) (similar to lasnoise from lastools). The algorithm finds points that have only a few other points in their surrounding 3 x 3 x 3 = 27 voxels. ivf(res = 5, n = 6)
  
  # * filtrer les point bruits en restreignant l'analyse au haut de canopée (pour éviter d'effacer des points bas localement rares au niveau du sol)
  # table(laz_norm@data$Classification)
  # # plot(laz_norm)
  # laz_norm@data[,Classification := ifelse(Classification==18, 7,Classification)] # recode 18->7
  laz_norm@data <- laz_norm@data[Classification!=7,]
  laz_norm@data[, Classification := as.integer(Classification)]
  # plot(laz_norm)
  # min(laz_norm@data$Z)
  
  # * dénormaliser
  laz <- lidR::unnormalize_height(laz_norm) # Dénormaliser la hauteur du sol
  return(laz)
}

laz_OutliersRemoved <- RemoveOutliers(laz_scanAngles, mnt)
table(laz_OutliersRemoved@data$Classification)
# plot(laz_OutliersRemoved)
```

```{r}
writeLAS(laz_OutliersRemoved, paste(local,folders,file, "_OutliersRemoved.laz", sep = ""))
```


# Classification des points sols avec lastools 
https://www.sigterritoires.fr/index.php/qgis-pour-lidarmodele-numerique-de-terrain-mnt-avec-lastools/

- LASGround est un outil qui identifie et classe les points du sol dans un nuage de points LiDAR en se basant sur la densité des points voisins. 

- **LASGround_New** est une version améliorée de LASGround, introduite pour fournir de meilleures performances et une extraction plus précise des points du sol.LASGround_New utilise une approche basée sur l’apprentissage automatique (machine learning), en se basant sur des caractéristiques telles que la hauteur, la densité, etc. 
- option **« -nature »** (pas de 5 mètres) ou « -wilderness » (pas de 3 mètres)

## Define the path and the function for lastools executables
```{r}
LAStoolsDir =  "D:/Program/LAStools/bin/"
# LAStoolsDir = "D:/UAV_Vincyane/LAStools/LAStools/bin"

## Define the R function that calls lastools executables
LAStool <- function(tool, inputFile, ...){
  cmd = paste(paste(LAStoolsDir, tool, sep=''), '-i', inputFile , ...) # -i in.laz
  cat(cmd)
  system(cmd)
  return(cmd)
}
```

## In and output
```{r}
# //amap-data.cirad.fr\work\users\VincyaneBadouard\Lidar\HovermapUAV2023\P16_C19C20/Output_subsampled_laz1_4.laz
# Define las/laz files to be processed
# inFiles = "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/P16_C19C20/Output_subsampled_laz1_4.laz"
# subsample <- readLAS("//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/P16_C19C20/Output_subsampled_laz1_4.laz")
# unique(subsample@data$Classification)

# inFiles = paste(local,folders, file, "_OutliersRemoved.laz", sep = "" ) # _OutliersRemoved
# outFile = paste(file, "_GroundClassif_las.laz", sep = "" )

# after retranslation
inFiles = paste(local,folders, file, "_OutliersRemoved.laz", sep = "" )
outFile = paste(file, "_lastoolsclassif.laz", sep = "" )
```

## Call the lastools lasground_new function to classify the ground points
```{r}
cores <- parallel::detectCores()

LASrun <- LAStool('lasground_new', inFiles,
                  '-cores', cores,
                  '-nature', # pas de 5 mètres ( -wilderness : 3 mètres)
                  '-odir', paste(local,folders,sep = ""), # output folder
                  '-o', outFile # -o out.laz
) # 412.865 sec.

# ou avec lidR
# classify_ground(laz_OutliersRemoved, algorithm, last_returns = TRUE) # pmf: , csf: , mcc:  
```
# After classification on CloudCompare, bind laz
```{r}
# subplot <- "UAV_C19C20"
# subplot <- "UAV_C14C15"
# veg <- readLAS(paste(local,folders, subplot, "_translated_VegPoints_CloudCompare.laz", sep = "")) 
# ground <- readLAS(paste(local,folders, subplot, "_translated_GroundPoints_CloudCompare.laz", sep = "")) 
# 
# unique(ground@data$Classification)
# 
# veg@data <- setDT(veg@data)
# ground@data <- setDT(ground@data)
# 
# veg@data[,Classification := 1L]
# ground@data[,Classification := 2L]
# 
# plot(ground)
# range(ground@data$Z) # Points sol : C1920: 6.3823 31.7885; C1415 : 4.6516 25.7552
# 
# # To merge on CloudCompare if not enough RAM
# writeLAS(veg, paste(local,folders, subplot, "_translated_VegPoints_CloudCompareClassif.laz", sep = ""))
# writeLAS(ground, paste(local,folders, subplot, "_translated_GroundPoints_CloudCompareClassif.laz", sep = ""))

# Merge in enough RAM...
# laz_GroundClassif@data <- merge(veg@data, ground@data, all.x = TRUE)
# laz_GroundClassif@data <- rbind(veg@data, ground@data, fill=TRUE)
# veg@data[ground@data, on=]
# writeLAS(laz_GroundClassif, paste(local,folders,file, "_GroundClassif.laz", sep = ""))

```

## Check
```{r}
file <- "UAV_C14C15" # "UAV_C19C20"

laz_GroundClassif <- readLAS(paste(local,folders, file, "_retranslated_lastoolsclassif.laz", sep = "" ))
# laz_GroundClassif <- readLAS(paste(local,folders,file, "_GroundClassif.laz", sep = "" ))
table(laz_GroundClassif@data$Classification) # 2 = sol
# plot(laz_GroundClassif, color = "Classification") # points sols trop hauts !

range(laz_GroundClassif$Z) # 6.3823 65.9298
range(laz_GroundClassif@data[Classification == 2L,]$Z) # Points sol: 6.3823 31.7885
range(laz_GroundClassif@data[Classification == 1L,]$Z) # Points vegetation: 6.6792 65.9298

# presque meme résultat entre lastools et cloudcompare
```

# Générer le MNT sur lastools ou lidR
Calcul du MNT avec LAS2dem :

Cet outil lit les points LIDAR, les triangule temporairement en un TIN, puis calque le TIN sur un raster MNT.
- Le filtre keep_class 2 fait qu’on ne traitera que les points classés « sol » (code 2).
résolution par défaut : 1 m ('-step 1')

## In and output
```{r}
# Define las/laz files to be processed
# inFiles = paste(local,folders,file, "_GroundClassif.laz", sep = "" )
# outFile = paste(file, "_DEM.asc", sep = "" )
```

```{r}
# LASrun <- LAStool('LAS2dem', inFiles,
#                   '-cores', cores,
#                   '-keep_class 2', # que les points sol
#                   '-elevation',
#                   '-o', outFile # -o out.laz
# ) # bloqué par withscecure

# ou avec lidR

# tin() Erreur : Internal error in C_interpolate_delaunay: xy coordinates were not converted to integer. Scale factors are likely to be invalid.
las_quantize(laz_GroundClassif)
laz_GroundClassif <- las_update(laz_GroundClassif) # Update the object to set up-to-date header data
laz_GroundClassif <- las_rescale(laz_GroundClassif, xscale = 0.01, yscale = 0.01)

UAV_DEM <- lidR::rasterize_terrain(laz_GroundClassif, res = 1, algorithm = lidR::tin(), use_class = 2L) # to mnt

# raster::writeRaster(UAV_DEM, file.path(paste(local, folders, file, "_DEM.asc", sep = "")), overwrite=T)
raster::writeRaster(UAV_DEM, file.path(paste(local, folders, file, "_DEM.tif", sep = "")), overwrite=T)

```

## Check
```{r}
UAV_DEM <- raster(paste(local, folders, file, "_DEM.tif", sep = ""))

# Region of Interest (ROI)
ROI <- terra::vect(paste(local,"users/VincyaneBadouard/Lidar/ALS2022/Plot16_4ha_buffer100m.shp", sep = "")) # interest zone + 100m buffer
ROI <- st_as_sf(ROI) # as sf object
ROI <- st_set_crs(ROI, 2972) # attribuer le dernier crs
crs(UAV_DEM) <- crs(ROI)

ggplot() + 
  tidyterra::geom_spatraster(data = UAV_DEM, aes(fill = Z)) +
  scale_fill_gradientn(name = "Elevation (m)",
                       colors = terrain.colors(30, rev=T), na.value="white") +
  geom_sf(data = sf::st_cast(ROI, "LINESTRING")) +
  ggtitle("Paracou P16: MNT - UAV 2023 (1m)") +
  theme_classic() +
  coord_sf()

ggsave(paste(file, "_DEM2_1m.png", sep = "" ), path = "D:/Mes Donnees/PhD/Figures/lidar/UAV", width = 25, height = 15, units = "cm", dpi=800, bg="white")
```

## Crop mnt (9ha)
```{r}
UAV_DEMROI <- raster::mask(UAV_DEM,ROI)
UAV_DEMROI <- raster::crop(UAV_DEMROI,ROI)

mntROI <- resample(mnt,UAV_DEMROI)

ggplot() + 
  tidyterra::geom_spatraster(data = mntROI, aes(fill = dtm2023_4ha_HighAlt_buffer)) + # mnt_roi36ha_1m # dtm2023
  scale_fill_gradientn(name = "Elevation (m)",
                       colors = terrain.colors(30, rev=T),
                       na.value="white") +
  theme_classic() +
  geom_sf(data = sf::st_cast(ROI, "LINESTRING"))

ggsave(paste(file, "_ALS_DEM2_1m_crop.png", sep = "" ), path = "D:/Mes Donnees/PhD/Figures/lidar/UAV", width = 25, height = 15, units = "cm", dpi=800, bg="white")
```

## Check ALS UAV match
```{r}
# 5-2 =3
diffmnt <- mntROI - UAV_DEMROI

ggplot() + 
  tidyterra::geom_spatraster(data = diffmnt, aes(fill = dtm2023_4ha_HighAlt_buffer)) + # mnt_roi36ha_1m # dtm2023
  scale_fill_gradientn(name = "Elevation difference (m)",
                       colors = terrain.colors(30, rev=T),
                       na.value="white") +
  theme_classic() +
  geom_sf(data = sf::st_cast(ROI, "LINESTRING")) +
  ggtitle("Paracou P16: MNT (1m) - ALS-UAV 2023 difference") +
  theme_classic() +
  coord_sf()

ggsave(paste("ALS-", file, "_2023_DEM_difference2.png", sep = ""), path = "D:/Mes Donnees/PhD/Figures/lidar/UAV", width = 25, height = 15, units = "cm", dpi=800, bg="white")
```
# Fusion

## Merge DEMs
```{r}
mnt_C14C15 <- rast("//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/AMAPVox/MNT/dtm2023_4ha_UAV_C14C15_buffer.asc")
mnt_C19C20 <- rast("//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/AMAPVox/MNT/dtm2023_4ha_UAV_C19C20_buffer.asc")

mnt_UAV <- raster::merge(mnt_C14C15, mnt_C19C20, first = T)
crs(mnt_UAV) <- crs(ROI)

ggplot() + 
  tidyterra::geom_spatraster(data = mnt_UAV, aes(fill = dtm2023_4ha_UAV_C14C15_buffer)) + 
  scale_fill_gradientn(name = "Elevation (m)",
                       colors = terrain.colors(30, rev=T),
                       na.value="white") +
  theme_classic() +
  geom_sf(data = sf::st_cast(ROI, "LINESTRING")) +
  ggtitle("Paracou P16: DEM (1m) - UAV 2023") +
  theme_classic() +
  coord_sf()

ggsave("P16_4ha_buffer_UAV_2023_DEM_1m.png", path = "D:/Mes Donnees/PhD/Figures/lidar/UAV", width = 25, height = 15, units = "cm", dpi=800, bg="white")

writeRaster(raster(mnt_UAV),
            "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/AMAPVox/MNT/dtm2023_4ha_UAV_buffer.asc",
            format="ascii", overwrite=T)
```
## Merge point clouds
```{r}
# Define the path for lastools executables
LAStoolsDir =  "D:/Program/LAStools/bin/"

# Define the R function that calls lastools executables
LAStool <- function(tool, inputFile, ...){
  cmd = paste(paste(LAStoolsDir, tool, sep=''), '-i', inputFile , ...)
  cat(cmd)
  system(cmd)
  return(cmd)
}

# Define las/laz files to be processed
inFiles <- paste("//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/AMAPVox/LAZ", '/*.laz', sep='') # files
outFile = "P16_2023_UAV_4ha_buffer_intensitycor_lastools.laz"
outDir <- "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/AMAPVox/LAZ"

# Merge files
LASrun <- LAStool('lasmerge64', inFiles,
                  '-odir', outDir,
                  # '-odix _cor',
                  '-unique',
                  '-o', outFile)
# WARNING: files have different attribute 0
```

## Merge trajectories
```{r}
traj_C14C15 <- fread("//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/AMAPVox/Traj/UAV_C14C15_traj_retranslated.xyz")
traj_C19C20 <- fread("//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/AMAPVox/Traj/UAV_C19C20_traj_retranslated.xyz")

traj_UAV <- rbind(traj_C14C15, traj_C19C20)

fwrite(traj_UAV, "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/AMAPVox/Traj/UAV_P16_4ha_traj.txt")
```


# Crop mnt (4ha)
```{r}
Understory <- vect("//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2022/Parcelles_Understory.shp") 
Understory <- st_as_sf(Understory) # as sf object
Understory <- st_set_crs(Understory, 2972) # attribuer le dernier crs

mnt_UAV <- raster::mask(mnt_UAV,Understory)
mnt_UAV <- raster::crop(mnt_UAV,Understory)

ggplot() + 
  tidyterra::geom_spatraster(data = mnt_UAV, aes(fill = dtm2023_4ha_UAV_C14C15_buffer)) +
  scale_fill_gradientn(name = "Elevation (m)",
                       colors = terrain.colors(30, rev=T),
                       na.value="white") +
  theme_classic() +
  geom_sf(data = sf::st_cast(Understory, "LINESTRING")) +
  ggtitle("Paracou P16 4ha: DEM (1m) - UAV 2023") +
  theme_classic() +
  coord_sf()

ggsave("P16_4ha_UAV_2023_DEM_1m.png", path = "D:/Mes Donnees/PhD/Figures/lidar/UAV", width = 25, height = 15, units = "cm", dpi=800, bg="white")

writeRaster(raster(mnt_UAV),
            "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/HovermapUAV2023/Processed/dtm2023_4ha_UAV.asc",
            format="ascii", overwrite=T)
```


# Buffer d’ALS
