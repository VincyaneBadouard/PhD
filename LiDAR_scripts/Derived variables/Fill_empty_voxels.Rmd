---
title: "Fill empty voxels"
author: "Vincyane Badouard"
date: '`r Sys.Date()`'
output:
  html_document: default
editor_options: 
  markdown: 
    wrap: 72
---

Source: Adapted to the script of Grégoire Vincent.

Certains voxels (en bas de canopée) ne sont pas ou mal échantillonnés
(seuil) du fait de l’occlusion des tirs LiDAR. Ces données manquantes
ont été comblées en appliquant la **moyenne des valeurs de transmittance
des 26 voisins les plus proches**.

Ce ne sont pas des trouées, mais des voxels perdus dans le nuage végétal

Estimer selon le plus probable et selon les besoins Prendre en compte le
voisinage en excluant les trouées

3 possibilités si pas de voisins : - une valeur fallback (fait
actuellement) - augmenter le voisinage - tourner le script plusieurs de
fois et faire donc du proche en proche

1)  get the vegetation voxels only (z \> 0.5 m)

2)  Choose a threshold (pulse.min) to consider an poorly sampled voxel:
- before : nbSampling <25
- now : median(fullcanopy@data$nbSampling)
- test for low altitude lidar : 4,12,20,28,44

Compute a reasonnable fallback value (the median of attenuation) if
local re-estimation fails

3)  Re-estimation of poorly sampled voxels

-   subset of voxels below sampling threshold level (=*nbsampling
median* of the data)
-   but all voxels can contribute to local estimate
-   Get neighbors in immediate neighborhood (27 nearest voxels including
target = 3 neighbors)
-   Recompute attenuation from local neighbourhood :
sum(bsIntercepted)/sum(weightedFreepathLength)
-   When no value was found, take the fallback value

4)  Create PadBVTotal

# Packages

```{r, include = F}
library(AMAPVox)
library(rgl)
library(lattice)
library(data.table)
library(MASS)
library(ggplot2)
library(tidyverse)
rm(list=ls())
```

# Function
```{r}
##### New function defined here #####
##### just a poor hack of fillNA #####
# HLE : hierarchical local estimation
# HLE = bsIntercepted/weightedFreepathLength (default attenuation) (?)
# HLE max quand rencontre un tronc sur tout un voxel 

HLE <- function (
    vxsp, # espace voxel
    variable.name1 = bsIntercepted, # nbr de pulses interceptés par l'empreinte du faisceau = surface occluse dans le faisceau
    variable.name2 = weightedFreepathLength, # longueur des trajets optiques pondérée par l'empreinte du faisceau
    variable.min = -Inf, variable.max = Inf, # bornes pas forcément utiles
    variable.fallback, #  valeur d'atténuation si l'algorithme n'en a pas trouvée
    radius = 2, # rayon de voisinage en mètre
    pulse.min = 25 # nbr de pulses satisfaisant pour faire une estimation locale (threshold)
    
){
  # Checks
  stopifnot(is.VoxelSpace(vxsp))
  stopifnot(variable.name1 %in% colnames(vxsp@data),
            length(variable.name1) == 1)
  stopifnot(variable.name2 %in% colnames(vxsp@data),
            length(variable.name2) == 1)
  stopifnot(is.numeric(variable.min), length(variable.min) == 
              1, is.numeric(variable.max), length(variable.max) == 
              1, !is.na(variable.min))
  
  if (!missing(variable.fallback)) 
    stopifnot(is.numeric(variable.fallback), length(variable.fallback) == 1,
              !is.na(variable.fallback))
  
  if (missing(radius)) 
    radius <- max(getVoxelSize(vxsp)) # if no radius take the max voxelsize
  stopifnot(is.numeric(radius), length(radius) == 1, !is.na(radius))
  
  stopifnot(is.numeric(pulse.min), pulse.min >= 0, !is.na(pulse.min))
  
  # fct
  vx <- vxsp@data
  
  # Put an NA if the pulse number is too low
  vx.na <- vx[nbSampling < pulse.min] # subset of voxels below sampling threshold level
  vx.pool <- vx # all voxels can contribute to local estimate!
  radius <- max(getVoxelSize(vxsp), radius) # radius would be at less the voxel size 
  
  # Get neighbors in immediate neighborhood (27 nearest voxels including target)
  # This k value could be set as a parameter of the HLE function (for ex. could be 125, i.e.a full step larger)
  
  neighbors <- RANN::nn2(data = getPosition(vxsp, vx.pool), # Nearest Neighbor Search
                         query = getPosition(vxsp, vx.na),
                         k = 27, # k = 27 : 3 voisins
                         searchtype = "radius", radius = radius)
  
  neighbors <- neighbors$nn.idx # keep list of indices only
  
  # Recompute attenuation from local neighborhood : sum(bsIntercepted)/sum(weightedFreepathLength)
  fill.value <- apply(
    neighbors, 1,
    function(nghb) vx.pool[as.vector(nghb), 
                           sum(get(variable.name1), na.rm = T)/sum(get(variable.name2), na.rm=T)]
  )
  
  fill.value[which(is.nan(fill.value))] <- NA # NaN to NA. why would this ever happen?
  
  # When no value was found, take the fallback value
  if (!missing(variable.fallback)) 
    fill.value[which(is.na(fill.value))] <- variable.fallback
  na.count <- length(which(is.na(fill.value))) # how many NA are left?
  
  if (na.count > 0) # if any NAs remain
    warning(paste(na.count, " NA left", "\nSomething went wrong somewhere..."))
  
  # Apply the thresholds
  fill.value[which(fill.value > variable.max)] <- variable.max
  fill.value[which(fill.value < variable.min)] <- variable.min
  
  # HLE = bsIntercepted/weightedFreepathLength
  vxsp@data[, HLE := .(get(variable.name1)/get(variable.name2))] # default attenuation
  vxsp@data[neighbors[,1], HLE := fill.value] # modified attenuation
}
```

# Read voxelSpace

```{r}
vxsp_High <- readVoxelSpace("//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/HighAltitudeFlight/P16_2023_HighAlt_4ha_buffer_equalecho2m.vox")
vxsp_Low <- readVoxelSpace("//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/lowAltitudeFlight/P16_2023_LowAlt_4ha_buffer_equalecho2m.vox")
# vxsp_LowI <- readVoxelSpace("//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/lowAltitudeFlight/P16_2023_LowAlt_4ha_buffer.vox")
# "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/lowAltitudeFlight/P16_2023_LowAlt_4ha_buffer.vox"
# "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2022/P16_2022_4ha_buffer.vox"

# median(vxsp_Low@data$nbSampling)
# median(vxsp_LowI@data$nbSampling)
# 
# hist(vxsp_Low@data$nbSampling, breaks=100)
# hist(vxsp_LowI@data$nbSampling, breaks=100)
# 
# sum(vxsp_Low@data$nbSampling)
# sum(vxsp_LowI@data$nbSampling)

# vxsp
# summary(vxsp@data)
# Pour ALS2023 low altitude le nbsampling est faible "Il n'y a pas d'incohérence dans les données: si tu travailles avec le fichier alt500m tu ne peux guère espérer mieux! Il faut en effet réduire le seuil pour le post-traitement (nbre minimum de tirs)"
```

# First get vegetation voxels only
```{r}
OnlyVegetation <- function(vxsp){
  bcnp <- belowCanopy(vxsp) # enlève tous les voxels au dessus de la canopée
  # summary(bcnp)
  
  dz = getVoxelSize(vxsp)["z"] # Gets the elemental size of a voxel (dx, dy, dz) in meter.
  
  # Considérer tout ce qui est à + de 0.5 m du z=0 comme de la végétation
  veg <- vxsp@data[bcnp, list(i,j,k,ground_distance), # combine data.tables on i,j,k columns
                   on = list(i, j, k)][ground_distance >= (0.5 * dz),
                                       list(i,j,k)] # keep only i,j,k columns
  fullcanopy <- vxsp
  fullcanopy@data <- vxsp@data[veg,,on = list(i,j,k)] # only veg part
  
  return(fullcanopy)
  
}

fullcanopy_High <- OnlyVegetation(vxsp_High)
fullcanopy_Low <- OnlyVegetation(vxsp_Low)
# fullcanopy_LowI <- OnlyVegetation(vxsp_LowI)

# summary(fullcanopy@data)

# median(fullcanopy_Low@data$nbSampling)
# median(fullcanopy_LowI@data$nbSampling)
# hist(fullcanopy_Low@data$nbSampling, breaks=50)
# hist(fullcanopy_LowI@data$nbSampling, breaks=50)
# sum(fullcanopy_Low@data$nbSampling)
# sum(fullcanopy_LowI@data$nbSampling)
```

# Compute a reasonnable fallback value if local re-estimation fails

fallback value = the median of attenuation

nbSampling : nombre d'échantillonage. Prendre les plus fiables (\>=25)

On utilise l'atténuation biaisée pcq la débiaisée ne peut pas être
utilisée à multiple échelle.

Biais d'échantillonage : quand peu échantilloné a tendence à renvoyer
une grande densité

```{r}
# hist(fullcanopy@data$nbSampling, breaks=100)

pulsemin_fbv <- function(fullcanopy){
  # pulse.min <- median(fullcanopy@data$nbSampling) # Low : 4 ; High : 44
  # pulse.min
  pulse.min = 20 # seq(4,28, by=8) =  4 12 20 28 44
  fbv <- median(fullcanopy@data[nbSampling>=pulse.min, na.omit(attenuation_FPL_biasedMLE)]) # 0.0257098
  # fbv
  return(list(pulse.min = pulse.min, fbv=fbv))
}

pulsemin_fbv_High <- pulsemin_fbv(fullcanopy_High)
pulsemin_High <- pulsemin_fbv_High$pulse.min
fbv_High <-  pulsemin_fbv_High$fbv
pulsemin_fbv_Low <- pulsemin_fbv(fullcanopy_Low)
pulsemin_Low <- pulsemin_fbv_Low$pulse.min
fbv_Low <- pulsemin_fbv_Low$fbv

# High : pulse min 44 ->
# Low :
# pulse min 4 -> 0
# pulse min 12 -> fbv 0.021692
# pulse min 20 -> 0.0548681
# pulse min 28 ->  0.1011642
# pulse min 28 ->  0.0258637
```
# Poorly sampled voxels
```{r}
na <- nrow(fullcanopy@data[nbSampling<20])/nrow(fullcanopy@data) # proportion of voxels below sampling threshold level (à garder pour comparer entre les différentes méthodes d'acquisition lidar)
write.csv(na, )
# "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/lowAltitudeFlight/EmptyVoxelsProportion2023LowAlt.csv"
# "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/HighAltitudeFlight/EmptyVoxelsProportion2023HighAlt.csv" # 0.37
# "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2022/EmptyVoxelsProportion2022.csv"
```

## Poorly sampled voxels per altitude
```{r}
Poorly_sampled_voxels_per_altitude <- function(fullcanopy, nbSampling_threshold=20){
  data <- setDF(fullcanopy@data) 
  data <- data %>% 
    mutate(ground_distance_disc = as.integer(ground_distance)) %>% 
    group_by(ground_distance_disc) %>% 
    mutate(Poor = ifelse(nbSampling < nbSampling_threshold, 1, 0)) %>%
    mutate(N_empty_voxels = sum(Poor)) %>% # nbr
    group_by(ground_distance_disc,Poor) %>% 
    mutate(`%_empty_voxels` = n()/nrow(.)*100) %>% # %
    ungroup() %>% 
    filter(Poor==1) %>% 
    # mutate(`%_empty_voxels` = ifelse(Poor==0, 0, `%_empty_voxels`)) %>% 
    dplyr::select(c(ground_distance_disc, N_empty_voxels,`%_empty_voxels`)) %>% 
    filter(ground_distance_disc>=0 & ground_distance_disc<=45) %>% 
    filter(ground_distance_disc %% 2 == F) %>% # de 2 en 2 m d'altitude if res = 2m
    unique()

}

dataHigh <- Poorly_sampled_voxels_per_altitude(fullcanopy_High)
dataLow <- Poorly_sampled_voxels_per_altitude(fullcanopy_Low)
gc()

ggplot(dataLow, aes(x= ground_distance_disc, y= `%_empty_voxels`)) +
  geom_point(data = dataHigh, aes(colour = "High altitude")) +
  geom_line(data = dataHigh, aes(colour = "High altitude")) +
  geom_point(data = dataLow, aes(colour = "Low altitude")) +
  geom_line(data = dataLow, aes(colour = "Low altitude")) +
  scale_colour_manual(values = c("High altitude" = "darkgreen",
                                 "Low altitude" = "green")) +
  ggtitle("P16-2023-4ha+buffer - Proportion of poorly sampled voxels per altitude - res 2m") +
  labs(y="% of poorly sampled voxels (<20 pulses)", x="Ground distance", color = "LiDAR acquisition") +
  coord_flip() +
  xlim(0,45)
# scale_x_continuous(breaks = seq(0,160615, by= 25000))
```

# Re-estimation of poorly sampled voxels
un peu long

```{r}
gc()
HLE(fullcanopy_High, # voxel space (only vegetation)
    variable.name1 = "bsIntercepted",
    variable.name2 = "weightedFreepathLength",
    variable.min = -Inf, variable.max = Inf, 
    variable.fallback = fbv_High, radius = 2, pulse.min = pulsemin_High)

HLE(fullcanopy_Low, # voxel space (only vegetation)
    variable.name1 = "bsIntercepted",
    variable.name2 = "weightedFreepathLength",
    variable.min = -Inf, variable.max = Inf, 
    variable.fallback = fbv_Low, radius = 2, pulse.min = pulsemin_Low)

gc()

"HLE" %in% names(fullcanopy_Low@data)
sum(is.na(fullcanopy@data$HLE)) 
sum(!is.na(fullcanopy@data$HLE)) # 4887658
all(is.na(fullcanopy@data[is.na(HLE)]$bsIntercepted)|is.na(fullcanopy@data[is.na(HLE)]$weightedFreepathLength)|fullcanopy@data[is.na(HLE)]$bsIntercepted==0) # missing HLE is when bsIntercepted or weightedFreepathLength are missing or equal to 0

hist(fullcanopy@data$HLE)
```

# Visualisation
```{r}
VX <- fullcanopy
VX@data <- fullcanopy@data[!is.na(HLE) & HLE<2.5]
AMAPVox::plot(VX, variable.name = "HLE")

plot(HLE~attenuation_FPL_biasedMLE, data=fullcanopy@data[1:1000])
plot(HLE~attenuation_FPL_unbiasedMLE, data=fullcanopy@data[1:10000])
plot(attenuation_FPL_biasedMLE~attenuation_FPL_unbiasedMLE, data=fullcanopy@data[1:1000])

fullcanopy@data[HLE>40,]

hist(fullcanopy@data$attenuation_FPL_unbiasedMLE)

quantile(x=fullcanopy@data$attenuation_FPL_unbiasedMLE, prob=c(0.5,0.9,0.95,0.99), na.rm = T)
range(fullcanopy@data$attenuation_FPL_unbiasedMLE, na.rm = T)
range(na.omit(fullcanopy@data$HLE))

# Replace extreme low and high values
# fullcanopy@data$attenuation_FPL_unbiasedMLE <- pmax(fullcanopy@data$attenuation_FPL_unbiasedMLE,0)
# fullcanopy@data$attenuation_FPL_unbiasedMLE <- pmin(fullcanopy@data$attenuation_FPL_unbiasedMLE, quantile(fullcanopy@data$attenuation_FPL_unbiasedMLE, prob=c(0.99), na.rm = T))
```

# Create PadBVTotal

ref : VINCENT, Gregoire; PIMONT, François; VERLEY, Philippe, 2021, "A
note on PAD/LAD estimators implemented in AMAPVox 1.7",
<doi:10.23708/1AJNMP> , DataSuds, V1

Computes Plant Area Density either from (transmittance or) attenuation
coefficient estimates. PAD is defind as the plant area per unit volume
(PAD plant area / voxel volume = m\^2 / m\^3). Plant area density (PAD
in m2·m−3)

PadBVTotal = 2\* attenuation (soit 2\*-log(transmittance)

PadBVTotal = 2 \* HLE

*AMAPVox::plantAreaDensity utilise une des variables disponibles
"transmittance", "attenuation_FPL_unbiasedMLE" ou "attenuation_PPL_MLE"
et génère une variable du même nom précédé du préfixe "pad\_"*

```{r}
Compute_PAD <- function(fullcanopy, vxsp, fbv){
  fullcanopy@data$HLE[which(is.na(fullcanopy@data$HLE))] <- fbv  # to allow later transmittance computations using AMAPVox
  
  fullcanopy@data$PadBVTotal <- 2*fullcanopy@data$HLE # *2 car hp d'orientation sphérique des feuilles
  
  # Import updated fields
  vxsp@data <- merge(vxsp@data,fullcanopy@data[,.(i,j,k,HLE,PadBVTotal)], by=c("i","j","k"), all.x=T) # veg and ground data
  
  # Fill-in above canopy and below ground voxels with 0 PadBVTotal value
  vxsp@data$PadBVTotal[which(is.na(vxsp@data$PadBVTotal))] <- 0  # to allow later transmittance computations using AMAPVox
  
  return(vxsp)
}

vxsp_High <- Compute_PAD(fullcanopy_High, vxsp_High, fbv_High)
vxsp_Low <- Compute_PAD(fullcanopy_Low, vxsp_Low, fbv_Low)

gc()
```

# Compute Transmittance from attenuation

T = I/Io, where I = transmitted light (“output”) and Io = incident light
(“input”) Transmission=exp\^(-HLE) ?

(l'attenuation n'est pas censé être \>0, elle l'est dues aux
statistiques, mais on ne l'ajuste pas à 0 car en moyenne elle est
débiaisée)

```{r}
Compute_Transmittance <- function(vxsp){
  vxsp@data[,Transmittance := exp(-HLE)] 
  # range(na.omit(vxsp@data$Transmittance))
  return(vxsp)
}
vxsp_High <- Compute_Transmittance(vxsp_High)
vxsp_Low <- Compute_Transmittance(vxsp_Low)


# writeVoxelSpace(vxsp, "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/lowAltitudeFlight/P16_2023_4ha_buffer_LowAlt_PadHLE_pulseMin44.vox")
writeVoxelSpace(vxsp_High, "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/HighAltitudeFlight/P16_2023_4ha_buffer_HighAlt_PadHLE_equalecho2m.vox")
writeVoxelSpace(vxsp_Low, "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/lowAltitudeFlight/P16_2023_4ha_buffer_LowAlt_PadHLE_equalecho2m.vox")

# "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/lowAltitudeFlight/P16_2023_4ha_buffer_LowAlt_PadHLE.vox"
# "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/HighAltitudeFlight/P16_2023_4ha_buffer_HighAlt_PadHLE.vox"
# "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2022/P16_2022_4ha_buffer__PadHLE.vox"
```

# Plot PAD vertical profile

```{r}
vxsp <- readVoxelSpace("//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/HighAltitudeFlight/P16_2023_4ha_buffer_HighAlt_PadHLE.vox")
# "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/HighAltitudeFlight/P16_2023_4ha_buffer_HighAlt_PadHLE.vox"
# "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/lowAltitudeFlight/P16_2023_4ha_buffer_LowAlt_PadHLE.vox"

# Crop voxel to test
# subvox <- crop(vxsp, -50, 50, -50, 50)
# AMAPVox::plot(subvox)
# writeVoxelSpace(subvox,"//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2022/subvox.vox")

data <- vxsp@data %>% 
  filter(nbSampling>0) %>%
  mutate(ground_distance_disc = as.integer(ground_distance)) %>% 
  group_by(ground_distance_disc) %>% 
  mutate(MeanPAD = mean(PadBVTotal)) %>% 
  mutate(MinPAD = min(PadBVTotal)) %>% 
  mutate(MaxPAD = max(PadBVTotal)) %>%
  mutate(MeanNbsampling = mean(nbSampling)) %>% 
  mutate(SdNbsampling = sd(nbSampling)) %>% 
  mutate(MinNbsampling = min(nbSampling)) %>% 
  mutate(MaxNbsampling = max(nbSampling)) %>%
  ungroup()

data %>% 
  select(ground_distance_disc, MeanPAD, MinPAD, MaxPAD) %>% 
  filter(ground_distance_disc>=0 & ground_distance_disc<=60) %>% 
  unique() %>% 
  ggplot(aes(x= ground_distance_disc, y= MeanPAD )) +
  geom_point() + 
  geom_line() +
  #scale_color_viridis_d() +
  # xlim(0,1) +
  # ylim(0,60) +
  ggtitle("P16 - 2023 - 4ha + buffer - HighAlt - PAD profile") +
  # theme(plot.title = element_text(hjust=0.5)) + 
  labs(y="PAD", x="Absolute Tree Height") +
  coord_flip() #+ # coordonnées inversées au départ pour que la ligne suive la hauteur au sol et non le PAD
# geom_errorbar(aes(ymin=MinPAD, ymax=MaxPAD), width=.2)#+ 
# options(repr.plot.width=8, repr.plot.height=15) # higher height
```



