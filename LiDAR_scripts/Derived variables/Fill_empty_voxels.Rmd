---
title: "Fill empty voxels"
author: "Vincyane Badouard"
date: '`r Sys.Date()`'
output:
  html_document: default
editor_options: 
  markdown: 
    wrap: 72
---

Source: Adapted to the script of Grégoire Vincent.

Certains voxels (en bas de canopée) ne sont pas ou mal échantillonnés
(seuil) du fait de l’occlusion des tirs LiDAR. Ces données manquantes
ont été comblées en appliquant la **moyenne des valeurs de transmittance
des 26 voisins les plus proches**.

Ce ne sont pas des trouées, mais des voxels perdus dans le nuage végétal

Estimer selon le plus probable et selon les besoins Prendre en compte le
voisinage en excluant les trouées

3 possibilités si pas de voisins : - une valeur fallback (fait
actuellement) - augmenter le voisinage - tourner le script plusieurs de
fois et faire donc du proche en proche

1)  get the vegetation voxels only (z \> 0.5 m)

2)  Compute a reasonnable fallback value (the median of attenuation) if
local re-estimation fails

3)  Re-estimation of poorly sampled voxels

-   subset of voxels below sampling threshold level (=*nbsampling
median* of the data)
-   but all voxels can contribute to local estimate
-   Get neighbors in immediate neighborhood (27 nearest voxels including
target = 3 neighbors)
-   Recompute attenuation from local neighbourhood :
sum(bsIntercepted)/sum(weightedFreepathLength)
-   When no value was found, take the fallback value

4)  Create PadBVTotal

# Packages

```{r, include = F}
library(AMAPVox)
library(rgl)
library(lattice)
library(data.table)
library(MASS)
library(ggplot2)
library(tidyverse)
rm(list=ls())
```

# Function
```{r}
##### New function defined here #####
##### just a poor hack of fillNA #####
# HLE : hierarchical local estimation
# HLE = bsIntercepted/weightedFreepathLength (default attenuation) (?)
# HLE max quand rencontre un tronc sur tout un voxel 

HLE <- function (
    vxsp, # espace voxel
    variable.name1 = bsIntercepted, # nbr de pulses interceptés par l'empreinte du faisceau = surface occluse dans le faisceau
    variable.name2 = weightedFreepathLength, # longueur des trajets optiques pondérée par l'empreinte du faisceau
    variable.min = -Inf, variable.max = Inf, # bornes pas forcément utiles
    variable.fallback, #  valeur d'atténuation si l'algorithme n'en a pas trouvée
    radius = 2, # rayon de voisinage en mètre
    pulse.min = 25 # nbr de pulses satisfaisant pour faire une estimation locale (threshold)
    
){
  # Checks
  stopifnot(is.VoxelSpace(vxsp))
  stopifnot(variable.name1 %in% colnames(vxsp@data),
            length(variable.name1) == 1)
  stopifnot(variable.name2 %in% colnames(vxsp@data),
            length(variable.name2) == 1)
  stopifnot(is.numeric(variable.min), length(variable.min) == 
              1, is.numeric(variable.max), length(variable.max) == 
              1, !is.na(variable.min))
  
  if (!missing(variable.fallback)) 
    stopifnot(is.numeric(variable.fallback), length(variable.fallback) == 1,
              !is.na(variable.fallback))
  
  if (missing(radius)) 
    radius <- max(getVoxelSize(vxsp)) # if no radius take the max voxelsize
  stopifnot(is.numeric(radius), length(radius) == 1, !is.na(radius))
  
  stopifnot(is.numeric(pulse.min), pulse.min >= 0, !is.na(pulse.min))
  
  # fct
  vx <- vxsp@data
  
  # Put an NA if the pulse number is too low
  vx.na <- vx[nbSampling < pulse.min] # subset of voxels below sampling threshold level
  vx.pool <- vx # all voxels can contribute to local estimate!
  radius <- max(getVoxelSize(vxsp), radius) # radius would be at less the voxel size 
  
  # Get neighbors in immediate neighborhood (27 nearest voxels including target)
  # This k value could be set as a parameter of the HLE function (for ex. could be 125, i.e.a full step larger)
  
  neighbors <- RANN::nn2(data = getPosition(vxsp, vx.pool), # Nearest Neighbor Search
                         query = getPosition(vxsp, vx.na),
                         k = 27, # k = 27 : 3 voisins
                         searchtype = "radius", radius = radius)
  
  neighbors <- neighbors$nn.idx # keep list of indices only
  
  # Recompute attenuation from local neighborhood : sum(bsIntercepted)/sum(weightedFreepathLength)
  fill.value <- apply(
    neighbors, 1,
    function(nghb) vx.pool[as.vector(nghb), 
                           sum(get(variable.name1), na.rm = T)/sum(get(variable.name2), na.rm=T)]
  )
  
  fill.value[which(is.nan(fill.value))] <- NA # NaN to NA. why would this ever happen?
  
  # When no value was found, take the fallback value
  if (!missing(variable.fallback)) 
    fill.value[which(is.na(fill.value))] <- variable.fallback
  na.count <- length(which(is.na(fill.value))) # how many NA are left?
  
  if (na.count > 0) # if any NAs remain
    warning(paste(na.count, " NA left", "\nSomething went wrong somewhere..."))
  
  # Apply the thresholds
  fill.value[which(fill.value > variable.max)] <- variable.max
  fill.value[which(fill.value < variable.min)] <- variable.min
  
  # HLE = bsIntercepted/weightedFreepathLength
  vxsp@data[, HLE := .(get(variable.name1)/get(variable.name2))] # default attenuation
  vxsp@data[neighbors[,1], HLE := fill.value] # modified attenuation
}
```

# Read voxelSpace

```{r}
vxsp <- readVoxelSpace("//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/lowAltitudeFlight/P16_2023_LowAlt_4ha_buffer.vox")
# "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/HighAltitudeFlight/P16_2023_HighAlt_4ha_buffer.vox"
# "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/lowAltitudeFlight/P16_2023_LowAlt_4ha_buffer.vox"
# "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2022/P16_2022_4ha_buffer.vox"
vxsp
summary(vxsp@data)
# Pour ALS2023 low altitude le nbsampling est faible "Il n'y a pas d'incohérence dans les données: si tu travailles avec le fichier alt500m tu ne peux guère espérer mieux! Il faut en effet réduire le seuil pour le post-traitement (nbre minimum de tirs)"
```

# First get vegetation voxels only

```{r}
bcnp <- belowCanopy(vxsp) # enlève tous les voxels au dessus de la canopée
summary(bcnp)

dz = getVoxelSize(vxsp)["z"] # Gets the elemental size of a voxel (dx, dy, dz) in meter.

# Considérer tout ce qui est à + de 0.5 m du z=0 comme de la végétation
veg <- vxsp@data[bcnp, list(i,j,k,ground_distance), # combine data.tables on i,j,k columns
                 on = list(i, j, k)][ground_distance >= (0.5 * dz),
                                     list(i,j,k)] # keep only i,j,k columns
fullcanopy <- vxsp
fullcanopy@data <- vxsp@data[veg,,on = list(i,j,k)] # only veg part

summary(fullcanopy@data)

```

# Compute a reasonnable fallback value if local re-estimation fails

fallback value = the median of attenuation

nbSampling : nombre d'échantillonage. Prendre les plus fiables (\>=25)

On utilise l'atténuation biaisée pcq la débiaisée ne peut pas être
utilisée à multiple échelle.

Biais d'échantillonage : quand peu échantilloné a tendence à renvoyer
une grande densité

```{r}
hist(fullcanopy@data$nbSampling, breaks=100)
pulse.min <- median(fullcanopy@data$nbSampling)
pulse.min

fbv <- median(fullcanopy@data[nbSampling>=pulse.min, na.omit(attenuation_FPL_biasedMLE)]) # 0.0257098
fbv
```

# Re-estimation of poorly sampled voxels

un peu long

```{r}
na <- nrow(fullcanopy@data[nbSampling < 25])/nrow(fullcanopy@data) # proportion of voxels below sampling threshold level (à garder pour comparer entre les différentes méthodes d'acquisition lidar)
write.csv(na, )
# "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/lowAltitudeFlight/EmptyVoxelsProportion2023LowAlt.csv"
# "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/HighAltitudeFlight/EmptyVoxelsProportion2023HighAlt.csv" # 0.37
# "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2022/EmptyVoxelsProportion2022.csv"

HLE(fullcanopy, # voxel space (only vegetation)
    variable.name1 = "bsIntercepted",
    variable.name2 = "weightedFreepathLength",
    variable.min = -Inf, variable.max = Inf, 
    variable.fallback = fbv, radius = 2, pulse.min = pulse.min)

"HLE" %in% names(fullcanopy@data)
sum(is.na(fullcanopy@data$HLE)) 
sum(!is.na(fullcanopy@data$HLE)) # 4887658
all(is.na(fullcanopy@data[is.na(HLE)]$bsIntercepted)|is.na(fullcanopy@data[is.na(HLE)]$weightedFreepathLength)|fullcanopy@data[is.na(HLE)]$bsIntercepted==0) # missing HLE is when bsIntercepted or weightedFreepathLength are missing or equal to 0
```

# Visualisation

```{r}
VX <- fullcanopy
VX@data <- fullcanopy@data[!is.na(HLE) & HLE<2.5]
AMAPVox::plot(VX, variable.name = "HLE")

plot(HLE~attenuation_FPL_biasedMLE, data=fullcanopy@data[1:1000])
plot(HLE~attenuation_FPL_unbiasedMLE, data=fullcanopy@data[1:10000])
plot(attenuation_FPL_biasedMLE~attenuation_FPL_unbiasedMLE, data=fullcanopy@data[1:1000])

fullcanopy@data[HLE>40,]

hist(fullcanopy@data$attenuation_FPL_unbiasedMLE)

quantile(x=fullcanopy@data$attenuation_FPL_unbiasedMLE, prob=c(0.5,0.9,0.95,0.99), na.rm = T)
range(fullcanopy@data$attenuation_FPL_unbiasedMLE, na.rm = T)
range(na.omit(fullcanopy@data$HLE))

# Replace extreme low and high values
# fullcanopy@data$attenuation_FPL_unbiasedMLE <- pmax(fullcanopy@data$attenuation_FPL_unbiasedMLE,0)
# fullcanopy@data$attenuation_FPL_unbiasedMLE <- pmin(fullcanopy@data$attenuation_FPL_unbiasedMLE, quantile(fullcanopy@data$attenuation_FPL_unbiasedMLE, prob=c(0.99), na.rm = T))
```

# Create PadBVTotal

ref : VINCENT, Gregoire; PIMONT, François; VERLEY, Philippe, 2021, "A
note on PAD/LAD estimators implemented in AMAPVox 1.7",
<doi:10.23708/1AJNMP> , DataSuds, V1

Computes Plant Area Density either from (transmittance or) attenuation
coefficient estimates. PAD is defind as the plant area per unit volume
(PAD plant area / voxel volume = m\^2 / m\^3). Plant area density (PAD
in m2·m−3)

PadBVTotal = 2\* attenuation (soit 2\*-log(transmittance)

PadBVTotal = 2 \* HLE

*AMAPVox::plantAreaDensity utilise une des variables disponibles
"transmittance", "attenuation_FPL_unbiasedMLE" ou "attenuation_PPL_MLE"
et génère une variable du même nom précédé du préfixe "pad\_"*

```{r}
fullcanopy@data$HLE[which(is.na(fullcanopy@data$HLE))] <- fbv  # to allow later transmittance computations using AMAPVox

fullcanopy@data$PadBVTotal <- 2*fullcanopy@data$HLE # *2 car hp d'orientation sphérique des feuilles

# Import updated fields
vxsp@data <- merge(vxsp@data,fullcanopy@data[,.(i,j,k,HLE,PadBVTotal)], by=c("i","j","k"), all.x=T) # veg and ground data

# Fill-in above canopy and below ground voxels with 0 PadBVTotal value
vxsp@data$PadBVTotal[which(is.na(vxsp@data$PadBVTotal))] <- 0  # to allow later transmittance computations using AMAPVox
```

# Compute Transmittance from attenuation

T = I/Io, where I = transmitted light (“output”) and Io = incident light
(“input”) Transmission=exp\^(-HLE) ?

(l'attenuation n'est pas censé être \>0, elle l'est dues aux
statistiques, mais on ne l'ajuste pas à 0 car en moyenne elle est
débiaisée)

```{r}
vxsp@data[,Transmittance := exp(-HLE)] 
range(na.omit(vxsp@data$Transmittance))

writeVoxelSpace(vxsp, "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/lowAltitudeFlight/P16_2023_4ha_buffer_LowAlt_PadHLE.vox")
# "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/lowAltitudeFlight/P16_2023_4ha_buffer_LowAlt_PadHLE.vox"
# "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/HighAltitudeFlight/P16_2023_4ha_buffer_HighAlt_PadHLE.vox"
# "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2022/P16_2022_4ha_buffer__PadHLE.vox"
```

# Plot vertical profile

```{r}
vxsp <- readVoxelSpace("//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/HighAltitudeFlight/P16_2023_4ha_buffer_HighAlt_PadHLE.vox")
# "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/HighAltitudeFlight/P16_2023_4ha_buffer_HighAlt_PadHLE.vox"
# "//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2023/lowAltitudeFlight/P16_2023_4ha_buffer_LowAlt_PadHLE.vox"

# Crop voxel to test
# subvox <- crop(vxsp, -50, 50, -50, 50)
# AMAPVox::plot(subvox)
# writeVoxelSpace(subvox,"//amap-data.cirad.fr/work/users/VincyaneBadouard/Lidar/ALS2022/subvox.vox")

data <- vxsp@data %>% 
  filter(nbSampling>0) %>%
  mutate(ground_distance_disc = as.integer(ground_distance)) %>% 
  group_by(ground_distance_disc) %>% 
  mutate(MeanPAD = mean(PadBVTotal)) %>% 
  mutate(MinPAD = min(PadBVTotal)) %>% 
  mutate(MaxPAD = max(PadBVTotal)) %>%
  mutate(MeanNbsampling = mean(nbSampling)) %>% 
  mutate(SdNbsampling = sd(nbSampling)) %>% 
  mutate(MinNbsampling = min(nbSampling)) %>% 
  mutate(MaxNbsampling = max(nbSampling)) %>%
  ungroup()

data %>% 
  select(ground_distance_disc, MeanPAD, MinPAD, MaxPAD) %>% 
  filter(ground_distance_disc>=0 & ground_distance_disc<=60) %>% 
  unique() %>% 
  ggplot(aes(x= ground_distance_disc, y= MeanPAD )) +
  geom_point() + 
  geom_line() +
  #scale_color_viridis_d() +
  # xlim(0,1) +
  # ylim(0,60) +
  ggtitle("P16 - 2023 - 4ha + buffer - HighAlt - PAD profile") +
  # theme(plot.title = element_text(hjust=0.5)) + 
  labs(y="PAD", x="Absolute Tree Height") +
  coord_flip() #+ # coordonnées inversées au départ pour que la ligne suive la hauteur au sol et non le PAD
  # geom_errorbar(aes(ymin=MinPAD, ymax=MaxPAD), width=.2)#+ 
# options(repr.plot.width=8, repr.plot.height=15) # higher height
```

# Plot extinction profiles
```{r}
data %>% 
  filter(ground_distance_disc>=0 & ground_distance_disc<=60) %>% 
  select(ground_distance_disc, MeanNbsampling, SdNbsampling) %>% 
  unique() %>% 
  ggplot(aes(x= ground_distance_disc, y= MeanNbsampling)) +
  geom_point() + 
  geom_line() +
  #scale_color_viridis_d() +
  # xlim(0,1) +
  # ylim(0,60) +
  ggtitle("P16 - 2023 - 4ha + buffer - HighAlt - extinction profile") +
  # theme(plot.title = element_text(hjust=0.5)) + 
  labs(y="Sampling", x="Absolute Tree Height") +
  coord_flip() +
  geom_errorbar(aes(ymin=MeanNbsampling-SdNbsampling, ymax=MeanNbsampling+SdNbsampling), width=.2)

data %>% 
  filter(ground_distance_disc>=0 & ground_distance_disc<=60) %>% 
  select(ground_distance_disc, MeanNbsampling, MinNbsampling, MaxNbsampling) %>% 
  unique() %>% 
  ggplot(aes(x= ground_distance_disc, y= MeanNbsampling)) +
  geom_point() + 
  geom_line() +
  #scale_color_viridis_d() +
  # xlim(0,1) +
  # ylim(0,60) +
  ggtitle("P16 - 2023 - 4ha + buffer - HighAlt - extinction profile") +
  # theme(plot.title = element_text(hjust=0.5)) + 
  labs(y="Sampling", x="Absolute Tree Height") +
  coord_flip() +
  geom_errorbar(aes(ymin=MinNbsampling, ymax=MaxNbsampling), width=.2)
```

# Test decim dans amapvox (80%) pour savoir à combien de pulse on fait confiance

fichier CheckEffectDecimation.R

full - decim = écart systématique ou non selon le numbre de pulse
